<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>accel-driv — Track Suite</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&family=Outfit:wght@300;400;600;700&display=swap');
  *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  :root{--bg:#0a0a0f;--surface:#12121a;--surface2:#1a1a28;--border:#2a2a3a;--text:#e0e0f0;--text-dim:#7a7a9a;--accent:#ff6b35;--accent2:#00d4aa;--accent3:#5b8cff;--danger:#ff4466;--cp-color:#ffcc00;--drawer-height:58vh}
  body{background:var(--bg);color:var(--text);font-family:'Outfit',sans-serif;overflow:hidden;height:100dvh;width:100vw;touch-action:none}
  #app{display:flex;height:100dvh;width:100vw}
  #sidebar{width:330px;min-width:330px;background:var(--surface);border-right:1px solid var(--border);display:flex;flex-direction:column;z-index:10;overflow-y:auto;overflow-x:hidden}
  #sidebar::-webkit-scrollbar{width:4px}#sidebar::-webkit-scrollbar-track{background:transparent}#sidebar::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
  .drawer-toggle{display:none;width:100%;padding:8px 0;text-align:center;cursor:pointer;flex-shrink:0;-webkit-user-select:none;user-select:none}
  .drawer-toggle span{display:inline-block;font-size:18px;color:var(--text-dim);transition:transform .3s}
  #sidebar.open .drawer-toggle span{transform:rotate(180deg)}
  .sidebar-header{padding:14px 16px 10px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between}
  .sidebar-header h1{font-size:15px;font-weight:700;letter-spacing:-0.5px;color:var(--accent);font-family:'JetBrains Mono',monospace}
  .sidebar-header .subtitle{font-size:10px;color:var(--text-dim);font-family:'JetBrains Mono',monospace}
  .panel{padding:12px 14px;border-bottom:1px solid var(--border)}
  .panel-title{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:1.5px;color:var(--text-dim);margin-bottom:8px}
  .stat-row{display:flex;justify-content:space-between;align-items:center;font-size:12px;margin-bottom:4px}
  .stat-label{color:var(--text-dim)}.stat-value{color:var(--text);font-family:'JetBrains Mono',monospace;font-size:11px}
  .btn-group{display:flex;gap:5px;flex-wrap:wrap;margin-bottom:6px}
  .btn{background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:7px 10px;border-radius:6px;font-size:11px;cursor:pointer;font-family:'Outfit',sans-serif;transition:all .15s;flex:1;min-width:60px;text-align:center;-webkit-user-select:none;user-select:none}
  .btn:hover{background:var(--border);border-color:var(--text-dim)}.btn:active{transform:scale(.96)}
  .btn-accent{border-color:var(--accent);color:var(--accent)}.btn-accent:hover{background:var(--accent);color:#000}
  .btn-accent2{border-color:var(--accent2);color:var(--accent2)}.btn-accent2:hover{background:var(--accent2);color:#000}
  .btn-danger{border-color:var(--danger);color:var(--danger)}.btn-danger:hover{background:var(--danger);color:#fff}
  .btn-cp{border-color:var(--cp-color);color:var(--cp-color)}.btn-cp:hover{background:var(--cp-color);color:#000}
  .slider-group{margin-bottom:8px}
  .slider-label{display:flex;justify-content:space-between;font-size:11px;margin-bottom:3px;color:var(--text-dim)}
  .slider-label span:last-child{color:var(--accent);font-family:'JetBrains Mono',monospace}
  input[type="range"]{width:100%;height:5px;-webkit-appearance:none;background:var(--border);border-radius:3px;outline:none}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid var(--bg)}
  label.chk{display:flex;align-items:center;gap:8px;font-size:11px;color:var(--text-dim);margin-bottom:5px;cursor:pointer;padding:2px 0}
  label.chk input[type="checkbox"]{width:16px;height:16px}
  .top-tabs{display:flex;gap:0;border-bottom:1px solid var(--border);flex-shrink:0}
  .top-tab{flex:1;padding:10px 6px;background:var(--surface);border:none;border-bottom:2px solid transparent;font-size:12px;font-weight:600;color:var(--text-dim);cursor:pointer;text-align:center;font-family:'Outfit',sans-serif;transition:all .15s;-webkit-user-select:none;user-select:none}
  .top-tab.active{color:var(--accent);border-bottom-color:var(--accent);background:var(--surface2)}
  .top-tab:hover:not(.active){background:var(--surface2);color:var(--text)}
  .mode-tabs{display:flex;gap:3px;margin-bottom:10px}
  .mode-tab{flex:1;padding:6px 4px;background:var(--surface2);border:1px solid var(--border);border-radius:5px;font-size:11px;color:var(--text-dim);cursor:pointer;text-align:center;font-family:'Outfit',sans-serif;transition:all .15s;-webkit-user-select:none;user-select:none}
  .mode-tab.active{background:var(--accent);color:#000;border-color:var(--accent);font-weight:600}
  .mode-tab:hover:not(.active){background:var(--border)}
  .cp-input-row{display:flex;align-items:center;gap:6px;margin-bottom:3px}
  .cp-input-row label{font-size:10px;font-family:'JetBrains Mono',monospace;color:var(--text-dim);width:24px}
  .cp-input-row input{flex:1;background:var(--bg);border:1px solid var(--border);color:var(--text);padding:5px 6px;border-radius:4px;font-size:12px;font-family:'JetBrains Mono',monospace}
  .color-row{display:flex;align-items:center;gap:6px;margin-bottom:5px;font-size:11px;color:var(--text-dim)}
  .color-row input[type="color"]{width:24px;height:20px;border:1px solid var(--border);background:none;border-radius:3px;cursor:pointer;padding:0}
  .width-viz{margin-top:6px;background:var(--bg);border:1px solid var(--border);border-radius:5px;padding:6px}
  .width-viz canvas{width:100%;height:50px;display:block;border-radius:3px}
  #viewport{flex:1;position:relative;overflow:hidden}#viewport canvas{display:block;touch-action:none}
  #mobile-toolbar{display:none;position:absolute;top:10px;left:10px;right:10px;z-index:15;gap:5px}
  #mobile-toolbar .mtb-btn{background:rgba(18,18,26,.9);border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:8px;font-size:15px;cursor:pointer;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);line-height:1}
  #toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%) translateY(80px);background:var(--surface2);border:1px solid var(--accent);color:var(--text);padding:8px 20px;border-radius:8px;font-size:12px;font-family:'JetBrains Mono',monospace;z-index:200;opacity:0;transition:all .3s;pointer-events:none;white-space:nowrap}
  #toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
  #help-overlay{position:absolute;bottom:10px;right:10px;background:rgba(10,10,15,.85);border:1px solid var(--border);border-radius:8px;padding:8px 12px;font-size:10px;color:var(--text-dim);font-family:'JetBrains Mono',monospace;line-height:1.7;z-index:5;pointer-events:none}
  #help-overlay kbd{background:var(--surface2);border:1px solid var(--border);padding:1px 4px;border-radius:3px;color:var(--text);font-size:9px}
  #file-input{display:none}
  .tab-content{display:none}.tab-content.active{display:block}
  @media(max-width:768px){
    #app{flex-direction:column}
    #sidebar{position:fixed;bottom:0;left:0;right:0;width:100%;min-width:100%;height:var(--drawer-height);border-right:none;border-top:1px solid var(--border);border-radius:16px 16px 0 0;z-index:50;transform:translateY(calc(var(--drawer-height) - 48px));transition:transform .35s cubic-bezier(.4,0,.2,1);will-change:transform}
    #sidebar.open{transform:translateY(0)}
    .drawer-toggle{display:block}
    #viewport{height:100dvh;width:100vw;padding-bottom:48px}
    #mobile-toolbar{display:flex}#help-overlay{display:none}
    .btn{padding:9px 10px;font-size:12px;min-height:38px}.mode-tab{padding:8px 4px;font-size:12px;min-height:36px}
    .top-tab{padding:9px 4px;font-size:12px}
    input[type="range"]::-webkit-slider-thumb{width:22px;height:22px}input[type="range"]{height:7px}
    #toast{bottom:58px;font-size:11px;padding:7px 14px}
  }
</style>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <div class="drawer-toggle" onclick="toggleDrawer()"><span>&#9650;</span></div>
    <div class="sidebar-header"><div><h1>ACCEL-DRIV</h1><div class="subtitle">track suite</div></div></div>
    <div class="top-tabs">
      <button class="top-tab active" data-tab="track" onclick="switchTab('track')">Track</button>
      <button class="top-tab" data-tab="terrain" onclick="switchTab('terrain')">Terrain</button>
      <button class="top-tab" data-tab="gameplay" onclick="switchTab('gameplay')">Game</button>
      <button class="top-tab" data-tab="play" onclick="switchTab('play')" style="color:var(--accent)">Play</button>
      <button class="top-tab" data-tab="splat" onclick="switchTab('splat')">Splat</button>
    </div>

<!-- ===== TRACK TAB ===== -->
<div class="tab-content active" id="tab-track">
  <div class="panel"><div class="panel-title">File</div><div class="btn-group"><button class="btn" onclick="loadFile()">Load</button><button class="btn btn-accent" onclick="exportTrack()">Export</button><button class="btn" onclick="undoAll()">Undo</button></div><input type="file" id="file-input" accept=".json" onchange="handleFile(event)"></div>
  <div class="panel"><div class="panel-title">Image to Track</div>
    <div class="btn-group"><button class="btn btn-accent2" onclick="document.getElementById('img-input').click()">Upload Image</button></div>
    <input type="file" id="img-input" accept="image/*" onchange="handleImageUpload(event)" style="display:none">
    <div class="slider-group"><div class="slider-label"><span>Track scale</span><span id="v-imgscale">2000</span></div><input type="range" id="s-imgscale" min="500" max="8000" value="2000" step="100"></div>
    <div class="slider-group"><div class="slider-label"><span>Point count</span><span id="v-imgpts">200</span></div><input type="range" id="s-imgpts" min="50" max="500" value="200" step="10"></div>
    <div class="slider-group"><div class="slider-label"><span>Smoothing</span><span id="v-imgsmooth">3</span></div><input type="range" id="s-imgsmooth" min="0" max="10" value="3" step="1"></div>
    <div id="img-preview" style="display:none;margin-top:8px;border:1px solid var(--border);border-radius:6px;overflow:hidden;position:relative"><canvas id="img-canvas" style="width:100%;display:block"></canvas><div id="img-status" style="position:absolute;bottom:4px;left:6px;font-size:10px;color:var(--accent);font-family:'JetBrains Mono',monospace;background:rgba(0,0,0,.7);padding:2px 6px;border-radius:3px"></div></div>
  </div>
  <div class="panel"><div class="panel-title">Track Info</div><div class="stat-row"><span class="stat-label">Points</span><span class="stat-value" id="stat-points">--</span></div><div class="stat-row"><span class="stat-label">Control Points</span><span class="stat-value" id="stat-cp">--</span></div><div class="stat-row"><span class="stat-label">Length</span><span class="stat-value" id="stat-length">--</span></div><div class="stat-row"><span class="stat-label">Elevation</span><span class="stat-value" id="stat-elevation">--</span></div></div>
  <div class="panel"><div class="panel-title">Edit Mode</div>
    <div class="mode-tabs"><button class="mode-tab active" data-mode="select" onclick="setEditMode('select')">Select</button><button class="mode-tab" data-mode="control-points" onclick="setEditMode('control-points')">Control Pts</button><button class="mode-tab" data-mode="width" onclick="setEditMode('width')">Width</button></div>
    <div id="mode-select"><div class="slider-group"><div class="slider-label"><span>Smooth iterations</span><span id="smooth-iter-val">3</span></div><input type="range" id="smooth-iter" min="1" max="20" value="3"></div><div class="slider-group"><div class="slider-label"><span>Smooth strength</span><span id="smooth-str-val">0.5</span></div><input type="range" id="smooth-str" min="0.1" max="1" step="0.1" value="0.5"></div><div class="btn-group"><button class="btn btn-accent2" onclick="smoothSelection()">Smooth Sel</button><button class="btn" onclick="smoothAll()">Smooth All</button></div><div class="slider-group"><div class="slider-label"><span>Elevation offset</span><span id="elev-val">0</span></div><input type="range" id="elev-offset" min="-200" max="200" value="0" step="1"></div><button class="btn" onclick="applyElevation()">Apply Elevation</button></div>
    <div id="mode-control-points" style="display:none"><div class="slider-group"><div class="slider-label"><span>CP count</span><span id="cp-count-val">20</span></div><input type="range" id="cp-count" min="5" max="80" value="20" step="1"></div><div class="slider-group"><div class="slider-label"><span>Spline resolution</span><span id="spline-res-val">10</span></div><input type="range" id="spline-resolution" min="2" max="30" value="10" step="1"></div><div class="btn-group"><button class="btn btn-cp" onclick="extractControlPoints()">Extract</button><button class="btn btn-accent2" onclick="rebuildFromSpline()">Rebuild</button></div><label class="chk"><input type="checkbox" id="show-cp-handles" checked><span>Show drag handles</span></label><div id="cp-selected-panel" style="display:none"><div style="margin-top:6px"><div class="stat-row"><span class="stat-label">CP Index</span><span class="stat-value" id="cp-sel-idx">--</span></div><div class="cp-input-row"><label>X</label><input type="number" id="cp-x" step="1" onchange="updateCPFromInput()"></div><div class="cp-input-row"><label>Y</label><input type="number" id="cp-y" step="1" onchange="updateCPFromInput()"></div><div class="cp-input-row"><label>Z</label><input type="number" id="cp-z" step="1" onchange="updateCPFromInput()"></div><div class="btn-group" style="margin-top:6px"><button class="btn" onclick="insertCPAfter()">+ Insert</button><button class="btn btn-danger" onclick="deleteSelectedCP()">Delete</button></div></div></div></div>
    <div id="mode-width" style="display:none"><div class="slider-group"><div class="slider-label"><span>Default width</span><span id="default-width-val">30</span></div><input type="range" id="default-width" min="5" max="100" value="30" step="1" oninput="onDefaultWidthChange()"></div><div class="btn-group"><button class="btn btn-accent2" onclick="setAllWidths()">Set All Default</button><button class="btn btn-cp" onclick="extractControlPoints()">Extract</button></div><div id="width-cp-panel" style="display:none;margin-top:8px"><div class="stat-row"><span class="stat-label">CP Index</span><span class="stat-value" id="width-cp-idx">--</span></div><div class="slider-group"><div class="slider-label"><span>Width at CP</span><span id="cp-width-val">30</span></div><input type="range" id="cp-width" min="5" max="150" value="30" step="1" oninput="onCPWidthChange()"></div><div class="btn-group"><button class="btn" onclick="widthPreset(15)">15</button><button class="btn" onclick="widthPreset(30)">30</button><button class="btn" onclick="widthPreset(60)">60</button><button class="btn" onclick="widthPreset(100)">100</button></div></div><div class="width-viz"><canvas id="width-graph"></canvas></div><div class="btn-group" style="margin-top:6px"><button class="btn btn-accent" onclick="rebuildWithWidth()">Rebuild Width</button></div></div>
  </div>
  <div class="panel"><div class="panel-title">Loop</div><div class="slider-group"><div class="slider-label"><span>Blend distance</span><span id="loop-blend-val">200</span></div><input type="range" id="loop-blend" min="50" max="800" value="200" step="10"></div><div class="slider-group"><div class="slider-label"><span>Points</span><span id="loop-pts-val">40</span></div><input type="range" id="loop-pts" min="10" max="200" value="40" step="5"></div><div class="btn-group"><button class="btn btn-accent2" onclick="previewLoop()">Preview</button><button class="btn btn-accent" onclick="makeLoop()">Loop</button><button class="btn btn-danger" onclick="removeLoop()">Unloop</button></div></div>
</div>

<!-- ===== TERRAIN TAB ===== -->
<div class="tab-content" id="tab-terrain">
  <div class="panel"><div class="panel-title">Noise</div>
    <div class="slider-group"><div class="slider-label"><span>Amplitude</span><span id="v-amp">80</span></div><input type="range" id="s-amp" min="5" max="300" value="80" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Frequency</span><span id="v-freq">0.003</span></div><input type="range" id="s-freq" min="0.0005" max="0.02" value="0.003" step="0.0005"></div>
    <div class="slider-group"><div class="slider-label"><span>Octaves</span><span id="v-oct">4</span></div><input type="range" id="s-oct" min="1" max="8" value="4" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Lacunarity</span><span id="v-lac">2.0</span></div><input type="range" id="s-lac" min="1.2" max="4" value="2.0" step="0.1"></div>
    <div class="slider-group"><div class="slider-label"><span>Persistence</span><span id="v-per">0.5</span></div><input type="range" id="s-per" min="0.1" max="0.9" value="0.5" step="0.05"></div>
    <div class="slider-group"><div class="slider-label"><span>Seed</span><span id="v-seed">42</span></div><input type="range" id="s-seed" min="1" max="999" value="42" step="1"></div>
  </div>
  <div class="panel"><div class="panel-title">Grid</div>
    <div class="slider-group"><div class="slider-label"><span>Resolution</span><span id="v-res">100</span></div><input type="range" id="s-res" min="20" max="200" value="100" step="10"></div>
    <div class="slider-group"><div class="slider-label"><span>Extent</span><span id="v-ext">600</span></div><input type="range" id="s-ext" min="100" max="2000" value="600" step="50"></div>
  </div>
  <div class="panel"><div class="panel-title">Track Blend</div>
    <div class="slider-group"><div class="slider-label"><span>Clearance</span><span id="v-clear">60</span></div><input type="range" id="s-clear" min="10" max="300" value="60" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Blend radius</span><span id="v-blend">200</span></div><input type="range" id="s-blend" min="30" max="800" value="200" step="10"></div>
    <div class="slider-group"><div class="slider-label"><span>Depression</span><span id="v-depress">-20</span></div><input type="range" id="s-depress" min="-100" max="50" value="-20" step="5"></div>
  </div>
  <div class="panel"><div class="panel-title">Appearance</div>
    <div class="color-row"><input type="color" id="c-low" value="#2a4a2a"><span>Low</span></div>
    <div class="color-row"><input type="color" id="c-mid" value="#5a8a3a"><span>Mid</span></div>
    <div class="color-row"><input type="color" id="c-high" value="#8a7a5a"><span>High</span></div>
    <div class="color-row"><input type="color" id="c-peak" value="#ccccbb"><span>Peak</span></div>
    <label class="chk"><input type="checkbox" id="chk-wire"><span>Wireframe</span></label>
    <label class="chk"><input type="checkbox" id="chk-flat" checked><span>Flat shading</span></label>
  </div>
  <div class="panel"><div class="stat-row"><span class="stat-label">Vertices</span><span class="stat-value" id="st-verts">--</span></div><div class="stat-row"><span class="stat-label">Triangles</span><span class="stat-value" id="st-tris">--</span></div><div class="stat-row"><span class="stat-label">Gen time</span><span class="stat-value" id="st-time">--</span></div></div>
  <div class="panel"><div class="btn-group"><button class="btn btn-accent" onclick="generateTerrain()">Generate</button><button class="btn" onclick="clearTerrain()">Clear</button></div></div>
</div>

<!-- ===== GAMEPLAY TAB ===== -->
<div class="tab-content" id="tab-gameplay">
  <div class="panel"><div class="panel-title">Speed Pads</div>
    <div class="slider-group"><div class="slider-label"><span>Count</span><span id="v-pads">4</span></div><input type="range" id="s-pads" min="0" max="20" value="4" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Boost</span><span id="v-boost">1.5</span></div><input type="range" id="s-boost" min="1.1" max="3.0" value="1.5" step="0.1"></div>
    <div class="slider-group"><div class="slider-label"><span>Pad length</span><span id="v-padlen">30</span></div><input type="range" id="s-padlen" min="10" max="80" value="30" step="5"></div>
    <label class="chk"><input type="checkbox" id="chk-pads" checked onchange="toggleSpeedPads()"><span>Show pads</span></label>
    <div class="btn-group"><button class="btn btn-accent2" onclick="placeSpeedPads()">Place Pads</button></div>
  </div>
  <div class="panel"><div class="panel-title">AI Cars</div>
    <div class="slider-group"><div class="slider-label"><span>Count</span><span id="v-aicount">6</span></div><input type="range" id="s-aicount" min="0" max="20" value="6" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Spacing</span><span id="v-aispacing">40</span></div><input type="range" id="s-aispacing" min="10" max="120" value="40" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Grid cols</span><span id="v-aigrid">2</span></div><input type="range" id="s-aigrid" min="1" max="4" value="2" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Start offset</span><span id="v-aioffset">0</span></div><input type="range" id="s-aioffset" min="0" max="200" value="0" step="1"></div>
    <label class="chk"><input type="checkbox" id="chk-ai" checked onchange="toggleAICars()"><span>Show cars</span></label>
    <div class="btn-group"><button class="btn btn-accent2" onclick="placeAICars()">Place Cars</button></div>
  </div>
  <div class="panel"><div class="panel-title">Scenery</div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>Theme</span></div>
      <select id="scenery-theme" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
        <option value="neon">Neon City</option>
        <option value="canyon">Canyon</option>
        <option value="scifi">Sci-Fi</option>
      </select>
    </div>
    <div class="slider-group"><div class="slider-label"><span>Density</span><span id="v-scenerydensity">1.0</span></div><input type="range" id="s-scenerydensity" min="0.2" max="3" value="1" step="0.1"></div>
    <div class="slider-group"><div class="slider-label"><span>Building height</span><span id="v-sceneryheight">60</span></div><input type="range" id="s-sceneryheight" min="10" max="200" value="60" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Setback</span><span id="v-scenerysetback">40</span></div><input type="range" id="s-scenerysetback" min="20" max="120" value="40" step="5"></div>
    <label class="chk"><input type="checkbox" id="chk-barriers" checked><span>Barriers</span></label>
    <label class="chk"><input type="checkbox" id="chk-buildings" checked><span>Buildings</span></label>
    <label class="chk"><input type="checkbox" id="chk-arches" checked><span>Arches</span></label>
    <label class="chk"><input type="checkbox" id="chk-lights" checked><span>Streetlights</span></label>
    <label class="chk"><input type="checkbox" id="chk-scenery" checked onchange="toggleScenery()"><span>Show scenery</span></label>
    <div class="btn-group"><button class="btn btn-accent2" onclick="generateScenery()">Generate</button><button class="btn" onclick="clearScenery()">Clear</button></div>
  </div>
  <div class="panel"><div class="btn-group"><button class="btn btn-accent" onclick="exportAll()">Export Scene</button></div></div>
</div>

<!-- ===== PLAY TAB ===== -->
<div class="tab-content" id="tab-play">
  <div class="panel"><div class="panel-title">Horizon Drive</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:8px">
      Race your track inline with the accel-driv engine. Press <span style="color:var(--accent)">ESC</span> or the exit button to return to the editor.
    </div>
    <div class="btn-group"><button class="btn btn-accent" onclick="startGame()" style="font-size:16px;padding:14px 24px">PLAY</button></div>
  </div>
  <div class="panel"><div class="panel-title">Track Info</div>
    <div class="stat-row"><span class="stat-label">Points</span><span class="stat-value" id="play-pts">--</span></div>
    <div class="stat-row"><span class="stat-label">Length</span><span class="stat-value" id="play-len">--</span></div>
    <div class="stat-row"><span class="stat-label">Closed loop</span><span class="stat-value" id="play-loop">--</span></div>
  </div>
  <div class="panel"><div class="panel-title">Game Controls</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.8">
      <div>Auto-accelerate (always moving)</div>
      <div><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">A</kbd><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">D</kbd> / <kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">left</kbd><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">right</kbd> Steer</div>
      <div><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">S</kbd> / <kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">down</kbd> Brake</div>
      <div style="margin-top:4px;color:var(--accent2)">Tilt to steer on mobile</div>
      <div style="color:var(--accent)">Race to the end against 5 AI opponents</div>
    </div>
  </div>
</div>

<!-- ===== SPLAT TAB ===== -->
<div class="tab-content" id="tab-splat">
  <div class="panel"><div class="panel-title">1. Generate World - Marble</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:8px">
      Sends a screenshot or prompt to <span style="color:var(--accent2)">World Labs Marble</span> to generate a full 3D environment as Gaussian splats.
    </div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>API Key</span></div>
      <input type="password" id="marble-apikey" placeholder="WLT-xxxxxxxx" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
    </div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>Environment Prompt</span></div>
      <textarea id="marble-prompt" rows="3" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:6px 8px;border-radius:4px;font-size:11px;resize:vertical;font-family:system-ui">neon-lit cyberpunk racing track through a mountain valley at night, futuristic buildings with holographic signs, glowing bioluminescent vegetation, dramatic clouds, volumetric lighting</textarea>
    </div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>Input mode</span></div>
      <select id="marble-mode" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
        <option value="text">Text prompt only</option>
        <option value="screenshot" selected>Screenshot of current view + prompt</option>
      </select>
      <button class="btn btn-accent2" style="margin-top:4px;width:100%;font-size:11px" onclick="trackAwarePrompt()">Screenshot + Track-Aware Prompt</button>
      <div id="marble-screenshot-preview" style="display:none;margin-top:6px;text-align:center">
        <img id="marble-screenshot-img" style="max-width:100%;border-radius:4px;border:1px solid var(--border)">
        <div style="font-size:10px;color:var(--text-dim);margin-top:2px">Viewport captured — will be sent with prompt</div>
      </div>
    </div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>Splat quality</span></div>
      <select id="marble-quality" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
        <option value="100k" selected>100k splats (fast, ~3 MB)</option>
        <option value="500k">500k splats (balanced, ~15 MB)</option>
        <option value="full_res">Full resolution (~30+ MB)</option>
      </select>
    </div>
    <div class="btn-group">
      <button class="btn btn-accent" onclick="generateMarbleWorld()" id="marble-gen-btn">Generate World</button>
    </div>
    <div id="marble-progress" style="font-size:11px;color:var(--accent2);display:none"></div>
    <div id="marble-pending" style="display:none;margin-top:6px;padding:8px;background:var(--surface2);border:1px solid var(--accent2);border-radius:4px;font-size:11px">
      <div style="color:var(--accent2);margin-bottom:4px">Pending generation found</div>
      <div id="marble-pending-info" style="color:var(--text-dim);margin-bottom:6px"></div>
      <div class="btn-group"><button class="btn btn-accent2" onclick="checkMarbleOperation()">Check Status</button><button class="btn" onclick="clearMarblePending()">Dismiss</button></div>
    </div>
  </div>

  <div class="panel"><div class="panel-title">2. Preview and Load Splat</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:8px">
      Load a splat file into the 3D viewport via <span style="color:var(--accent2)">Spark.js</span>. Supports <b>.spz</b>, <b>.ply</b>, <b>.splat</b>, <b>.sog</b>.
    </div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>Splat URL</span></div>
      <input type="text" id="splat-url" placeholder="https://... .spz / .ply / .sog" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
    </div>
    <div class="btn-group">
      <button class="btn" onclick="loadSplatFromURL()">Load from URL</button>
      <button class="btn" onclick="loadSplatFromFile()">Load File</button>
      <button class="btn" onclick="removeSplat()">Remove</button>
    </div>
    <input type="file" id="splat-file-input" accept=".spz,.ply,.splat,.sog,.ksplat" style="display:none">
    <div class="slider-group"><div class="slider-label"><span>Splat opacity</span><span id="v-splatopacity">1.0</span></div><input type="range" id="s-splatopacity" min="0" max="1" value="1" step="0.05"></div>
    <div class="slider-group"><div class="slider-label"><span>Splat scale</span><span id="v-splatscale">1.0</span></div><input type="range" id="s-splatscale" min="0.01" max="100" value="1" step="0.1"></div>
    <div style="margin-top:8px;border-top:1px solid var(--border);padding-top:8px">
      <div class="slider-label" style="margin-bottom:4px"><span style="color:var(--accent)">Transform</span></div>
      <div class="slider-group"><div class="slider-label"><span>Position X</span><span id="v-splatpx">0</span></div><input type="range" id="s-splatpx" min="-500" max="500" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Position Y</span><span id="v-splatpy">0</span></div><input type="range" id="s-splatpy" min="-500" max="500" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Position Z</span><span id="v-splatpz">0</span></div><input type="range" id="s-splatpz" min="-500" max="500" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Rotation X</span><span id="v-splatrx">0</span></div><input type="range" id="s-splatrx" min="-180" max="180" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Rotation Y</span><span id="v-splatry">0</span></div><input type="range" id="s-splatry" min="-180" max="180" value="0" step="1"></div>
    </div>
    <div class="btn-group" style="margin-top:6px">
      <button class="btn btn-accent2" onclick="splatBackdropPreset()">Use as Backdrop</button>
      <button class="btn" onclick="splatResetTransform()">Reset Transform</button>
    </div>
    <div id="splat-info" style="font-size:10px;color:var(--text-dim);margin-top:4px"></div>
  </div>

  <div class="panel"><div class="panel-title">3. Export Training Views</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:6px">
      Render multi-view images of the current scene for <span style="color:var(--accent2)">3D Gaussian Splatting</span> training via Google Colab.
    </div>
    <div class="slider-group">
      <div class="slider-label"><span>Views</span><span id="v-trainviews">72</span></div>
      <input type="range" id="s-trainviews" min="24" max="200" step="4" value="72">
    </div>
    <div class="slider-group">
      <div class="slider-label"><span>Resolution</span><span id="v-trainres">1024</span></div>
      <input type="range" id="s-trainres" min="512" max="2048" step="256" value="1024">
    </div>
    <div class="btn-group">
      <button class="btn btn-accent2" onclick="exportTrainingViews()" id="btn-export-views">Export Views ZIP</button>
    </div>
    <div id="export-views-progress" style="display:none;font-size:11px;color:var(--accent2);margin-top:4px"></div>
    <div style="font-size:10px;color:var(--text-dim);margin-top:6px;line-height:1.6">
      <div style="color:var(--accent);font-weight:600;margin-bottom:2px">Pipeline</div>
      <div>1. Export views ZIP (images + transforms.json)</div>
      <div>2. Upload to Google Colab notebook</div>
      <div>3. Train 3DGS → download <b>.ply</b> → load in Splat tab</div>
    </div>
  </div>
  <div class="panel"><div class="panel-title">4. Convert Splats</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:6px">
      Convert to <span style="color:var(--accent2)">.sog</span> format for optimal web delivery (~95% smaller than raw PLY).
    </div>
    <div class="btn-group">
      <button class="btn" onclick="window.open('https://supersplat.io','_blank')">SuperSplat (SPZ to SOG)</button>
      <button class="btn" onclick="window.open('https://marble.worldlabs.ai','_blank')">Marble Studio</button>
    </div>
  </div>
  <div class="panel"><div class="panel-title">5. Flythrough &rarr; Stylize &rarr; Marble</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:8px">
      Record a camera flythrough along the track spline, stylize with <span style="color:var(--accent2)">Runway</span> or <span style="color:var(--accent2)">Decart</span>, then reconstruct 3D Gaussian splats with <span style="color:var(--accent2)">Marble</span>.
    </div>
    <div class="slider-group" style="margin-bottom:6px" id="apikey-runway-row">
      <div class="slider-label"><span>Runway API Key</span></div>
      <input type="password" id="runway-apikey" placeholder="rw_xxxxxxxx" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
    </div>
    <div class="slider-group" style="margin-bottom:6px;display:none" id="apikey-decart-row">
      <div class="slider-label"><span>Decart API Key</span></div>
      <input type="password" id="decart-apikey" placeholder="decart_xxxxxxxx" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
    </div>
    <div style="border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px">
      <div style="color:var(--accent);font-weight:600;font-size:12px;margin-bottom:6px">Stage 1 &mdash; Flythrough Video</div>
      <div style="font-size:10px;color:var(--text-dim);margin-bottom:6px">Camera follows the track spline, baking geometry into frames.</div>
      <div class="slider-group">
        <div class="slider-label"><span>Duration (s)</span><span id="v-flydur">10</span></div>
        <input type="range" id="s-flydur" min="2" max="60" value="10" step="1">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Camera height</span><span id="v-flyht">8</span></div>
        <input type="range" id="s-flyht" min="2" max="40" value="8" step="1">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Resolution</span></div>
        <select id="fly-res" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="720" selected>1280 x 720</option>
          <option value="1080">1920 x 1080</option>
        </select>
      </div>
      <div class="btn-group">
        <button class="btn btn-accent2" onclick="recordFlythrough()" id="fly-rec-btn">Record Flythrough</button>
        <button class="btn" onclick="downloadFlythrough()">Download</button>
      </div>
      <div id="fly-progress" style="display:none;font-size:11px;color:var(--accent2);margin-top:4px"></div>
      <video id="fly-video" style="display:none;width:100%;border-radius:6px;margin-top:8px;border:1px solid var(--border);background:#000" controls muted></video>
    </div>
    <div style="border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px">
      <div style="color:var(--accent);font-weight:600;font-size:12px;margin-bottom:6px">Stage 2 &mdash; AI Stylization</div>
      <div id="stylize-desc" style="font-size:10px;color:var(--text-dim);margin-bottom:6px">Stylizes the flythrough using <span style="color:var(--accent2)">Runway</span>. Gen-4 Turbo/Gen-3 use image-to-video with keyframes per segment. <strong>Aleph</strong> uses video-to-video &mdash; sends actual flythrough chunks preserving camera motion (max 5s/segment). Longer tracks are auto-chunked and concatenated.</div>
      <div class="slider-group">
        <div class="slider-label"><span>Provider</span></div>
        <select id="stylize-provider" onchange="onProviderChange()" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="runway" selected>Runway</option>
          <option value="decart">Decart</option>
        </select>
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Style prompt</span></div>
        <textarea id="runway-prompt" rows="2" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:6px 8px;border-radius:4px;font-size:11px;resize:vertical;font-family:system-ui">cinematic flythrough of a futuristic racing track through a detailed sci-fi cityscape environment, towering neon buildings on both sides, volumetric fog, reflective wet ground, dramatic sky with clouds, photorealistic</textarea>
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Model</span></div>
        <select id="runway-model" onchange="onModelChange()" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="gen4_turbo" selected>Gen-4 Turbo</option>
          <option value="gen4_aleph">Gen-4 Aleph (video-to-video)</option>
          <option value="gen3a_turbo">Gen-3 Alpha Turbo</option>
        </select>
      </div>
      <div class="slider-group" id="stylize-duration-row">
        <div class="slider-label"><span>Segment length</span></div>
        <select id="runway-duration" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="5" id="dur-opt-5">5 seconds</option>
          <option value="10" id="dur-opt-10" selected>10 seconds (recommended)</option>
        </select>
      </div>
      <div class="slider-group" id="decart-resolution-row" style="display:none">
        <div class="slider-label"><span>Resolution</span></div>
        <select id="decart-resolution" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="720p" selected>720p</option>
          <option value="480p">480p</option>
        </select>
      </div>
      <div class="btn-group">
        <button class="btn btn-accent2" onclick="runStylize()" id="runway-btn">Stylize with Runway</button>
      </div>
      <div id="runway-progress" style="display:none;font-size:11px;color:var(--accent2);margin-top:4px"></div>
      <div id="runway-segments" style="display:none;margin-top:6px"></div>
      <video id="runway-video" style="display:none;width:100%;border-radius:6px;margin-top:8px;border:1px solid var(--border);background:#000" controls></video>
      <div id="runway-download-bar" style="display:none;margin-top:4px" class="btn-group"></div>
      <div id="runway-pending" style="display:none;margin-top:6px;padding:8px;background:var(--surface2);border:1px solid var(--accent2);border-radius:4px;font-size:11px">
        <div style="color:var(--accent2);margin-bottom:4px" id="pending-title">Pending generation found</div>
        <div id="runway-pending-info" style="color:var(--text-dim);margin-bottom:6px"></div>
        <div class="btn-group"><button class="btn btn-accent2" onclick="checkPendingOperation()">Check Status</button><button class="btn" onclick="clearAllPending()">Dismiss</button></div>
      </div>
    </div>
    <div style="border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px">
      <div style="color:var(--accent);font-weight:600;font-size:12px;margin-bottom:6px">Stage 3 &mdash; Marble from Video</div>
      <div style="font-size:10px;color:var(--text-dim);margin-bottom:6px">Uploads the styled video to Marble for 3D Gaussian splat reconstruction.</div>
      <div class="btn-group">
        <button class="btn btn-accent" onclick="runMarbleFromVideo()" id="marble-vid-btn">Reconstruct 3D World</button>
      </div>
      <div id="marble-vid-progress" style="display:none;font-size:11px;color:var(--accent2);margin-top:4px"></div>
    </div>
    <div class="btn-group">
      <button class="btn btn-accent" onclick="runFullPipeline()" id="pipeline-full-btn" style="width:100%">Run Full Pipeline</button>
    </div>
    <div id="pipeline-progress" style="display:none;font-size:11px;color:var(--accent);margin-top:4px"></div>
  </div>
</div>

  </div>

  <div id="viewport">
    <div id="mobile-toolbar"><button class="mtb-btn" onclick="toggleDrawer()">&#9776;</button><button class="mtb-btn" onclick="fitView()">&#8862;</button><button class="mtb-btn" onclick="loadFile()">&#128194;</button><button class="mtb-btn" onclick="exportTrack()">&#128190;</button><div style="flex:1"></div><button class="mtb-btn" onclick="undoAll()">&#8617;</button></div>
    <div id="help-overlay"><kbd>LMB</kbd> orbit &middot; <kbd>RMB</kbd> pan &middot; <kbd>Scroll</kbd> zoom &middot; <kbd>F</kbd> fit<br><kbd>Shift+Click</kbd> range &middot; <kbd>Esc</kbd> deselect</div>
    <div id="game-overlay" style="display:none;position:absolute;top:0;left:0;right:0;bottom:0;z-index:100;background:#000">
      <iframe id="game-iframe" style="width:100%;height:100%;border:none" allow="accelerometer;gyroscope"></iframe>
      <button id="game-exit-btn" onclick="stopGame()" style="position:absolute;top:12px;left:12px;z-index:110;background:rgba(0,0,0,.7);color:#ff6ec7;border:2px solid #ff6ec7;padding:8px 18px;border-radius:8px;font:700 14px system-ui;cursor:pointer;backdrop-filter:blur(4px)">EXIT</button>
    </div>
  </div>
</div>
<div id="toast"></div>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/"}}</script>
<script type="module">
import * as THREE from 'three';
THREE.ColorManagement.enabled=false;
// ============================================================
// SHARED DATA
// ============================================================
const ET=[[400,-250,-400,0,1,0],[415.4,-250,-400.1,0,1,0],[435.9,-249.9,-400.5,0,1,0],[460.4,-249.9,-400.9,0,1,0],[487.5,-249.8,-401.2,0,1,0],[516.2,-249.8,-401.5,0,1,0],[545.3,-249.8,-401.4,0,1,0],[573.6,-249.9,-401,0,1,0],[600,-250,-400,0,1,0],[625,-250.2,-398.6,-0.0011,0.9998,0.0174],[650,-250.6,-396.9,-0.0026,0.9994,0.0348],[675,-250.9,-394.8,-0.0046,0.9986,0.0521],[700,-251.4,-392.5,-0.0069,0.9976,0.0694],[725,-251.8,-389.8,-0.0097,0.9962,0.0866],[750,-252.2,-386.9,-0.013,0.9945,0.1037],[775,-252.7,-383.6,-0.0166,0.9925,0.1207],[800,-253,-380,-0.0223,0.9903,0.1374],[825,-253.3,-375.5,-0.0296,0.989,0.1448],[850,-253.7,-369.8,-0.0368,0.9877,0.1521],[875,-254,-363.4,-0.0412,0.9863,0.1598],[900,-254.3,-356.9,-0.0425,0.9848,0.1684],[925,-254.6,-350.8,-0.0403,0.9833,0.1777],[950,-254.8,-345.5,-0.0337,0.9816,0.1878],[975,-254.9,-341.8,-0.022,0.9799,0.1982],[1000,-255,-340,-0.0058,0.9781,0.2078],[1025,-254.9,-340.4,0.0103,0.9799,0.1991],[1050,-254.8,-342.6,0.0217,0.9816,0.1896],[1075,-254.6,-346.1,0.029,0.9833,0.1799],[1100,-254.3,-350.6,0.0326,0.9848,0.1706],[1125,-254,-355.7,0.0331,0.9863,0.1617],[1150,-253.7,-360.9,0.031,0.9877,0.1533],[1175,-253.3,-365.8,0.0266,0.989,0.1454],[1200,-253,-370,0.0225,0.9903,0.1373],[1225,-252.7,-374,0.0197,0.9925,0.1203],[1250,-252.2,-378.2,0.0177,0.9945,0.103],[1275,-251.8,-382.6,0.0149,0.9962,0.0859],[1300,-251.4,-386.9,0.0115,0.9976,0.0688],[1325,-250.9,-390.9,0.008,0.9986,0.0517],[1350,-250.6,-394.6,0.0047,0.9994,0.0346],[1375,-250.2,-397.7,0.0019,0.9998,0.0174],[1400,-250,-400,0,1,0],[1425,-249.8,-401.6,0,1,0],[1450,-249.6,-402.6,0,1,0],[1475,-249.3,-403.1,0,1,0],[1500,-249.2,-403.1,0,1,0],[1525,-249.1,-402.8,0,1,0],[1550,-249.2,-402.1,0,1,0],[1575,-249.5,-401.2,0,1,0],[1600,-250,-400,0,1,0],[1625.3,-250.7,-398.7,-0.0023,0.999,0.0436],[1651.2,-251.7,-397.3,-0.005,0.9962,0.087],[1677.2,-252.8,-395.7,-0.009,0.9914,0.1302],[1703.1,-254.1,-393.7,-0.0148,0.9848,0.173],[1728.7,-255.4,-391.3,-0.0234,0.9763,0.2152],[1753.5,-256.9,-388.3,-0.0356,0.9659,0.2564],[1777.4,-258.4,-384.6,-0.0527,0.9537,0.296],[1800,-260,-380,-0.0747,0.9397,0.3338],[1821.5,-261.7,-374.7,-0.0939,0.9312,0.3522],[1842.2,-263.5,-368.7,-0.1137,0.9222,0.3696],[1862.1,-265.5,-362.2,-0.1357,0.9127,0.3855],[1881.3,-267.5,-355,-0.1599,0.9026,0.3997],[1899.6,-269.5,-347.2,-0.1862,0.892,0.4119],[1917.2,-271.5,-338.7,-0.2147,0.8809,0.4218],[1934,-273.3,-329.7,-0.2453,0.8693,0.4292],[1950,-275,-320,-0.2781,0.8572,0.4335],[1965.4,-276.6,-309.6,-0.301,0.8572,0.4179],[1980.2,-278.2,-298.3,-0.323,0.8572,0.4012],[1994.2,-279.8,-286.3,-0.3439,0.8572,0.3834],[2007.5,-281.2,-273.7,-0.3642,0.8572,0.3642],[2019.8,-282.6,-260.7,-0.3841,0.8572,0.3432],[2031.1,-283.7,-247.3,-0.4038,0.8572,0.3197],[2041.2,-284.5,-233.7,-0.4236,0.8572,0.2929],[2050,-285,-220,-0.4437,0.8572,0.2615],[2057.4,-285.1,-206.2,-0.463,0.8572,0.2257],[2063.6,-284.8,-192.1,-0.4795,0.8572,0.1881],[2068.6,-284.2,-177.8,-0.4923,0.8572,0.1513],[2072.5,-283.4,-163.1,-0.5016,0.8572,0.1168],[2075.5,-282.5,-148.1,-0.5079,0.8572,0.0857],[2077.7,-281.6,-132.6,-0.5116,0.8572,0.059],[2079.1,-280.7,-116.6,-0.5137,0.8572,0.037],[2080,-280,-100,-0.5148,0.8572,0.0158],[2080.2,-279.4,-82.5,-0.5094,0.8605,-0.0078],[2079.5,-278.7,-64.1,-0.5029,0.8638,-0.0301],[2077.9,-278.1,-45.1,-0.4957,0.8671,-0.0493],[2075.6,-277.5,-25.6,-0.4879,0.8704,-0.0663],[2072.6,-276.9,-6.1,-0.4798,0.8736,-0.082],[2069,-276.2,13.2,-0.471,0.8767,-0.0973],[2064.8,-275.6,32,-0.4617,0.8799,-0.1127],[2060,-275,50,-0.4514,0.8829,-0.1289],[2054.7,-274.4,67.3,-0.4404,0.886,-0.1451],[2048.8,-273.7,84.1,-0.4288,0.889,-0.1606],[2042.2,-273.1,100.7,-0.4168,0.892,-0.1751],[2035,-272.5,116.9,-0.4045,0.8949,-0.1884],[2027.2,-271.9,132.9,-0.3921,0.8978,-0.2004],[2018.8,-271.2,148.7,-0.3798,0.9007,-0.211],[2009.7,-270.6,164.4,-0.3677,0.9035,-0.2201],[2000,-270,180,-0.3557,0.9063,-0.2282],[1989.6,-269.4,195.8,-0.3403,0.9109,-0.2336],[1978.3,-268.8,211.6,-0.3249,0.9153,-0.238],[1966.3,-268.2,227.5,-0.3098,0.9197,-0.2414],[1953.8,-267.6,243.1,-0.2947,0.9239,-0.2442],[1940.7,-267,258.4,-0.2794,0.928,-0.2465],[1927.3,-266.4,273,-0.2636,0.932,-0.2487],[1913.7,-265.7,287,-0.2473,0.9359,-0.2509],[1900,-265,300,-0.2317,0.9397,-0.2516],[1886.4,-264.2,312.2,-0.2115,0.9469,-0.2421],[1872.8,-263.4,323.8,-0.1914,0.9537,-0.2319],[1859.1,-262.6,334.7,-0.1699,0.96,-0.2224],[1845,-261.7,345,-0.1475,0.9659,-0.2127],[1830.3,-260.8,354.7,-0.125,0.9713,-0.2021],[1814.7,-259.9,363.8,-0.1032,0.9763,-0.1903],[1798,-258.9,372.2,-0.0828,0.9808,-0.1767],[1780,-258,380,-0.064,0.9848,-0.1614],[1760.5,-257,387.1,-0.0476,0.9884,-0.1445],[1739.7,-255.9,393.3,-0.0346,0.9914,-0.1258],[1717.8,-254.7,398.8,-0.0248,0.9941,-0.106],[1695,-253.6,403.8,-0.0174,0.9962,-0.0854],[1671.6,-252.5,408.2,-0.0117,0.9979,-0.0643],[1647.8,-251.5,412.3,-0.0072,0.999,-0.043],[1623.9,-250.6,416.2,-0.0034,0.9998,-0.0215],[1600,-250,420,0,1,0],[1576.6,-249.6,423.5,0,1,0],[1553.8,-249.4,426.6,0,1,0],[1530.9,-249.4,429.4,0,1,0],[1507.5,-249.5,431.9,0,1,0],[1483.2,-249.6,434.1,0,1,0],[1457.5,-249.8,436.2,0,1,0],[1429.9,-249.9,438.1,0,1,0],[1400,-250,440,0,1,0],[1367.3,-250,441.9,0,1,0],[1332,-250,443.7,0,1,0],[1294.8,-250,445.4,0,1,0],[1256.3,-250,446.9,0,1,0],[1216.9,-250,448.2,0,1,0],[1177.3,-250,449.1,0,1,0],[1138.2,-250,449.8,0,1,0],[1100,-250,450,0,1,0],[1061.8,-250,449.8,0,1,0],[1022.7,-250,449.1,0,1,0],[983.1,-250,448.2,0,1,0],[943.8,-250,446.9,0,1,0],[905.2,-250,445.4,0,1,0],[868,-250,443.7,0,1,0],[832.7,-250,441.9,0,1,0],[800,-250,440,0,1,0],[770.2,-249.9,438.1,0,1,0],[743,-249.8,436.2,0,1,0],[717.7,-249.6,434.1,0,1,0],[693.8,-249.5,431.9,0,1,0],[670.6,-249.4,429.4,0,1,0],[647.7,-249.4,426.6,0,1,0],[624.3,-249.6,423.5,0,1,0],[600,-250,420,0,1,0],[574.7,-250.6,416.2,0.0048,0.9995,-0.0324],[548.8,-251.4,412.3,0.01,0.9979,-0.0646],[522.8,-252.3,408.2,0.016,0.9952,-0.0967],[496.9,-253.4,403.8,0.0235,0.9914,-0.1284],[471.3,-254.5,398.8,0.0331,0.9866,-0.1595],[446.5,-255.7,393.3,0.0458,0.9808,-0.1896],[422.6,-256.8,387.1,0.0624,0.9739,-0.2183],[400,-258,380,0.0827,0.9659,-0.2453],[378.5,-259.1,372.2,0.1006,0.96,-0.2611],[357.8,-260.3,363.8,0.119,0.9537,-0.2762],[337.9,-261.5,354.7,0.1391,0.9469,-0.2898],[318.8,-262.7,345,0.161,0.9397,-0.3018],[300.4,-264,334.7,0.1845,0.932,-0.312],[282.8,-265.3,323.8,0.2096,0.9239,-0.3202],[266,-266.6,312.2,0.2361,0.9153,-0.3263],[250,-268,300,0.2653,0.9063,-0.329],[234.8,-269.5,287,0.292,0.9007,-0.3217],[220.3,-271,273,0.3182,0.8949,-0.3128],[206.6,-272.7,258.4,0.3424,0.889,-0.304],[193.8,-274.3,243.1,0.3649,0.8829,-0.2954],[181.6,-275.9,227.5,0.3858,0.8767,-0.2872],[170.3,-277.4,211.6,0.4054,0.8704,-0.2794],[159.8,-278.8,195.8,0.4239,0.8638,-0.2722],[150,-280,180,0.4422,0.8572,-0.2641],[141,-281,164.4,0.4515,0.8572,-0.2477],[132.8,-282,148.7,0.4614,0.8572,-0.2288],[125.4,-282.8,132.9,0.471,0.8572,-0.2083],[118.8,-283.6,116.9,0.4801,0.8572,-0.1864],[112.9,-284.2,100.7,0.4885,0.8572,-0.1632],[107.8,-284.6,84.1,0.4959,0.8572,-0.1393],[103.5,-284.9,67.3,0.5021,0.8572,-0.1149],[100,-285,50,0.5073,0.8572,-0.0889],[97.3,-284.9,32,0.5113,0.8572,-0.0619],[95.5,-284.5,13.2,0.5137,0.8572,-0.0371],[94.6,-283.9,-6.1,0.5148,0.8572,-0.0155],[94.4,-283.1,-25.6,0.515,0.8572,0.0039],[94.9,-282.3,-45.1,0.5146,0.8572,0.0219],[96,-281.5,-64.1,0.5135,0.8572,0.0393],[97.7,-280.7,-82.5,0.5119,0.8572,0.0569],[100,-280,-100,0.5094,0.8572,0.0759],[102.8,-279.4,-116.6,0.5003,0.8605,0.096],[106.3,-278.9,-132.6,0.4901,0.8638,0.1167],[110.3,-278.3,-148.1,0.4789,0.8671,0.1372],[115,-277.8,-163.1,0.4667,0.8704,0.1571],[120.3,-277.2,-177.8,0.4537,0.8736,0.1761],[126.3,-276.6,-192.1,0.4402,0.8767,0.1939],[132.8,-275.9,-206.2,0.4263,0.8799,0.2101],[140,-275,-220,0.4126,0.8829,0.224],[147.7,-274,-233.7,0.3909,0.891,0.2309],[156,-272.9,-247.1,0.3687,0.8988,0.2372],[164.9,-271.6,-260.3,0.3453,0.9063,0.2437],[174.4,-270.3,-273.1,0.3208,0.9135,0.25],[184.6,-269,-285.6,0.2954,0.9205,0.2558],[195.5,-267.6,-297.6,0.2691,0.9272,0.2606],[207.3,-266.3,-309.1,0.2422,0.9336,0.2641],[220,-265,-320,0.2129,0.9397,0.2677],[234.4,-263.7,-330.6,0.1786,0.9483,0.2623],[250.9,-262.4,-341,0.1503,0.9563,0.2508],[268.6,-261,-351.1,0.1278,0.9636,0.2347],[286.9,-259.7,-360.6,0.1093,0.9703,0.2158],[304.9,-258.4,-369.5,0.0935,0.9763,0.1952],[322,-257.1,-377.4,0.0797,0.9816,0.1734],[337.2,-256,-384.3,0.0675,0.9863,0.1506],[350,-255,-390,0.0545,0.9903,0.1281],[360.4,-254.1,-394.2,0.0413,0.9925,0.1147],[369.3,-253.3,-397,0.0271,0.9945,0.101],[376.8,-252.5,-398.6,0.015,0.9962,0.0858],[383.1,-251.9,-399.4,0.0062,0.9976,0.0695],[388.4,-251.3,-399.6,0.0013,0.9986,0.0523],[392.9,-250.8,-399.6,0.0001,0.9994,0.0349],[396.7,-250.4,-399.6,0.001,0.9998,0.0174],[400,-250,-400,0,1,0]];

let trackData=[],origData=null,selA=-1,selB=-1,loopAdded=0,editMode='select';
let cps=[],selCP=-1,dragCP=false,cpMeshes=[];
let defWidth=30,isMobile=window.innerWidth<=768;
let scene,cam,rndr,tLine,tRibbon,ptCloud,loopLine,selHL,cpGrp,splineLine,wRibbon,ray,mouse,gPlane,laneLineGroup;
let cScene,cCam;
let orb={rot:false,pan:false,lx:0,ly:0,tgt:new THREE.Vector3(600,0,0),phi:Math.PI/4,theta:Math.PI/4,dist:1500};
let tch={mode:null,last:null,initDist:0,tapTime:0,tapPos:null,moved:false};
let drawerOpen=false;
let terrainMesh=null,terrainWire=null;
let speedPadGroup=null,speedPadData=[];
let aiCarGroup=null,aiCarData=[];
let trackRibbon=null;
let sceneryGroup=null;
let activeTab='track';

function norm(v){var l=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])||1;return[v[0]/l,v[1]/l,v[2]/l]}
function crs(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}
function sub(a,b){return[a[0]-b[0],a[1]-b[1],a[2]-b[2]]}
function dst(a,b){return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2)}
function toast(m){var e=document.getElementById('toast');e.textContent=m;e.classList.add('show');setTimeout(function(){e.classList.remove('show')},2500)}

// ============================================================
// TAB SWITCHING
// ============================================================
function switchTab(tab) {
activeTab = tab;
document.querySelectorAll('.top-tab').forEach(function(t){t.classList.toggle('active', t.dataset.tab === tab)});
document.querySelectorAll('.tab-content').forEach(function(t){t.classList.toggle('active', t.id === 'tab-' + tab)});
if (tab === 'play') updatePlayInfo();
}

function updatePlayInfo() {
var pts = document.getElementById('play-pts');
var len = document.getElementById('play-len');
var loop = document.getElementById('play-loop');
if (pts) pts.textContent = trackData.length;
if (len) len.textContent = Math.round(getTrackLength()) + ' units';
if (loop && trackData.length >= 3) {
var f = trackData[0][0], l = trackData[trackData.length-1][0];
var gap = Math.hypot(f[0]-l[0], f[1]-l[1], f[2]-l[2]);
loop.textContent = gap < 50 ? 'Yes' : 'No (gap: ' + Math.round(gap) + ')';
}
}

// ============================================================
// INIT
// ============================================================
function init(){
trackData=ET.map(function(p){return[[p[0],p[1],p[2]],[p[3],p[4],p[5]]]});
origData=JSON.parse(JSON.stringify(trackData));
setupThree();buildVis();updateStats();bindUI();setupDrawer();animate();
}

function setupThree(){
var c=document.getElementById('viewport'),w=c.clientWidth,h=c.clientHeight;
scene=new THREE.Scene();scene.background=new THREE.Color(0x0a0a0f);scene.fog=new THREE.Fog(0x0a0a0f,5000,12000);
cam=new THREE.PerspectiveCamera(50,w/h,1,20000);cam.position.set(600,400,600);
rndr=new THREE.WebGLRenderer({antialias:true});rndr.setSize(w,h);rndr.setPixelRatio(Math.min(window.devicePixelRatio,2));rndr.autoClear=false;rndr.outputColorSpace=THREE.LinearSRGBColorSpace;
c.appendChild(rndr.domElement);
scene.add(new THREE.AmbientLight(0x445566,1.57));var sun=new THREE.DirectionalLight(0xffeedd,2.51);sun.position.set(1000,2000,500);scene.add(sun);
var fill=new THREE.DirectionalLight(0x445566,0.94);fill.position.set(-500,500,-500);scene.add(fill);
var grid=new THREE.GridHelper(10000,100,0x1a1a2a,0x111118);scene.add(grid);
gPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0);cpGrp=new THREE.Group();scene.add(cpGrp);
cScene=new THREE.Scene();cScene.background=new THREE.Color(0x12121a);cCam=new THREE.PerspectiveCamera(50,1,.1,10);
cScene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0),new THREE.Vector3(),1,0xff4444,.25,.12));
cScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0),new THREE.Vector3(),1,0x44ff44,.25,.12));
cScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1),new THREE.Vector3(),1,0x4488ff,.25,.12));
ray=new THREE.Raycaster();mouse=new THREE.Vector2();

if(trackData.length>0){var cx=trackData.reduce(function(s,p){return s+p[0][0]},0)/trackData.length,cy=trackData.reduce(function(s,p){return s+p[0][1]},0)/trackData.length,cz=trackData.reduce(function(s,p){return s+p[0][2]},0)/trackData.length;orb.tgt.set(cx,cy,cz)}

c.addEventListener('mousedown', function(e){
if(e.button===2){orb.pan=true}else{orb.rot=true;if(activeTab==='track'&&editMode==='control-points'&&cps.length>0)trySelectCP(e);if(activeTab==='track'&&editMode!=='control-points')trySelectTrackPt(e)}
orb.lx=e.clientX;orb.ly=e.clientY;
});
c.addEventListener('contextmenu',function(e){e.preventDefault()});
window.addEventListener('mouseup',function(){orb.rot=false;orb.pan=false;if(dragCP){dragCP=false}});
window.addEventListener('mousemove',function(e){
var dx=e.clientX-orb.lx,dy=e.clientY-orb.ly;orb.lx=e.clientX;orb.ly=e.clientY;
if(dragCP&&selCP>=0){var ndc=new THREE.Vector2((e.clientX/window.innerWidth)*2-1,-(e.clientY/window.innerHeight)*2+1);dragCPTo(ndc);return}
if(orb.rot&&!dragCP){orb.theta+=dx*.005;orb.phi-=dy*.005;orb.phi=Math.max(.05,Math.min(Math.PI-.05,orb.phi))}
if(orb.pan) doPan(dx,dy);
});
c.addEventListener('wheel',function(e){e.preventDefault();orb.dist*=(1+e.deltaY*.001);orb.dist=Math.max(50,Math.min(15000,orb.dist))},{passive:false});

c.addEventListener('touchstart',function(e){e.preventDefault();var t=e.touches;if(t.length===1){tch.mode='orbit';tch.moved=false;tch.tapTime=Date.now();tch.tapPos={x:t[0].clientX,y:t[0].clientY};orb.lx=t[0].clientX;orb.ly=t[0].clientY}else if(t.length===2){tch.mode='pinch';tch.initDist=Math.hypot(t[1].clientX-t[0].clientX,t[1].clientY-t[0].clientY);tch.last=[{x:t[0].clientX,y:t[0].clientY},{x:t[1].clientX,y:t[1].clientY}]}},{passive:false});
c.addEventListener('touchmove',function(e){e.preventDefault();var t=e.touches;if(t.length===1&&tch.mode==='orbit'){var dx=t[0].clientX-orb.lx,dy=t[0].clientY-orb.ly;orb.lx=t[0].clientX;orb.ly=t[0].clientY;if(Math.abs(dx)>2||Math.abs(dy)>2)tch.moved=true;orb.theta+=dx*.005;orb.phi-=dy*.005;orb.phi=Math.max(.05,Math.min(Math.PI-.05,orb.phi))}if(t.length===2&&tch.mode==='pinch'){var nd=Math.hypot(t[1].clientX-t[0].clientX,t[1].clientY-t[0].clientY);orb.dist*=(1+(tch.initDist/nd-1)*.05);orb.dist=Math.max(50,Math.min(15000,orb.dist));tch.initDist=nd;var mx=(t[0].clientX+t[1].clientX)/2,my=(t[0].clientY+t[1].clientY)/2;if(tch.last&&tch.last.length===2){doPan(mx-(tch.last[0].x+tch.last[1].x)/2,my-(tch.last[0].y+tch.last[1].y)/2)}tch.last=[{x:t[0].clientX,y:t[0].clientY},{x:t[1].clientX,y:t[1].clientY}]}},{passive:false});
c.addEventListener('touchend',function(e){e.preventDefault();if(!tch.moved&&Date.now()-tch.tapTime<300&&tch.tapPos){var tp=tch.tapPos;if(activeTab==='track')trySelectTrackPt({clientX:tp.x,clientY:tp.y})}tch.mode=null;tch.last=null;if(e.touches.length===1){tch.mode='orbit';orb.lx=e.touches[0].clientX;orb.ly=e.touches[0].clientY}},{passive:false});
c.addEventListener('touchcancel',function(e){e.preventDefault();tch.mode=null;tch.last=null},{passive:false});

window.addEventListener('resize',function(){var w=c.clientWidth,h=c.clientHeight;cam.aspect=w/h;cam.updateProjectionMatrix();rndr.setSize(w,h);isMobile=window.innerWidth<=768});
window.addEventListener('keydown',function(e){if(e.key==='f'||e.key==='F')fitView();if(e.key==='Escape'){selA=selB=-1;selCP=-1;updateSelVis();updateCPPanel()}});
}

function doPan(dx,dy){var r=new THREE.Vector3(),u=new THREE.Vector3();r.crossVectors(cam.up,new THREE.Vector3().subVectors(orb.tgt,cam.position).normalize()).normalize();u.copy(cam.up);var s=orb.dist*.001;orb.tgt.add(r.multiplyScalar(dx*s));orb.tgt.add(u.multiplyScalar(dy*s))}
function updCam(){var sp=Math.sin(orb.phi),cp=Math.cos(orb.phi),st=Math.sin(orb.theta),ct=Math.cos(orb.theta);cam.position.set(orb.tgt.x+orb.dist*sp*ct,orb.tgt.y+orb.dist*cp,orb.tgt.z+orb.dist*sp*st);cam.lookAt(orb.tgt)}
function fitView(){if(!trackData.length)return;var a=Infinity,b=-Infinity,c=Infinity,d=-Infinity,e=Infinity,f=-Infinity;trackData.forEach(function(p){a=Math.min(a,p[0][0]);b=Math.max(b,p[0][0]);c=Math.min(c,p[0][1]);d=Math.max(d,p[0][1]);e=Math.min(e,p[0][2]);f=Math.max(f,p[0][2])});orb.tgt.set((a+b)/2,(c+d)/2,(e+f)/2);orb.dist=Math.max(b-a,d-c,f-e)*1.2;orb.phi=Math.PI/4;orb.theta=Math.PI/4}

// ============================================================
// TRACK VISUALIZATION
// ============================================================
function buildVis(){
if(tLine)scene.remove(tLine);if(tRibbon)scene.remove(tRibbon);if(ptCloud)scene.remove(ptCloud);if(selHL)scene.remove(selHL);if(trackRibbon)scene.remove(trackRibbon);if(laneLineGroup){scene.remove(laneLineGroup);laneLineGroup=null}
if(!trackData.length)return;
var pos=[],col=[];var mY=Infinity,MY=-Infinity;trackData.forEach(function(p){mY=Math.min(mY,p[0][1]);MY=Math.max(MY,p[0][1])});var yr=Math.max(MY-mY,1);
trackData.forEach(function(p){pos.push(p[0][0],p[0][1],p[0][2]);var t=(p[0][1]-mY)/yr;col.push(1-t*.6,.3+t*.4,.2+t*.6)});
var g1=new THREE.BufferGeometry();g1.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));g1.setAttribute('color',new THREE.Float32BufferAttribute(col,3));
tLine=new THREE.Line(g1,new THREE.LineBasicMaterial({vertexColors:true}));scene.add(tLine);
ptCloud=new THREE.Points(g1.clone(),new THREE.PointsMaterial({size:4,vertexColors:true,sizeAttenuation:false}));scene.add(ptCloud);
selHL=new THREE.Points(new THREE.BufferGeometry(),new THREE.PointsMaterial({size:8,color:0x00ffcc,sizeAttenuation:false}));scene.add(selHL);
updateSelVis();
buildTrackRibbon();
buildEditorLaneLines();
}

function buildTrackRibbon(){
if(trackRibbon)scene.remove(trackRibbon);
var w=15,verts=[],idx=[],cols=[];
for(var i=0;i<trackData.length;i++){
var p=trackData[i][0],n=trackData[i][1];var fwd;
if(i<trackData.length-1)fwd=sub(trackData[i+1][0],p);else fwd=sub(p,trackData[i-1][0]);
var fl=Math.sqrt(fwd[0]*fwd[0]+fwd[1]*fwd[1]+fwd[2]*fwd[2])||1;fwd=[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl];
var r=crs(fwd,n),rl=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2])||1;
verts.push(p[0]+r[0]/rl*w,p[1]+r[1]/rl*w+1,p[2]+r[2]/rl*w);
verts.push(p[0]-r[0]/rl*w,p[1]-r[1]/rl*w+1,p[2]-r[2]/rl*w);
cols.push(0.25,0.25,0.3, 0.25,0.25,0.3);
if(i<trackData.length-1){var vi=i*2;idx.push(vi,vi+1,vi+2,vi+1,vi+3,vi+2)}
}
var g=new THREE.BufferGeometry();
g.setAttribute('position',new THREE.Float32BufferAttribute(verts,3));
g.setAttribute('color',new THREE.Float32BufferAttribute(cols,3));
g.setIndex(idx);g.computeVertexNormals();
trackRibbon=new THREE.Mesh(g,new THREE.MeshPhongMaterial({vertexColors:true,side:THREE.DoubleSide}));
scene.add(trackRibbon);
}

function buildEditorLaneLines(){
if(laneLineGroup){scene.remove(laneLineGroup);laneLineGroup=null}
if(trackData.length<10)return;
laneLineGroup=new THREE.Group();
var w=15,dashLen=18,gapLen=24,dashW=1.2,edgeInset=2.5;
var dashMat=new THREE.MeshBasicMaterial({color:0xffffff,side:THREE.DoubleSide,transparent:true,opacity:0.5,depthWrite:false});
var edgeMat=new THREE.MeshBasicMaterial({color:0xffdd44,side:THREE.DoubleSide,transparent:true,opacity:0.4,depthWrite:false});
// Accumulate distance along track and place dashes
var dist=0,cycleLen=dashLen+gapLen;
var i=0;
while(i<trackData.length-1){
  var p=trackData[i][0],pn=trackData[Math.min(i+1,trackData.length-1)][0];
  var segLen=Math.sqrt((pn[0]-p[0])**2+(pn[1]-p[1])**2+(pn[2]-p[2])**2);
  var prevDist=dist;
  dist+=segLen;
  // Check if a dash start falls within this segment
  var nextDash=Math.ceil(prevDist/cycleLen)*cycleLen;
  while(nextDash<dist&&nextDash+dashLen*0.5<dist){
    // Find the midpoint index roughly at nextDash+dashLen/2
    var midDist=nextDash+dashLen/2;
    var mi=i;
    var acc=prevDist;
    while(mi<trackData.length-2){
      var d2=Math.sqrt((trackData[mi+1][0][0]-trackData[mi][0][0])**2+(trackData[mi+1][0][1]-trackData[mi][0][1])**2+(trackData[mi+1][0][2]-trackData[mi][0][2])**2);
      if(acc+d2>=midDist)break;
      acc+=d2;mi++;
    }
    var mp=trackData[mi][0],mn=trackData[mi][1];
    var fwd;
    if(mi<trackData.length-1)fwd=sub(trackData[mi+1][0],mp);else fwd=sub(mp,trackData[mi-1][0]);
    var fl=Math.sqrt(fwd[0]**2+fwd[1]**2+fwd[2]**2)||1;
    fwd=[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl];
    var r=crs(fwd,mn),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;
    r=[r[0]/rl,r[1]/rl,r[2]/rl];
    // Center dash
    var dg=new THREE.PlaneGeometry(dashW,dashLen);
    var dm=new THREE.Mesh(dg,dashMat);
    dm.position.set(mp[0],mp[1]+1.5,mp[2]);
    var la=new THREE.Vector3(mp[0]+fwd[0],mp[1]+fwd[1]+1.5,mp[2]+fwd[2]);
    dm.up.set(mn[0],mn[1],mn[2]);
    dm.lookAt(la);
    dm.rotateX(-Math.PI/2);
    laneLineGroup.add(dm);
    // Left edge dash
    var eg=new THREE.PlaneGeometry(dashW*0.6,dashLen*0.7);
    var el=new THREE.Mesh(eg,edgeMat);
    el.position.set(mp[0]-r[0]*(w-edgeInset),mp[1]-r[1]*(w-edgeInset)+1.5,mp[2]-r[2]*(w-edgeInset));
    el.up.set(mn[0],mn[1],mn[2]);
    el.lookAt(new THREE.Vector3(el.position.x+fwd[0],el.position.y+fwd[1],el.position.z+fwd[2]));
    el.rotateX(-Math.PI/2);
    laneLineGroup.add(el);
    // Right edge dash
    var er=new THREE.Mesh(eg.clone(),edgeMat);
    er.position.set(mp[0]+r[0]*(w-edgeInset),mp[1]+r[1]*(w-edgeInset)+1.5,mp[2]+r[2]*(w-edgeInset));
    er.up.set(mn[0],mn[1],mn[2]);
    er.lookAt(new THREE.Vector3(er.position.x+fwd[0],er.position.y+fwd[1],er.position.z+fwd[2]));
    er.rotateX(-Math.PI/2);
    laneLineGroup.add(er);
    nextDash+=cycleLen;
  }
  i++;
}
scene.add(laneLineGroup);
}

function updateSelVis(){if(!selHL)return;if(selA<0){selHL.geometry.setAttribute('position',new THREE.Float32BufferAttribute([],3));return}var lo=Math.min(selA,selB<0?selA:selB),hi=Math.max(selA,selB<0?selA:selB);var p=[];for(var i=lo;i<=hi&&i<trackData.length;i++)p.push(trackData[i][0][0],trackData[i][0][1],trackData[i][0][2]);selHL.geometry.setAttribute('position',new THREE.Float32BufferAttribute(p,3))}

function trySelectTrackPt(e){if(activeTab!=='track')return;var c=document.getElementById('viewport');mouse.x=(e.clientX/c.clientWidth)*2-1;mouse.y=-(e.clientY/c.clientHeight)*2+1;ray.setFromCamera(mouse,cam);var best=-1,bestD=40;for(var i=0;i<trackData.length;i++){var v=new THREE.Vector3(trackData[i][0][0],trackData[i][0][1],trackData[i][0][2]);v.project(cam);var sx=(v.x+1)/2*c.clientWidth,sy=(1-v.y)/2*c.clientHeight;var d=Math.hypot(sx-e.clientX,sy-e.clientY);if(d<bestD){bestD=d;best=i}}if(best>=0){if(e.shiftKey&&selA>=0){selB=best}else{selA=best;selB=-1}updateSelVis()}}

function trySelectCP(e){var c=document.getElementById('viewport');var ndc=new THREE.Vector2((e.clientX/c.clientWidth)*2-1,-(e.clientY/c.clientHeight)*2+1);var best=-1,bestD=30;for(var i=0;i<cps.length;i++){var v=new THREE.Vector3(cps[i].pos[0],cps[i].pos[1],cps[i].pos[2]);v.project(cam);var sx=(v.x+1)/2*c.clientWidth,sy=(1-v.y)/2*c.clientHeight;var d=Math.hypot(sx-e.clientX,sy-e.clientY);if(d<bestD){bestD=d;best=i}}if(best>=0){selCP=best;dragCP=true;orb.rot=false;updateCPVis();updateCPPanel()}}
function dragCPTo(ndc){ray.setFromCamera(ndc,cam);var v=new THREE.Vector3(),y=cps[selCP].pos[1],p=new THREE.Plane(new THREE.Vector3(0,1,0),-y);if(ray.ray.intersectPlane(p,v)){cps[selCP].pos[0]=v.x;cps[selCP].pos[2]=v.z;updateCPVis();updateCPPanel();rebuildSpline()}}
function updateCPPanel(){var p=document.getElementById('cp-selected-panel');var wp=document.getElementById('width-cp-panel');if(selCP<0){if(p)p.style.display='none';if(wp)wp.style.display='none';return}if(p){p.style.display='block';document.getElementById('cp-sel-idx').textContent=selCP;document.getElementById('cp-x').value=Math.round(cps[selCP].pos[0]);document.getElementById('cp-y').value=Math.round(cps[selCP].pos[1]);document.getElementById('cp-z').value=Math.round(cps[selCP].pos[2])}if(wp&&editMode==='width'){wp.style.display='block';document.getElementById('width-cp-idx').textContent=selCP;document.getElementById('cp-width').value=cps[selCP].width;document.getElementById('cp-width-val').textContent=Math.round(cps[selCP].width)}}
function updateCPFromInput(){if(selCP<0)return;cps[selCP].pos[0]=parseFloat(document.getElementById('cp-x').value)||0;cps[selCP].pos[1]=parseFloat(document.getElementById('cp-y').value)||0;cps[selCP].pos[2]=parseFloat(document.getElementById('cp-z').value)||0;updateCPVis();rebuildSpline()}
function extractControlPoints(){var n=parseInt(document.getElementById('cp-count').value);if(trackData.length<n){toast('Not enough pts');return}cps=[];var step=trackData.length/n;for(var i=0;i<n;i++){var idx=Math.min(Math.floor(i*step),trackData.length-1);cps.push({pos:[trackData[idx][0][0],trackData[idx][0][1],trackData[idx][0][2]],normal:[trackData[idx][1][0],trackData[idx][1][1],trackData[idx][1][2]],width:defWidth})}selCP=-1;updateCPVis();rebuildSpline();toast(n+' CPs extracted')}
function updateCPVis(){while(cpGrp.children.length)cpGrp.remove(cpGrp.children[0]);if(editMode!=='control-points'&&editMode!=='width')return;var show=document.getElementById('show-cp-handles');if(show&&show.checked===false)return;cps.forEach(function(c,i){var g=new THREE.SphereGeometry(6,8,6);var m=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:i===selCP?0x00ffcc:0xffcc00}));m.position.set(c.pos[0],c.pos[1],c.pos[2]);cpGrp.add(m)})}
function rebuildSpline(){if(splineLine)scene.remove(splineLine);if(cps.length<2)return;var cv=new THREE.CatmullRomCurve3(cps.map(function(c){return new THREE.Vector3(c.pos[0],c.pos[1],c.pos[2])}));var r=parseInt(document.getElementById('spline-resolution').value||'10');var p=cv.getPoints(cps.length*r);var g=new THREE.BufferGeometry().setFromPoints(p);splineLine=new THREE.Line(g,new THREE.LineDashedMaterial({color:0xff44cc,dashSize:10,gapSize:5}));splineLine.computeLineDistances();scene.add(splineLine)}
function rebuildFromSpline(){if(cps.length<2){toast('Extract CPs first');return}var r=parseInt(document.getElementById('spline-resolution').value);var cv=new THREE.CatmullRomCurve3(cps.map(function(c){return new THREE.Vector3(c.pos[0],c.pos[1],c.pos[2])}));var nc=new THREE.CatmullRomCurve3(cps.map(function(c){return new THREE.Vector3(c.normal[0],c.normal[1],c.normal[2])}));var tp=cps.length*r,pp=cv.getPoints(tp),np=nc.getPoints(tp);trackData=pp.map(function(p,i){var n=np[i],nl=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z)||1;return[[p.x,p.y,p.z],[n.x/nl,n.y/nl,n.z/nl]]});buildVis();updateStats();toast('Rebuilt: '+trackData.length+' pts')}
function insertCPAfter(){if(selCP<0||cps.length<2)return;var next=(selCP+1)%cps.length;var np={pos:[(cps[selCP].pos[0]+cps[next].pos[0])/2,(cps[selCP].pos[1]+cps[next].pos[1])/2,(cps[selCP].pos[2]+cps[next].pos[2])/2],normal:[cps[selCP].normal[0],cps[selCP].normal[1],cps[selCP].normal[2]],width:cps[selCP].width};cps.splice(selCP+1,0,np);selCP=selCP+1;updateCPVis();rebuildSpline();toast('Inserted CP')}
function deleteSelectedCP(){if(selCP<0||cps.length<=2)return;cps.splice(selCP,1);selCP=Math.min(selCP,cps.length-1);updateCPVis();rebuildSpline();toast('Deleted CP')}

function onDefaultWidthChange(){defWidth=parseInt(document.getElementById('default-width').value);document.getElementById('default-width-val').textContent=defWidth}
function setAllWidths(){cps.forEach(function(c){c.width=defWidth});if(editMode==='width')buildWRib();drawWGraph();toast('All widths set to '+defWidth)}
function onCPWidthChange(){if(selCP<0)return;cps[selCP].width=parseInt(document.getElementById('cp-width').value);document.getElementById('cp-width-val').textContent=cps[selCP].width;buildWRib();drawWGraph()}
function widthPreset(w){if(selCP<0)return;cps[selCP].width=w;document.getElementById('cp-width').value=w;document.getElementById('cp-width-val').textContent=w;buildWRib();drawWGraph()}
function interpWidths(){if(cps.length<2)return trackData.map(function(){return defWidth});var ws=[];var total=trackData.length;for(var i=0;i<total;i++){var t=i/(total-1)*(cps.length-1);var idx=Math.floor(t),frac=t-idx;var a=cps[Math.min(idx,cps.length-1)].width,b=cps[Math.min(idx+1,cps.length-1)].width;ws.push(a+(b-a)*frac)}return ws}
function buildWRib(){if(wRibbon)scene.remove(wRibbon);if(cps.length<2)return;var ws=interpWidths(),verts=[],idx=[],cols=[];for(var i=0;i<trackData.length;i++){var p=trackData[i][0],n=trackData[i][1];var fwd;if(i<trackData.length-1)fwd=sub(trackData[i+1][0],p);else fwd=sub(p,trackData[i-1][0]);var fl=Math.sqrt(fwd[0]**2+fwd[1]**2+fwd[2]**2)||1;fwd=[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl];var r=crs(fwd,n),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;var hw=ws[i]/2;verts.push(p[0]+r[0]/rl*hw,p[1]+r[1]/rl*hw+2,p[2]+r[2]/rl*hw);verts.push(p[0]-r[0]/rl*hw,p[1]-r[1]/rl*hw+2,p[2]-r[2]/rl*hw);cols.push(.2,.6,.4,.2,.6,.4);if(i<trackData.length-1){var vi=i*2;idx.push(vi,vi+1,vi+2,vi+1,vi+3,vi+2)}}var g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(verts,3));g.setAttribute('color',new THREE.Float32BufferAttribute(cols,3));g.setIndex(idx);g.computeVertexNormals();wRibbon=new THREE.Mesh(g,new THREE.MeshPhongMaterial({vertexColors:true,side:THREE.DoubleSide,transparent:true,opacity:.5}));scene.add(wRibbon)}
function rebuildWithWidth(){rebuildFromSpline();if(cps.length>=2)buildWRib();drawWGraph()}
function drawWGraph(){var cv=document.getElementById('width-graph');if(!cv||cps.length<2)return;var ctx=cv.getContext('2d');cv.width=cv.clientWidth*2;cv.height=cv.clientHeight*2;ctx.scale(2,2);var w=cv.clientWidth,h=cv.clientHeight;ctx.clearRect(0,0,w,h);var ws=interpWidths(),mx=Math.max.apply(null,ws.concat([1]));ctx.strokeStyle='#00d4aa';ctx.lineWidth=1.5;ctx.beginPath();ws.forEach(function(v,i){var x=i/(ws.length-1)*w,y=h-v/mx*(h-4)-2;i===0?ctx.moveTo(x,y):ctx.lineTo(x,y)});ctx.stroke()}

function smoothSelection(){var lo=Math.min(selA,selB<0?selA:selB),hi=Math.max(selA,selB<0?selA:selB);if(lo<0){toast('Select points first');return}var iter=parseInt(document.getElementById('smooth-iter').value),str=parseFloat(document.getElementById('smooth-str').value);for(var k=0;k<iter;k++){var old=trackData.map(function(p){return[[p[0][0],p[0][1],p[0][2]],[p[1][0],p[1][1],p[1][2]]]});for(var i=Math.max(1,lo);i<=Math.min(hi,trackData.length-2);i++){for(var j=0;j<3;j++){trackData[i][0][j]=old[i][0][j]*(1-str)+(old[i-1][0][j]+old[i+1][0][j])/2*str}}}buildVis();toast('Smoothed')}
function smoothAll(){selA=0;selB=trackData.length-1;smoothSelection();selA=selB=-1;updateSelVis()}
function applyElevation(){var lo=Math.min(selA,selB),hi=Math.max(selA,selB);if(lo<0){toast('Select points first');return}var o=parseInt(document.getElementById('elev-offset').value);for(var i=lo;i<=hi&&i<trackData.length;i++){var ed=Math.min(i-lo,hi-i),rg=Math.max(1,(hi-lo)/2),f=Math.min(1,ed/Math.min(10,rg));trackData[i][0][1]+=o*f}buildVis();document.getElementById('elev-offset').value=0;document.getElementById('elev-val').textContent=0;toast('Elevation applied')}

function previewLoop(){if(loopLine)scene.remove(loopLine);if(trackData.length<10)return;var pts=genLoop(parseInt(document.getElementById('loop-blend').value),parseInt(document.getElementById('loop-pts').value));var p=[];pts.forEach(function(q){p.push(q[0][0],q[0][1],q[0][2])});var g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(p,3));loopLine=new THREE.Line(g,new THREE.LineDashedMaterial({color:0xff44cc,dashSize:8,gapSize:4}));loopLine.computeLineDistances();scene.add(loopLine);toast('Preview: '+pts.length+' loop pts')}
function makeLoop(){if(loopAdded>0)removeLoop();var pts=genLoop(parseInt(document.getElementById('loop-blend').value),parseInt(document.getElementById('loop-pts').value));trackData=trackData.concat(pts);loopAdded=pts.length;if(loopLine){scene.remove(loopLine);loopLine=null}buildVis();updateStats();toast('Added '+pts.length+' loop pts')}
function removeLoop(){if(loopAdded<=0)return;trackData.splice(trackData.length-loopAdded,loopAdded);loopAdded=0;buildVis();updateStats();toast('Loop removed')}
function genLoop(bd,np){var s=trackData[0],e=trackData[trackData.length-1];var st=norm(sub(trackData[Math.min(5,trackData.length-1)][0],s[0])),et=norm(sub(e[0],trackData[Math.max(0,trackData.length-6)][0]));var pts=[];for(var i=1;i<=np;i++){var t=i/(np+1),h00=2*t*t*t-3*t*t+1,h10=t*t*t-2*t*t+t,h01=-2*t*t*t+3*t*t,h11=t*t*t-t*t;var p=[h00*e[0][0]+h10*et[0]*bd+h01*s[0][0]+h11*(-st[0])*bd,h00*e[0][1]+h10*et[1]*bd+h01*s[0][1]+h11*(-st[1])*bd,h00*e[0][2]+h10*et[2]*bd+h01*s[0][2]+h11*(-st[2])*bd];var n=norm([e[1][0]*(1-t)+s[1][0]*t,e[1][1]*(1-t)+s[1][1]*t,e[1][2]*(1-t)+s[1][2]*t]);pts.push([p,n])}return pts}

function loadFile(){document.getElementById('file-input').click()}
function handleFile(e){var f=e.target.files[0];if(!f)return;var r=new FileReader();r.onload=function(ev){try{var raw=JSON.parse(ev.target.result);var d=raw.track||raw;if(Array.isArray(d)&&d.length>0){if(Array.isArray(d[0])&&d[0].length===6)trackData=d.map(function(p){return[[p[0],p[1],p[2]],[p[3],p[4],p[5]]]});else if(Array.isArray(d[0])&&d[0].length===2)trackData=d;else throw new Error('Unknown format');origData=JSON.parse(JSON.stringify(trackData));cps=[];loopAdded=0;selCP=-1;buildVis();updateCPVis();updateStats();fitView();toast('Loaded '+trackData.length+' pts')}}catch(err){toast('Error: '+err.message)}};r.readAsText(f);e.target.value=''}
function exportTrack(){var d=trackData.map(function(p){return[Math.round(p[0][0]*10)/10,Math.round(p[0][1]*10)/10,Math.round(p[0][2]*10)/10,Math.round(p[1][0]*1e4)/1e4,Math.round(p[1][1]*1e4)/1e4,Math.round(p[1][2]*1e4)/1e4]});var ex={track:d,controlPoints:cps.length>0?cps.map(function(c){return{pos:c.pos.map(function(v){return Math.round(v*10)/10}),normal:c.normal.map(function(v){return Math.round(v*1e4)/1e4}),width:Math.round(c.width*10)/10}}):undefined,widths:cps.length>0?interpWidths().map(function(w){return Math.round(w*10)/10}):undefined};var b=new Blob([JSON.stringify(ex,null,2)],{type:'application/json'});var u=URL.createObjectURL(b);var a=document.createElement('a');a.href=u;a.download='track_with_width.json';a.click();URL.revokeObjectURL(u);toast('Exported')}
function undoAll(){if(!origData)return;trackData=JSON.parse(JSON.stringify(origData));cps=[];loopAdded=0;selCP=-1;buildVis();updateCPVis();updateStats();toast('Reverted')}

function setEditMode(m){editMode=m;document.querySelectorAll('.mode-tab').forEach(function(t){t.classList.toggle('active',t.dataset.mode===m)});document.getElementById('mode-select').style.display=m==='select'?'block':'none';document.getElementById('mode-control-points').style.display=m==='control-points'?'block':'none';document.getElementById('mode-width').style.display=m==='width'?'block':'none';if(m==='width'&&cps.length>=2)buildWRib();updateCPVis();drawWGraph()}

function updateStats(){document.getElementById('stat-points').textContent=trackData.length;document.getElementById('stat-cp').textContent=cps.length||'--';var l=0;for(var i=1;i<trackData.length;i++)l+=dst(trackData[i][0],trackData[i-1][0]);document.getElementById('stat-length').textContent=Math.round(l)+'m';if(trackData.length>0){var mY=Infinity,MY=-Infinity;trackData.forEach(function(p){mY=Math.min(mY,p[0][1]);MY=Math.max(MY,p[0][1])});document.getElementById('stat-elevation').textContent=Math.round(MY-mY)+'m'}}

// ============================================================
// TERRAIN GENERATION
// ============================================================
function SeededNoise(seed){
this.perm=new Uint8Array(512);var p=new Uint8Array(256);for(var i=0;i<256;i++)p[i]=i;
var s=seed;for(var i=255;i>0;i--){s=(s*16807+0)%2147483647;var j=s%(i+1);var tmp=p[i];p[i]=p[j];p[j]=tmp}
for(var i=0;i<512;i++)this.perm[i]=p[i&255];
this.grad=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
}
SeededNoise.prototype.dot2=function(g,x,y){return g[0]*x+g[1]*y};
SeededNoise.prototype.noise2D=function(x,y){var F2=0.5*(Math.sqrt(3)-1),G2=(3-Math.sqrt(3))/6;var s=(x+y)*F2;var i=Math.floor(x+s),j=Math.floor(y+s);var t=(i+j)*G2;var x0=x-(i-t),y0=y-(j-t);var i1=x0>y0?1:0,j1=x0>y0?0:1;var x1=x0-i1+G2,y1=y0-j1+G2;var x2=x0-1+2*G2,y2=y0-1+2*G2;var ii=i&255,jj=j&255;var gi0=this.perm[ii+this.perm[jj]]%8,gi1=this.perm[ii+i1+this.perm[jj+j1]]%8,gi2=this.perm[ii+1+this.perm[jj+1]]%8;var n0=0,n1=0,n2=0;var t0=0.5-x0*x0-y0*y0;if(t0>=0){t0*=t0;n0=t0*t0*this.dot2(this.grad[gi0],x0,y0)}var t1=0.5-x1*x1-y1*y1;if(t1>=0){t1*=t1;n1=t1*t1*this.dot2(this.grad[gi1],x1,y1)}var t2=0.5-x2*x2-y2*y2;if(t2>=0){t2*=t2;n2=t2*t2*this.dot2(this.grad[gi2],x2,y2)}return 70*(n0+n1+n2)};
SeededNoise.prototype.fbm=function(x,y,octaves,lacunarity,persistence){var val=0,amp=1,freq=1,maxAmp=0;for(var i=0;i<octaves;i++){val+=this.noise2D(x*freq,y*freq)*amp;maxAmp+=amp;amp*=persistence;freq*=lacunarity}return val/maxAmp};

function generateTerrain(){
var t0=performance.now();
var amp=parseFloat(document.getElementById('s-amp').value);
var freq=parseFloat(document.getElementById('s-freq').value);
var octaves=parseInt(document.getElementById('s-oct').value);
var lac=parseFloat(document.getElementById('s-lac').value);
var per=parseFloat(document.getElementById('s-per').value);
var seed=parseInt(document.getElementById('s-seed').value);
var res=parseInt(document.getElementById('s-res').value);
var ext=parseFloat(document.getElementById('s-ext').value);
var clearance=parseFloat(document.getElementById('s-clear').value);
var blendR=parseFloat(document.getElementById('s-blend').value);
var depress=parseFloat(document.getElementById('s-depress').value);
var wireOn=document.getElementById('chk-wire').checked;
var flatShade=document.getElementById('chk-flat').checked;
var colLow=hexToRGB(document.getElementById('c-low').value);
var colMid=hexToRGB(document.getElementById('c-mid').value);
var colHigh=hexToRGB(document.getElementById('c-high').value);
var colPeak=hexToRGB(document.getElementById('c-peak').value);
var noise=new SeededNoise(seed);
var minX=Infinity,maxX=-Infinity,minZ=Infinity,maxZ=-Infinity,avgH=0;
trackData.forEach(function(p){minX=Math.min(minX,p[0][0]);maxX=Math.max(maxX,p[0][0]);minZ=Math.min(minZ,p[0][2]);maxZ=Math.max(maxZ,p[0][2]);avgH+=p[0][1]});
avgH/=trackData.length;
var gMinX=minX-ext,gMaxX=maxX+ext,gMinZ=minZ-ext,gMaxZ=maxZ+ext;
var stepX=(gMaxX-gMinX)/res,stepZ=(gMaxZ-gMinZ)/res;
var tkPts=trackData.map(function(p){return{x:p[0][0],z:p[0][2],h:p[0][1]}});
function closestTrack(gx,gz){var bd=Infinity,bh=avgH;for(var i=0;i<tkPts.length;i++){var dx=gx-tkPts[i].x,dz=gz-tkPts[i].z,d=Math.sqrt(dx*dx+dz*dz);if(d<bd){bd=d;bh=tkPts[i].h}}return{dist:bd,h:bh}}
var cols=res+1,rows=res+1;var heights=new Float32Array(cols*rows);var minH=Infinity,maxH=-Infinity;
for(var iz=0;iz<=res;iz++){for(var ix=0;ix<=res;ix++){var gx=gMinX+ix*stepX,gz=gMinZ+iz*stepZ,idx=iz*cols+ix;
var h=noise.fbm(gx*freq,gz*freq,octaves,lac,per)*amp+avgH;
var tk=closestTrack(gx,gz);
if(tk.dist<clearance){h=tk.h+depress}else if(tk.dist<clearance+blendR){var t=(tk.dist-clearance)/blendR,s2=t*t*(3-2*t);h=(tk.h+depress)*(1-s2)+h*s2}
heights[idx]=h;minH=Math.min(minH,h);maxH=Math.max(maxH,h)}}
var positions=new Float32Array(cols*rows*3),colors=new Float32Array(cols*rows*3);var hRange=Math.max(maxH-minH,1);
for(var iz=0;iz<=res;iz++){for(var ix=0;ix<=res;ix++){var idx=iz*cols+ix,gx=gMinX+ix*stepX,gz=gMinZ+iz*stepZ,h=heights[idx];
positions[idx*3]=gx;positions[idx*3+1]=h;positions[idx*3+2]=gz;
var nt=(h-minH)/hRange;var r,g,b;
if(nt<.33){var lt=nt/.33;r=colLow[0]*(1-lt)+colMid[0]*lt;g=colLow[1]*(1-lt)+colMid[1]*lt;b=colLow[2]*(1-lt)+colMid[2]*lt}
else if(nt<.66){var lt=(nt-.33)/.33;r=colMid[0]*(1-lt)+colHigh[0]*lt;g=colMid[1]*(1-lt)+colHigh[1]*lt;b=colMid[2]*(1-lt)+colHigh[2]*lt}
else{var lt=(nt-.66)/.34;r=colHigh[0]*(1-lt)+colPeak[0]*lt;g=colHigh[1]*(1-lt)+colPeak[1]*lt;b=colHigh[2]*(1-lt)+colPeak[2]*lt}
var tk2=closestTrack(gx,gz);if(tk2.dist<clearance*1.5){var dT=Math.max(0,1-tk2.dist/(clearance*1.5));r*=(1-dT*.4);g*=(1-dT*.4);b*=(1-dT*.3)}
colors[idx*3]=r;colors[idx*3+1]=g;colors[idx*3+2]=b}}
var indices=[];for(var iz=0;iz<res;iz++){for(var ix=0;ix<res;ix++){var a=iz*cols+ix,b=a+1,c=(iz+1)*cols+ix,d=c+1;indices.push(a,c,b,b,c,d)}}
var geo=new THREE.BufferGeometry();geo.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));geo.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));geo.setIndex(indices);geo.computeVertexNormals();
if(terrainMesh)scene.remove(terrainMesh);if(terrainWire)scene.remove(terrainWire);
terrainMesh=new THREE.Mesh(geo,new THREE.MeshPhongMaterial({vertexColors:true,flatShading:flatShade,side:THREE.DoubleSide,shininess:5}));scene.add(terrainMesh);
if(wireOn){terrainWire=new THREE.LineSegments(new THREE.WireframeGeometry(geo),new THREE.LineBasicMaterial({color:0x1a3a2a,transparent:true,opacity:.3}));scene.add(terrainWire)}
var elapsed=(performance.now()-t0).toFixed(1);
document.getElementById('st-verts').textContent=(cols*rows).toLocaleString();
document.getElementById('st-tris').textContent=(res*res*2).toLocaleString();
document.getElementById('st-time').textContent=elapsed+'ms';
toast('Terrain generated');
}

function clearTerrain(){if(terrainMesh){scene.remove(terrainMesh);terrainMesh=null}if(terrainWire){scene.remove(terrainWire);terrainWire=null}toast('Terrain cleared')}
function hexToRGB(hex){return[parseInt(hex.substr(1,2),16)/255,parseInt(hex.substr(3,2),16)/255,parseInt(hex.substr(5,2),16)/255]}

// ============================================================
// GAMEPLAY - Speed Pads & AI Cars
// ============================================================
function getTrackLength(){var l=0;for(var i=1;i<trackData.length;i++)l+=dst(trackData[i][0],trackData[i-1][0]);return l}
function getTrackPointAt(frac){var total=getTrackLength(),target=frac*total;var accum=0;
for(var i=1;i<trackData.length;i++){var d=dst(trackData[i][0],trackData[i-1][0]);if(accum+d>=target){var t=(target-accum)/d;var pos=trackData[i-1][0].map(function(v,j){return v+(trackData[i][0][j]-v)*t});var fwd=sub(trackData[i][0],trackData[i-1][0]);var fl=Math.sqrt(fwd[0]**2+fwd[1]**2+fwd[2]**2)||1;var nrm=trackData[i-1][1].map(function(v,j){return v+(trackData[i][1][j]-v)*t});return{pos:pos,fwd:[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl],norm:nrm}}accum+=d}
return{pos:[trackData[0][0][0],trackData[0][0][1],trackData[0][0][2]],fwd:[1,0,0],norm:[0,1,0]}}

function placeSpeedPads(){
var count=parseInt(document.getElementById('s-pads').value),boost=parseFloat(document.getElementById('s-boost').value),padLen=parseFloat(document.getElementById('s-padlen').value);
if(speedPadGroup)scene.remove(speedPadGroup);speedPadGroup=new THREE.Group();speedPadData=[];
for(var i=0;i<count;i++){var frac=i/count,tp=getTrackPointAt(frac),pw=20;
var fx=tp.fwd[0],fy=tp.fwd[1],fz=tp.fwd[2];var r=crs(tp.fwd,tp.norm),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;var hw=pw/2,hl=padLen/2;
var v=new Float32Array([tp.pos[0]-fx*hl+r[0]/rl*hw,tp.pos[1]-fy*hl+r[1]/rl*hw+3,tp.pos[2]-fz*hl+r[2]/rl*hw, tp.pos[0]-fx*hl-r[0]/rl*hw,tp.pos[1]-fy*hl-r[1]/rl*hw+3,tp.pos[2]-fz*hl-r[2]/rl*hw, tp.pos[0]+fx*hl+r[0]/rl*hw,tp.pos[1]+fy*hl+r[1]/rl*hw+3,tp.pos[2]+fz*hl+r[2]/rl*hw, tp.pos[0]+fx*hl-r[0]/rl*hw,tp.pos[1]+fy*hl-r[1]/rl*hw+3,tp.pos[2]+fz*hl-r[2]/rl*hw]);
var g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(v,3));g.setIndex([0,1,2,1,3,2]);g.computeVertexNormals();
g.setAttribute('color',new THREE.Float32BufferAttribute([0,.9,1,0,.9,1,1,.9,0,1,.9,0],3));
speedPadGroup.add(new THREE.Mesh(g,new THREE.MeshPhongMaterial({vertexColors:true,emissive:0x004455,side:THREE.DoubleSide,transparent:true,opacity:.85})));
var ag=new THREE.CylinderGeometry(0,3,8,4);var am=new THREE.Mesh(ag,new THREE.MeshPhongMaterial({color:0x00ffcc,emissive:0x00aa88}));am.position.set(tp.pos[0],tp.pos[1]+12,tp.pos[2]);am.rotation.x=Math.PI;speedPadGroup.add(am);
speedPadData.push({position:[tp.pos[0],tp.pos[1],tp.pos[2]],forward:[tp.fwd[0],tp.fwd[1],tp.fwd[2]],boost:boost,length:padLen,trackFraction:frac})}
scene.add(speedPadGroup);speedPadGroup.visible=document.getElementById('chk-pads').checked;toast(count+' pads placed')}

function toggleSpeedPads(){if(speedPadGroup)speedPadGroup.visible=document.getElementById('chk-pads').checked}

function placeAICars(){
var count=parseInt(document.getElementById('s-aicount').value),spacing=parseFloat(document.getElementById('s-aispacing').value),gridCols=parseInt(document.getElementById('s-aigrid').value),startOff=parseFloat(document.getElementById('s-aioffset').value);
if(aiCarGroup)scene.remove(aiCarGroup);aiCarGroup=new THREE.Group();aiCarData=[];
var total=getTrackLength(),laneW=8;
for(var i=0;i<count;i++){var row=Math.floor(i/gridCols),col=i%gridCols,dist=startOff+row*spacing,frac=(dist/total)%1;
var tp=getTrackPointAt(frac);var r=crs(tp.fwd,tp.norm),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;
var lat=(col-(gridCols-1)/2)*laneW;var cx=tp.pos[0]+r[0]/rl*lat,cy=tp.pos[1]+r[1]/rl*lat+4,cz=tp.pos[2]+r[2]/rl*lat;
var hue=(i/count)*360;var body=new THREE.Mesh(new THREE.BoxGeometry(10,4,5),new THREE.MeshPhongMaterial({color:new THREE.Color().setHSL(hue/360,.8,.5)}));
body.position.set(cx,cy,cz);body.lookAt(cx+tp.fwd[0]*10,cy+tp.fwd[1]*10,cz+tp.fwd[2]*10);
var cab=new THREE.Mesh(new THREE.BoxGeometry(5,3,4.5),new THREE.MeshPhongMaterial({color:0x222233}));cab.position.y=3;body.add(cab);
aiCarGroup.add(body);aiCarData.push({position:[cx,cy,cz],forward:[tp.fwd[0],tp.fwd[1],tp.fwd[2]],lane:col,row:row,trackFraction:frac})}
scene.add(aiCarGroup);aiCarGroup.visible=document.getElementById('chk-ai').checked;toast(count+' cars placed')}

function toggleAICars(){if(aiCarGroup)aiCarGroup.visible=document.getElementById('chk-ai').checked}

// ============================================================
// PROCEDURAL SCENERY
// ============================================================
var THEMES = {
neon: {
  barrier: 0x00ffcc, barrierEmit: 0x004433, barrierH: 3,
  bldgColors: [0x1a1a2e, 0x16213e, 0x0f3460], bldgEmit: [0x001122, 0x000a1a, 0x000815],
  windowColor: 0x00ccff, windowEmit: 0x0088aa,
  archColor: 0xff6ec7, archEmit: 0x661144,
  lightColor: 0x00ffcc, lightEmit: 0x00aa88, lightIntensity: 3.14,
  poleColor: 0x333344
},
canyon: {
  barrier: 0x8b6914, barrierEmit: 0x2a1f05, barrierH: 2,
  bldgColors: [0x8b7355, 0x9b8465, 0x7a6245], bldgEmit: [0x1a1008, 0x1a1008, 0x1a1008],
  windowColor: 0x8b7355, windowEmit: 0x1a1008,
  archColor: 0xa0522d, archEmit: 0x3a1a0a,
  lightColor: 0xffaa44, lightEmit: 0xaa6622, lightIntensity: 2.51,
  poleColor: 0x5a4a3a
},
scifi: {
  barrier: 0x8844ff, barrierEmit: 0x220066, barrierH: 4,
  bldgColors: [0x0a0a1a, 0x111128, 0x080820], bldgEmit: [0x110033, 0x0a0022, 0x080020],
  windowColor: 0xaa66ff, windowEmit: 0x6633aa,
  archColor: 0x44aaff, archEmit: 0x113366,
  lightColor: 0xaa66ff, lightEmit: 0x6633aa, lightIntensity: 4.71,
  poleColor: 0x222233
}
};

function generateScenery() {
if (trackData.length < 20) { toast('Load a track first'); return; }
clearScenery();
sceneryGroup = new THREE.Group();
var theme = THEMES[document.getElementById('scenery-theme').value] || THEMES.neon;
var density = parseFloat(document.getElementById('s-scenerydensity').value);
var maxH = parseFloat(document.getElementById('s-sceneryheight').value);
var setback = parseFloat(document.getElementById('s-scenerysetback').value);
var doBarriers = document.getElementById('chk-barriers').checked;
var doBuildings = document.getElementById('chk-buildings').checked;
var doArches = document.getElementById('chk-arches').checked;
var doLights = document.getElementById('chk-lights').checked;
var trackLen = getTrackLength();
var step = 15 / density; // base spacing in world units

// Barriers — continuous wall along both sides
if (doBarriers) {
var barrierStep = 8 / density;
var bh = theme.barrierH, bw = 1.5;
var lVerts = [], rVerts = [], lIdx = [], rIdx = [];
var n = Math.floor(trackLen / barrierStep);
for (var i = 0; i <= n; i++) {
var frac = i / n;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
var hw = (defWidth / 2) + 2;
// Left barrier
var lx = tp.pos[0] - rv[0]*hw, ly = tp.pos[1] - rv[1]*hw + 1, lz = tp.pos[2] - rv[2]*hw;
lVerts.push(lx - rv[0]*bw, ly, lz - rv[2]*bw, lx - rv[0]*bw, ly+bh, lz - rv[2]*bw);
// Right barrier
var rx = tp.pos[0] + rv[0]*hw, ry = tp.pos[1] + rv[1]*hw + 1, rz = tp.pos[2] + rv[2]*hw;
rVerts.push(rx + rv[0]*bw, ry, rz + rv[2]*bw, rx + rv[0]*bw, ry+bh, rz + rv[2]*bw);
if (i > 0) {
var bi = (i-1)*2;
lIdx.push(bi, bi+1, bi+2, bi+1, bi+3, bi+2);
rIdx.push(bi, bi+1, bi+2, bi+1, bi+3, bi+2);
}
}
var bMat = new THREE.MeshPhongMaterial({color: theme.barrier, emissive: theme.barrierEmit, side: THREE.DoubleSide});
[{v:lVerts,i:lIdx},{v:rVerts,i:rIdx}].forEach(function(d){
var g = new THREE.BufferGeometry();
g.setAttribute('position', new THREE.Float32BufferAttribute(d.v, 3));
g.setIndex(d.i); g.computeVertexNormals();
sceneryGroup.add(new THREE.Mesh(g, bMat));
});
}

// Buildings — placed at intervals on both sides
if (doBuildings) {
var bldgStep = 50 / density;
var nBldg = Math.floor(trackLen / bldgStep);
var seed = 12345;
function prng() { seed = (seed * 16807 + 0) % 2147483647; return (seed - 1) / 2147483646; }
for (var i = 0; i < nBldg; i++) {
var frac = i / nBldg;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
for (var side = -1; side <= 1; side += 2) {
var h = maxH * (0.3 + prng() * 0.7);
var w = 12 + prng() * 20;
var d = 12 + prng() * 15;
var dist = setback + prng() * 20;
var cx = tp.pos[0] + rv[0] * side * dist;
var cy = tp.pos[1] + h/2;
var cz = tp.pos[2] + rv[2] * side * dist;
var ci = Math.floor(prng() * theme.bldgColors.length);
var bldg = new THREE.Mesh(
new THREE.BoxGeometry(w, h, d),
new THREE.MeshPhongMaterial({color: theme.bldgColors[ci], emissive: theme.bldgEmit[ci]})
);
bldg.position.set(cx, cy, cz);
// Orient along track
bldg.lookAt(cx + tp.fwd[0], cy, cz + tp.fwd[2]);
sceneryGroup.add(bldg);
// Window strips
var winRows = Math.floor(h / 8);
for (var wr = 0; wr < winRows; wr++) {
var wy = -h/2 + 6 + wr * 8;
var winStrip = new THREE.Mesh(
new THREE.BoxGeometry(w * 0.9, 1.5, d + 0.2),
new THREE.MeshPhongMaterial({color: theme.windowColor, emissive: theme.windowEmit, transparent: true, opacity: 0.6 + prng() * 0.4})
);
winStrip.position.y = wy;
bldg.add(winStrip);
}
}
}
}

// Arches — overhead gates at intervals
if (doArches) {
var archStep = 200 / density;
var nArch = Math.floor(trackLen / archStep);
for (var i = 0; i < nArch; i++) {
var frac = (i + 0.5) / nArch;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
var archW = defWidth + 10, archH = 25, poleR = 1.5;
var archMat = new THREE.MeshPhongMaterial({color: theme.archColor, emissive: theme.archEmit});
// Left pole
var lp = new THREE.Mesh(new THREE.CylinderGeometry(poleR, poleR, archH, 6), archMat);
lp.position.set(tp.pos[0] - rv[0]*archW/2, tp.pos[1] + archH/2, tp.pos[2] - rv[2]*archW/2);
sceneryGroup.add(lp);
// Right pole
var rp = new THREE.Mesh(new THREE.CylinderGeometry(poleR, poleR, archH, 6), archMat);
rp.position.set(tp.pos[0] + rv[0]*archW/2, tp.pos[1] + archH/2, tp.pos[2] + rv[2]*archW/2);
sceneryGroup.add(rp);
// Crossbar
var bar = new THREE.Mesh(new THREE.BoxGeometry(archW, 2, 3), archMat);
bar.position.set(tp.pos[0], tp.pos[1] + archH, tp.pos[2]);
bar.lookAt(tp.pos[0] + tp.fwd[0], tp.pos[1] + archH, tp.pos[2] + tp.fwd[2]);
sceneryGroup.add(bar);
}
}

// Streetlights — poles with point lights
if (doLights) {
var lightStep = 80 / density;
var nLights = Math.floor(trackLen / lightStep);
var poleMat = new THREE.MeshPhongMaterial({color: theme.poleColor});
var bulbMat = new THREE.MeshPhongMaterial({color: theme.lightColor, emissive: theme.lightEmit});
for (var i = 0; i < nLights; i++) {
var frac = i / nLights;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
var side = (i % 2 === 0) ? -1 : 1;
var dist = (defWidth / 2) + 5;
var px = tp.pos[0] + rv[0] * side * dist;
var pz = tp.pos[2] + rv[2] * side * dist;
var py = tp.pos[1];
// Pole
var pole = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 15, 4), poleMat);
pole.position.set(px, py + 7.5, pz);
sceneryGroup.add(pole);
// Bulb
var bulb = new THREE.Mesh(new THREE.SphereGeometry(1.2, 6, 4), bulbMat);
bulb.position.set(px, py + 15.5, pz);
sceneryGroup.add(bulb);
// Light
var pl = new THREE.PointLight(theme.lightColor, theme.lightIntensity, 40, 1);
pl.position.set(px, py + 15, pz);
sceneryGroup.add(pl);
}
}

scene.add(sceneryGroup);
sceneryGroup.visible = document.getElementById('chk-scenery').checked;
toast('Scenery generated');
}

function clearScenery() {
if (sceneryGroup) { scene.remove(sceneryGroup); sceneryGroup = null; }
}
function toggleScenery() { if (sceneryGroup) sceneryGroup.visible = document.getElementById('chk-scenery').checked; }

function exportAll(){
var d={track:trackData.map(function(p){return[Math.round(p[0][0]*10)/10,Math.round(p[0][1]*10)/10,Math.round(p[0][2]*10)/10,Math.round(p[1][0]*1e4)/1e4,Math.round(p[1][1]*1e4)/1e4,Math.round(p[1][2]*1e4)/1e4]}),
speedPads:speedPadData,aiCars:aiCarData,
terrain:{amplitude:parseFloat(document.getElementById('s-amp').value),frequency:parseFloat(document.getElementById('s-freq').value),octaves:parseInt(document.getElementById('s-oct').value),seed:parseInt(document.getElementById('s-seed').value),resolution:parseInt(document.getElementById('s-res').value),extent:parseFloat(document.getElementById('s-ext').value)}};
var b=new Blob([JSON.stringify(d,null,2)],{type:'application/json'});var u=URL.createObjectURL(b);var a=document.createElement('a');a.href=u;a.download='track_scene.json';a.click();URL.revokeObjectURL(u);toast('Scene exported')}

// ============================================================
// IMAGE TO TRACK
// ============================================================
var uploadedImage = null;

function handleImageUpload(e) {
var file = e.target.files[0];
if (!file) return;
var reader = new FileReader();
reader.onload = function(ev) {
var img = new Image();
img.onload = function() {
uploadedImage = img;
processImageToTrack(img);
};
img.src = ev.target.result;
};
reader.readAsDataURL(file);
e.target.value = '';
}

function processImageToTrack(img) {
var scale = parseFloat(document.getElementById('s-imgscale').value);
var targetPts = parseInt(document.getElementById('s-imgpts').value);
var smoothIter = parseInt(document.getElementById('s-imgsmooth').value);
var maxW = 600;
var ratio = Math.min(1, maxW / img.width);
var w = Math.round(img.width * ratio);
var h = Math.round(img.height * ratio);
var cv = document.getElementById('img-canvas');
cv.width = w; cv.height = h;
var ctx = cv.getContext('2d');
ctx.drawImage(img, 0, 0, w, h);
document.getElementById('img-preview').style.display = 'block';
document.getElementById('img-status').textContent = 'Processing...';
var imgData = ctx.getImageData(0, 0, w, h);
var data = imgData.data;
var gray = new Float32Array(w * h);
for (var i = 0; i < w * h; i++) {
gray[i] = (data[i*4] * 0.299 + data[i*4+1] * 0.587 + data[i*4+2] * 0.114) / 255;
}
var bestThresh = 0.5;
var bestVar = 0;
for (var t = 0.1; t < 0.9; t += 0.02) {
var w0 = 0, w1 = 0, s0 = 0, s1 = 0;
for (var i = 0; i < gray.length; i++) {
if (gray[i] < t) { w0++; s0 += gray[i]; }
else { w1++; s1 += gray[i]; }
}
if (w0 === 0 || w1 === 0) continue;
var m0 = s0/w0, m1 = s1/w1;
var v = w0 * w1 * (m0 - m1) * (m0 - m1);
if (v > bestVar) { bestVar = v; bestThresh = t; }
}
var mask = new Uint8Array(w * h);
for (var i = 0; i < gray.length; i++) {
mask[i] = gray[i] < bestThresh ? 1 : 0;
}
var dist = new Float32Array(w * h);
var queue = [];
for (var y = 0; y < h; y++) {
for (var x = 0; x < w; x++) {
var idx = y * w + x;
if (mask[idx] === 0) { dist[idx] = 0; queue.push(idx); }
else dist[idx] = 99999;
}
}
var qi = 0;
while (qi < queue.length) {
var idx = queue[qi++];
var x = idx % w, y = Math.floor(idx / w);
var d = dist[idx] + 1;
var neighbors = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
for (var ni = 0; ni < neighbors.length; ni++) {
var nx = neighbors[ni][0], ny = neighbors[ni][1];
if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
var nidx = ny * w + nx;
if (d < dist[nidx]) { dist[nidx] = d; queue.push(nidx); }
}
}
var ridge = [];
for (var y = 2; y < h - 2; y++) {
for (var x = 2; x < w - 2; x++) {
var idx = y * w + x;
if (mask[idx] === 0) continue;
var d = dist[idx];
if (d < 1.5) continue;
var isMax = true;
for (var dy = -1; dy <= 1 && isMax; dy++) {
for (var dx = -1; dx <= 1 && isMax; dx++) {
if (dx === 0 && dy === 0) continue;
if (dist[(y+dy)*w+(x+dx)] > d) isMax = false;
}
}
if (isMax) ridge.push({ x: x, y: y, d: d });
}
}
if (ridge.length < 10) {
document.getElementById('img-status').textContent = 'No line found! Try a clearer image.';
return;
}
var gridSize = 10;
var gridW = Math.ceil(w / gridSize), gridH = Math.ceil(h / gridSize);
var sgrid = new Array(gridW * gridH);
for(var i=0;i<sgrid.length;i++)sgrid[i]=[];
ridge.forEach(function(p, i) {
var gx = Math.floor(p.x / gridSize), gy = Math.floor(p.y / gridSize);
sgrid[gy * gridW + gx].push(i);
});
function findNearest(last, used, maxDist) {
var gx = Math.floor(last.x / gridSize), gy = Math.floor(last.y / gridSize);
var searchR = Math.ceil(maxDist / gridSize) + 1;
var bestIdx = -1, bestDist = maxDist * maxDist;
for (var dy = -searchR; dy <= searchR; dy++) {
for (var dx = -searchR; dx <= searchR; dx++) {
var nx = gx + dx, ny = gy + dy;
if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
var cell = sgrid[ny * gridW + nx];
for (var ci = 0; ci < cell.length; ci++) {
var j = cell[ci];
if (used.has(j)) continue;
var ddx = ridge[j].x - last.x, ddy = ridge[j].y - last.y;
var dd = ddx*ddx + ddy*ddy;
if (dd < bestDist) { bestDist = dd; bestIdx = j; }
}
}
}
return bestIdx;
}
var startIdx = 0;
var minY2 = Infinity;
for (var i = 0; i < ridge.length; i++) {
if (ridge[i].y < minY2) { minY2 = ridge[i].y; startIdx = i; }
}
var ordered = [ridge[startIdx]];
var used = new Set([startIdx]);
var maxGap = 25;
for (var iter = 0; iter < ridge.length - 1; iter++) {
var last = ordered[ordered.length - 1];
var bestIdx = findNearest(last, used, maxGap);
if (bestIdx < 0) break;
ordered.push(ridge[bestIdx]);
used.add(bestIdx);
}
var totalPathLen = ordered.reduce(function(sum, p, i) {
if (i === 0) return 0;
return sum + Math.hypot(p.x - ordered[i-1].x, p.y - ordered[i-1].y);
}, 0);
var step = totalPathLen / targetPts;
var sampled = [ordered[0]];
var accum = 0;
for (var i = 1; i < ordered.length; i++) {
accum += Math.hypot(ordered[i].x - ordered[i-1].x, ordered[i].y - ordered[i-1].y);
if (accum >= step) {
sampled.push(ordered[i]);
accum = 0;
}
}
var pts = sampled.map(function(p) { return { x: p.x, y: p.y }; });
for (var iter = 0; iter < smoothIter; iter++) {
var next = pts.map(function(p, i) {
if (i === 0 || i === pts.length - 1) return { x: p.x, y: p.y };
return {
x: p.x * 0.5 + (pts[i-1].x + pts[i+1].x) * 0.25,
y: p.y * 0.5 + (pts[i-1].y + pts[i+1].y) * 0.25
};
});
pts = next;
}
var imgCx = w / 2, imgCy = h / 2;
var worldScale = scale / Math.max(w, h);
var baseY = -250;
var newTrack = pts.map(function(p) {
var wx = (p.x - imgCx) * worldScale;
var wz = (p.y - imgCy) * worldScale;
return [[wx, baseY, wz], [0, 1, 0]];
});
if (newTrack.length >= 3) {
var first = newTrack[0][0], last = newTrack[newTrack.length - 1][0];
var gap = Math.hypot(first[0]-last[0], first[2]-last[2]);
if (gap < scale * 0.15) {
var closePts = Math.max(3, Math.round(gap / (totalPathLen * worldScale / targetPts)));
for (var i = 1; i <= closePts; i++) {
var t = i / (closePts + 1);
newTrack.push([
[last[0] + (first[0]-last[0])*t, baseY, last[2] + (first[2]-last[2])*t],
[0, 1, 0]
]);
}
newTrack.push([[first[0],first[1],first[2]], [0, 1, 0]]);
}
}
trackData = newTrack;
origData = JSON.parse(JSON.stringify(trackData));
cps = []; loopAdded = 0; selCP = -1;
buildVis(); updateCPVis(); updateStats(); fitView();
ctx.strokeStyle = '#ff6b35';
ctx.lineWidth = 2;
ctx.beginPath();
pts.forEach(function(p, i) { i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y); });
ctx.stroke();
ctx.fillStyle = 'rgba(0,212,170,0.3)';
ordered.forEach(function(p) { ctx.fillRect(p.x-1, p.y-1, 2, 2); });
document.getElementById('img-status').textContent = pts.length + ' pts traced (' + ridge.length + ' ridge px)';
toast('Track traced: ' + newTrack.length + ' points');
}

// ============================================================
// PLAY MODE
// ============================================================
var gameActive = false;

function startGame() {
try {
if (trackData.length < 20) { toast('Track too short to play'); return; }
var exportedTrack = trackData.map(function(p) { return [
[Math.round(p[0][0]*10)/10, Math.round(p[0][1]*10)/10, Math.round(p[0][2]*10)/10],
[Math.round(p[1][0]*1e4)/1e4, Math.round(p[1][1]*1e4)/1e4, Math.round(p[1][2]*1e4)/1e4]
]; });
toast('Loading Horizon Drive...');
var overlay = document.getElementById('game-overlay');
var iframe = document.getElementById('game-iframe');
// Listen for messages from the game iframe
window._gameMessageHandler = function(e) {
if (e.data && e.data.type === 'gameReady') {
  iframe.contentWindow.postMessage({ type: 'trackData', track: exportedTrack }, '*');
}
if (e.data && e.data.type === 'gameExit') {
  stopGame();
}
};
window.addEventListener('message', window._gameMessageHandler);
iframe.src = 'game.html';
overlay.style.display = 'block';
gameActive = true;
window._gameEscHandler = function(e) { if (e.key === 'Escape') stopGame(); };
window.addEventListener('keydown', window._gameEscHandler);
} catch(err) { toast('Launch error: ' + err.message); console.error(err); }
}

function stopGame() {
var overlay = document.getElementById('game-overlay');
var iframe = document.getElementById('game-iframe');
overlay.style.display = 'none';
iframe.src = 'about:blank';
gameActive = false;
if (window._gameMessageHandler) {
window.removeEventListener('message', window._gameMessageHandler);
window._gameMessageHandler = null;
}
if (window._gameEscHandler) {
window.removeEventListener('keydown', window._gameEscHandler);
window._gameEscHandler = null;
}
toast('Back to editor');
}

// ============================================================
// MARBLE WORLD GENERATION + SPARK.JS SPLAT VIEWER
// ============================================================
var _proxyUrl = '';
var _RUNWAY_PREFIX = 'https://api.dev.runwayml.com/v1/';
var _MARBLE_PREFIX = 'https://api.worldlabs.ai/marble/v1/';
var _DECART_PREFIX = 'https://api.decart.ai/v1/';
async function proxiedFetch(url, opts) {
  opts = opts || {};
  if (_proxyUrl) {
    var workerPath = null;
    if (url.indexOf(_RUNWAY_PREFIX) === 0) workerPath = '/runway/' + url.slice(_RUNWAY_PREFIX.length);
    else if (url.indexOf(_MARBLE_PREFIX) === 0) workerPath = '/marble/' + url.slice(_MARBLE_PREFIX.length);
    else if (url.indexOf(_DECART_PREFIX) === 0) workerPath = '/decart/' + url.slice(_DECART_PREFIX.length);
    if (workerPath) {
      // Strip auth headers — Worker adds them server-side
      var h = {};
      if (opts.headers) { for (var k in opts.headers) { var kl = k.toLowerCase(); if (kl !== 'authorization' && kl !== 'wlt-api-key' && kl !== 'x-api-key' && kl !== 'x-runway-version') h[k] = opts.headers[k]; } }
      return fetch(_proxyUrl + workerPath, Object.assign({}, opts, { headers: h }));
    }
    // Non-API URL: try direct, fallback to Worker generic proxy
    try { return await fetch(url, opts); }
    catch (e) { return fetch(_proxyUrl + '/fetch?url=' + encodeURIComponent(url), opts); }
  }
  try { return await fetch(url, opts); }
  catch (e) { return fetch('https://corsproxy.io/?' + encodeURIComponent(url), opts); }
}

// ---- Visibility-aware polling sleep ----
// When the tab is backgrounded, browsers throttle setTimeout to >=1s (or pause entirely).
// This mechanism lets polling loops be woken up early when the tab regains focus.
var _pollWakeResolvers = [];
function pollSleep(ms) {
  return new Promise(function(resolve) {
    var done = false;
    var timer = setTimeout(function() { if (!done) { done = true; resolve('timer'); } }, ms);
    _pollWakeResolvers.push(function() { if (!done) { done = true; clearTimeout(timer); resolve('wake'); } });
  });
}
function wakePollLoops() {
  var fns = _pollWakeResolvers.splice(0);
  fns.forEach(function(fn) { fn(); });
}
document.addEventListener('visibilitychange', function() {
  if (!document.hidden) {
    wakePollLoops();
    showRunwayPending();
    showDecartPending();
    showMarblePending();
  }
});

// ---- Runway pending state persistence ----
function saveRunwayPending(taskId, apiKey) {
  localStorage.setItem('runway_pending', JSON.stringify({ taskId: taskId, apiKey: apiKey, time: Date.now() }));
}
function clearRunwayPending() {
  localStorage.removeItem('runway_pending');
  var el = document.getElementById('runway-pending'); if (el) el.style.display = 'none';
}
function showRunwayPending() {
  var raw = localStorage.getItem('runway_pending'); if (!raw) return;
  try { var p = JSON.parse(raw); } catch(e) { return; }
  var age = Math.round((Date.now() - p.time) / 60000);
  if (age > 15) { clearRunwayPending(); return; }
  var el = document.getElementById('runway-pending'); if (!el) return;
  document.getElementById('runway-pending-info').textContent = 'Task: ' + p.taskId.substring(0, 12) + '... (' + age + ' min ago)';
  el.style.display = 'block';
}
async function checkRunwayOperation() {
  var raw = localStorage.getItem('runway_pending'); if (!raw) { toast('No pending Runway task'); return; }
  try { var p = JSON.parse(raw); } catch(e) { toast('Invalid pending data'); clearRunwayPending(); return; }
  var progEl = document.getElementById('runway-progress');
  var pendEl = document.getElementById('runway-pending');
  progEl.style.display = 'block';
  progEl.textContent = 'Checking Runway task status...';
  pendEl.style.display = 'none';
  var apiKey = p.apiKey || document.getElementById('runway-apikey').value.trim();
  if (!apiKey) { toast('Enter your Runway API key first'); pendEl.style.display = 'block'; return; }
  var headers = { 'Authorization': 'Bearer ' + apiKey, 'X-Runway-Version': '2024-11-06' };
  try {
    var res = await proxiedFetch('https://api.dev.runwayml.com/v1/tasks/' + p.taskId, { headers: headers });
    if (!res.ok) throw new Error('Poll failed: ' + res.status);
    var data = await res.json();
    if (data.status === 'SUCCEEDED') {
      clearRunwayPending();
      _runwayVideoUrl = data.output[0];
      var videoEl = document.getElementById('runway-video');
      videoEl.src = _runwayVideoUrl; videoEl.style.display = 'block';
      progEl.textContent = 'Runway stylization complete!';
      toast('Runway video ready');
    } else if (data.status === 'FAILED') {
      clearRunwayPending();
      throw new Error('Runway failed: ' + (data.failureCode || 'unknown'));
    } else if (data.status === 'CANCELED') {
      clearRunwayPending();
      throw new Error('Runway task canceled');
    } else {
      progEl.textContent = 'Still generating — resuming poll...';
      _runwayVideoUrl = await pollRunwayTask(p.taskId, apiKey, progEl);
      var videoEl = document.getElementById('runway-video');
      videoEl.src = _runwayVideoUrl; videoEl.style.display = 'block';
      progEl.textContent = 'Runway stylization complete!';
      toast('Runway video ready');
    }
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('Runway error: ' + err.message);
    console.error('Runway check error:', err);
  }
}

var _splatMesh = null;
var _sparkLoaded = false;

async function ensureSparkLoaded() {
if (_sparkLoaded) return;
if (window.Spark) { _sparkLoaded = true; return; }
var mod = await import('https://cdn.jsdelivr.net/npm/@sparkjsdev/spark@0.1.10/dist/spark.module.js');
window.Spark = mod;
_sparkLoaded = true;
}

function captureScreenshot() {
if (!trackData.length) { rndr.render(scene, cam); return rndr.domElement.toDataURL('image/png'); }
// Save current camera state
var savePhi = orb.phi, saveTheta = orb.theta, saveDist = orb.dist;
var saveTgt = orb.tgt.clone();
// Compute track bounding box
var minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
trackData.forEach(function(p){
minX=Math.min(minX,p[0][0]);maxX=Math.max(maxX,p[0][0]);
minY=Math.min(minY,p[0][1]);maxY=Math.max(maxY,p[0][1]);
minZ=Math.min(minZ,p[0][2]);maxZ=Math.max(maxZ,p[0][2]);
});
// Top-down: phi=0.001 (nearly straight down), theta=0
orb.tgt.set((minX+maxX)/2,(minY+maxY)/2,(minZ+maxZ)/2);
orb.phi = 0.001;
orb.theta = 0;
orb.dist = Math.max(maxX-minX, maxZ-minZ) * 1.1;
updCam();
rndr.render(scene, cam);
var dataUrl = rndr.domElement.toDataURL('image/png');
// Restore camera
orb.phi = savePhi; orb.theta = saveTheta; orb.dist = saveDist;
orb.tgt.copy(saveTgt);
updCam();
return dataUrl;
}

function analyzeTrack() {
if (trackData.length < 20) return { flat: true, tight: false, compact: true, elRange: 0, avgCurv: 0, hasLoop: false };
var pts = trackData.map(function(p) { return p[0]; });
var minY = Infinity, maxY = -Infinity, minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
var totalCurv = 0, segCount = 0;
for (var i = 0; i < pts.length; i++) {
var y = pts[i][1]; if (y < minY) minY = y; if (y > maxY) maxY = y;
var x = pts[i][0]; if (x < minX) minX = x; if (x > maxX) maxX = x;
var z = pts[i][2]; if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
if (i > 0 && i < pts.length - 1) {
var ax = pts[i-1][0], az = pts[i-1][2], bx = pts[i][0], bz = pts[i][2], cx = pts[i+1][0], cz = pts[i+1][2];
var d1x = bx-ax, d1z = bz-az, d2x = cx-bx, d2z = cz-bz;
var l1 = Math.sqrt(d1x*d1x+d1z*d1z)||1, l2 = Math.sqrt(d2x*d2x+d2z*d2z)||1;
var dot = (d1x*d2x+d1z*d2z)/(l1*l2);
totalCurv += Math.acos(Math.max(-1,Math.min(1,dot)));
segCount++;
}
}
var elRange = maxY - minY;
var avgCurv = segCount > 0 ? totalCurv / segCount : 0;
var spanX = maxX - minX, spanZ = maxZ - minZ;
var footprint = Math.max(spanX, spanZ);
var hasLoop = elRange > 40;
return { flat: elRange < 8, hilly: elRange >= 8 && elRange < 30, mountainous: elRange >= 30,
tight: avgCurv > 0.06, flowing: avgCurv <= 0.03, compact: footprint < 150, sprawling: footprint > 400,
elRange: elRange, avgCurv: avgCurv, footprint: footprint, hasLoop: hasLoop };
}

var _capturedScreenshot = null;

function trackAwarePrompt() {
if (trackData.length < 20) { toast('Load a track first'); return; }
// 1. Capture screenshot
_capturedScreenshot = captureScreenshot();
var preview = document.getElementById('marble-screenshot-preview');
document.getElementById('marble-screenshot-img').src = _capturedScreenshot;
preview.style.display = 'block';
// 2. Set input mode to screenshot
document.getElementById('marble-mode').value = 'screenshot';
// 3. Generate geometry-aware prompt
var t = analyzeTrack();
var p = 'racing track environment';
if (t.mountainous || t.hasLoop) p = 'dramatic mountain racing road with steep elevation changes and vertical sections';
else if (t.hilly) p = 'hillside racing road winding through varied terrain';
else p = 'wide racing highway on mostly flat ground';
if (t.tight) p += ', tight technical corners and sharp switchbacks';
else if (t.flowing) p += ', long sweeping high-speed curves';
else p += ', a mix of fast straights and medium-speed bends';
if (t.sprawling) p += ', vast open landscape stretching to the horizon';
else if (t.compact) p += ', enclosed arena-style layout surrounded by structures';
p += ', futuristic roadside barriers and signage, dramatic sky, volumetric lighting, photorealistic detail';
document.getElementById('marble-prompt').value = p;
toast('Screenshot captured + prompt generated — hit Generate World');
}

function saveMarblePending(opId, apiKey, quality) {
localStorage.setItem('marble_pending', JSON.stringify({ opId: opId, apiKey: apiKey, quality: quality, time: Date.now() }));
}
function clearMarblePending() {
localStorage.removeItem('marble_pending');
var el = document.getElementById('marble-pending'); if (el) el.style.display = 'none';
}
function showMarblePending() {
var raw = localStorage.getItem('marble_pending'); if (!raw) return;
try { var p = JSON.parse(raw); } catch(e) { return; }
var age = Math.round((Date.now() - p.time) / 60000);
if (age > 30) { clearMarblePending(); return; }
var el = document.getElementById('marble-pending'); if (!el) return;
document.getElementById('marble-pending-info').textContent = 'Operation: ' + p.opId.substring(0, 20) + '... (' + age + ' min ago)';
el.style.display = 'block';
}
function handleMarbleResult(worldData, quality) {
var progEl = document.getElementById('marble-progress');
var assets = worldData.assets;
var splatUrl = null;
if (assets && assets.splats && assets.splats.spz_urls) {
splatUrl = assets.splats.spz_urls[quality] || assets.splats.spz_urls['100k'] || assets.splats.spz_urls['full_res'];
}
var colliderUrl = null;
if (assets && assets.mesh) { colliderUrl = assets.mesh.collider_mesh_url; }
if (splatUrl) {
document.getElementById('splat-url').value = splatUrl;
progEl.textContent = 'World generated! Loading splat...';
loadSplatFromURL();
if (colliderUrl) { window._marbleColliderUrl = colliderUrl; }
} else {
progEl.textContent = 'World generated! View at: ' + (worldData.world_marble_url || '');
if (worldData.world_marble_url) { window.open(worldData.world_marble_url, '_blank'); }
}
toast('World generated!');
}
async function pollMarbleOp(opId, apiKey, quality, progEl) {
var startTime = Date.now();
var maxMs = 9 * 60 * 1000; // 9 min wall-clock timeout
while (Date.now() - startTime < maxMs) {
await pollSleep(3000);
var elapsed = Math.round((Date.now() - startTime) / 1000);
progEl.textContent = 'Generating 3D world... (' + elapsed + 's)';
try {
var pollRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/operations/' + opId, { headers: { 'WLT-Api-Key': apiKey } });
if (!pollRes.ok) continue;
var pollData = await pollRes.json();
if (pollData.done) {
clearMarblePending();
if (pollData.error) throw new Error('Generation error: ' + (pollData.error.message || JSON.stringify(pollData.error)));
return pollData.response;
}
if (pollData.metadata && pollData.metadata.progress) {
progEl.textContent = 'Generating: ' + (pollData.metadata.progress.description || pollData.metadata.progress.status);
}
} catch (e) {
if (e.message.includes('Generation error')) throw e;
}
}
throw new Error('Timeout waiting for world generation');
}
async function checkMarbleOperation() {
var raw = localStorage.getItem('marble_pending'); if (!raw) { toast('No pending operation'); return; }
try { var p = JSON.parse(raw); } catch(e) { toast('Invalid pending data'); clearMarblePending(); return; }
var progEl = document.getElementById('marble-progress');
var pendEl = document.getElementById('marble-pending');
progEl.style.display = 'block';
progEl.textContent = 'Checking operation status...';
pendEl.style.display = 'none';
var apiKey = p.apiKey || document.getElementById('marble-apikey').value.trim();
if (!apiKey) { toast('Enter your API key first'); pendEl.style.display = 'block'; return; }
try {
var pollRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/operations/' + p.opId, { headers: { 'WLT-Api-Key': apiKey } });
if (!pollRes.ok) throw new Error('Poll failed: ' + pollRes.status);
var pollData = await pollRes.json();
if (pollData.done) {
clearMarblePending();
if (pollData.error) throw new Error('Generation error: ' + (pollData.error.message || JSON.stringify(pollData.error)));
handleMarbleResult(pollData.response, p.quality || '100k');
} else {
progEl.textContent = 'Still generating — resuming poll...';
var worldData = await pollMarbleOp(p.opId, apiKey, p.quality || '100k', progEl);
handleMarbleResult(worldData, p.quality || '100k');
}
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Error: ' + err.message);
console.error('Marble check error:', err);
}
}
async function generateMarbleWorld() {
var apiKey = document.getElementById('marble-apikey').value.trim();
if (!apiKey) { toast('Enter a Marble API key'); return; }
var prompt = document.getElementById('marble-prompt').value.trim();
var mode = document.getElementById('marble-mode').value;
var quality = document.getElementById('marble-quality').value;
var progEl = document.getElementById('marble-progress');
var btn = document.getElementById('marble-gen-btn');
if (!prompt) { toast('Enter an environment prompt'); return; }
progEl.style.display = 'block';
progEl.textContent = 'Preparing request...';
btn.disabled = true;
btn.textContent = 'Generating...';
var headers = { 'Content-Type': 'application/json', 'WLT-Api-Key': apiKey };
try {
var worldPrompt;
if (mode === 'screenshot' && trackData.length > 10) {
progEl.textContent = 'Capturing viewport screenshot...';
var screenshotDataUrl = _capturedScreenshot || captureScreenshot();
_capturedScreenshot = null;
var blob = await (await fetch(screenshotDataUrl)).blob();
progEl.textContent = 'Uploading screenshot to Marble...';
var uploadRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/media-assets:prepare_upload', {
method: 'POST', headers: headers,
body: JSON.stringify({ file_name: 'track-screenshot.png', kind: 'image', extension: 'png' })
});
if (!uploadRes.ok) throw new Error(uploadRes.status === 401 ? 'Invalid API key — check your Marble key' : 'Media asset creation failed: ' + uploadRes.status);
var uploadData = await uploadRes.json();
var mediaAssetId = uploadData.media_asset.media_asset_id;
var uploadUrl = uploadData.upload_info.upload_url;
var uploadMethod = uploadData.upload_info.upload_method || 'PUT';
var uploadHeaders = uploadData.upload_info.required_headers || {};
await proxiedFetch(uploadUrl, { method: uploadMethod, headers: uploadHeaders, body: blob });
worldPrompt = { type: 'image', image_prompt: { source: 'media_asset', media_asset_id: mediaAssetId }, text_prompt: prompt };
} else {
worldPrompt = { type: 'text', text_prompt: prompt };
}
progEl.textContent = 'Generating 3D world (this takes 1-3 minutes)...';
var genRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/worlds:generate', {
method: 'POST', headers: headers,
body: JSON.stringify({ display_name: 'Track Environment', model: 'Marble 0.1-plus', world_prompt: worldPrompt })
});
if (!genRes.ok) { if (genRes.status === 401) throw new Error('Invalid API key — check your Marble key'); var errText = await genRes.text(); throw new Error('Generation failed (' + genRes.status + '): ' + errText); }
var genData = await genRes.json();
var opId = genData.operation_id || genData.name;
var worldData = null;
if (genData.done && genData.response) {
worldData = genData.response;
} else if (opId) {
saveMarblePending(opId, apiKey, quality);
progEl.textContent = 'Generating 3D world... (you can close this tab and check back later)';
worldData = await pollMarbleOp(opId, apiKey, quality, progEl);
} else {
worldData = genData.world || genData;
}
handleMarbleResult(worldData, quality);
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Error: ' + err.message);
console.error('Marble generation error:', err);
} finally {
btn.disabled = false;
btn.textContent = 'Generate World';
}
}

// ============================================================
// FLYTHROUGH → RUNWAY → MARBLE PIPELINE
// ============================================================
var _flyBlob = null;
var _flyFrames = [];
var _runwayVideoUrl = null;

async function recordFlythrough() {
if (trackData.length < 20) { toast('Load a track first'); return; }
var duration = parseInt(document.getElementById('s-flydur').value);
var resVal = document.getElementById('fly-res').value;
var camH = parseFloat(document.getElementById('s-flyht').value);
var w = resVal === '1080' ? 1920 : 1280;
var h = resVal === '1080' ? 1080 : 720;
var fps = 30;
var totalFrames = duration * fps;
var btn = document.getElementById('fly-rec-btn');
var progEl = document.getElementById('fly-progress');
btn.disabled = true; btn.textContent = 'Recording...';
progEl.style.display = 'block'; progEl.textContent = 'Building spline...';

// Build CatmullRomCurve3 from track data
var pts = [];
var step = Math.max(1, Math.floor(trackData.length / 500));
for (var i = 0; i < trackData.length; i += step) {
pts.push(new THREE.Vector3(trackData[i][0][0], trackData[i][0][1], trackData[i][0][2]));
}
var last = trackData[trackData.length - 1][0];
if (pts.length < 2 || pts[pts.length - 1].distanceTo(new THREE.Vector3(last[0], last[1], last[2])) > 1) {
pts.push(new THREE.Vector3(last[0], last[1], last[2]));
}
// Detect closed loop: if start and end are within 50 units, close the spline
var first = trackData[0][0];
var trackGap = Math.hypot(first[0] - last[0], first[1] - last[1], first[2] - last[2]);
var isClosed = trackGap < 50;
var flyCurve = new THREE.CatmullRomCurve3(pts, isClosed, 'catmullrom', 0.5);

// Hide editor-only overlays during recording
var hidden = [];
[ptCloud, selHL, cpGrp, splineLine].forEach(function(obj) {
if (obj && obj.visible) { obj.visible = false; hidden.push(obj); }
});
scene.traverse(function(obj) {
if (obj.type === 'GridHelper' && obj.visible) { obj.visible = false; hidden.push(obj); }
});

// Temporary environment for Runway context (sky dome + ground plane)
var _origBg = scene.background;
var _origFog = scene.fog;
scene.background = new THREE.Color(0x050510);
scene.fog = new THREE.FogExp2(0x050510, 0.00015);

// Sky dome: large inverted sphere with vertex-color gradient (horizon glow → dark zenith)
var skyGeo = new THREE.SphereGeometry(8000, 32, 24);
var skyColors = [];
var skyPos = skyGeo.getAttribute('position');
for (var si = 0; si < skyPos.count; si++) {
  var ny = (skyPos.getY(si) / 8000 + 1) * 0.5; // 0 at bottom, 1 at top
  // Horizon: warm dark purple/blue, zenith: near-black with slight blue
  var hr = 0.06, hg = 0.04, hb = 0.12; // horizon
  var zr = 0.01, zg = 0.01, zb = 0.03; // zenith
  var blend = Math.pow(ny, 0.6);
  skyColors.push(hr + (zr - hr) * blend, hg + (zg - hg) * blend, hb + (zb - hb) * blend);
}
skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(skyColors, 3));
var skyMat = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide });
var skyDome = new THREE.Mesh(skyGeo, skyMat);
scene.add(skyDome);

// Stars: scattered points in the sky
var starCount = 800;
var starPositions = new Float32Array(starCount * 3);
for (var si = 0; si < starCount; si++) {
  var phi = Math.acos(2 * Math.random() - 1);
  var theta = Math.random() * Math.PI * 2;
  var sr = 7500 + Math.random() * 400;
  starPositions[si * 3] = sr * Math.sin(phi) * Math.cos(theta);
  starPositions[si * 3 + 1] = Math.abs(sr * Math.cos(phi)); // upper hemisphere only
  starPositions[si * 3 + 2] = sr * Math.sin(phi) * Math.sin(theta);
}
var starGeo = new THREE.BufferGeometry();
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
var starMat = new THREE.PointsMaterial({ color: 0xccccff, size: 6, sizeAttenuation: true });
var starField = new THREE.Points(starGeo, starMat);
scene.add(starField);

// Ground plane: dark textured surface extending to horizon
var groundGeo = new THREE.PlaneGeometry(16000, 16000, 64, 64);
var groundPos = groundGeo.getAttribute('position');
var groundColors = [];
for (var gi = 0; gi < groundPos.count; gi++) {
  var gx = groundPos.getX(gi), gz = groundPos.getY(gi); // plane is XY, we rotate it
  var dist = Math.sqrt(gx * gx + gz * gz) / 8000;
  // Slight variation for texture, darken at edges
  var fade = Math.max(0, 1 - dist * 0.7);
  var base = 0.025 + 0.015 * fade;
  groundColors.push(base * 0.8, base * 0.9, base * 1.2);
}
groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(groundColors, 3));
var groundMat = new THREE.MeshBasicMaterial({ vertexColors: true });
var groundMesh = new THREE.Mesh(groundGeo, groundMat);
groundMesh.rotation.x = -Math.PI / 2;
groundMesh.position.y = -2; // slightly below track
scene.add(groundMesh);

// Offscreen renderer
var offR = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
offR.setSize(w, h); offR.setPixelRatio(1);
offR.outputColorSpace = THREE.LinearSRGBColorSpace;
var offCam = new THREE.PerspectiveCamera(60, w / h, 1, 20000);

// Copy editor scene lighting
// (scene is shared, so lighting already exists)

// MediaRecorder setup
var stream = offR.domElement.captureStream(0);
var vTrack = stream.getVideoTracks()[0];
var hasRF = typeof vTrack.requestFrame === 'function';
if (!hasRF) { stream = offR.domElement.captureStream(fps); }
var mimeType = bestRecorderMime();
var blobType = mimeType.split(';')[0]; // clean MIME for blob/data URI
var recorder = new MediaRecorder(stream, { mimeType: mimeType, videoBitsPerSecond: 8000000 });
var chunks = [];
recorder.ondataavailable = function(e) { if (e.data.size) chunks.push(e.data); };

_flyFrames = [];
_flyBlob = null;

// --- Pre-pass: capture keyframe images for Runway segment chaining ---
// Done BEFORE recorder.start() so the expensive toDataURL calls don't
// add wall-clock time to the recording (MediaRecorder uses wall-clock for timestamps).
progEl.textContent = 'Capturing keyframes...';
for (var kf = 0; kf <= duration; kf++) {
  var kfFrame = kf === duration ? totalFrames - 1 : kf * fps;
  var kt = isClosed ? kfFrame / totalFrames : Math.min(kfFrame / Math.max(totalFrames - 1, 1), 0.9999);
  var kLookT = kt + 0.02;
  if (isClosed) { kLookT = kLookT % 1; } else { kLookT = Math.min(kLookT, 0.9999); }
  var kPt = flyCurve.getPointAt(kt);
  var kLook = flyCurve.getPointAt(kLookT);
  var kTan = flyCurve.getTangentAt(kt).normalize();
  offCam.position.set(kPt.x - kTan.x * 10, kPt.y + camH, kPt.z - kTan.z * 10);
  offCam.lookAt(kLook.x, kLook.y + camH * 0.3, kLook.z);
  offCam.updateMatrixWorld(true);
  offR.clear(); offR.render(scene, offCam);
  var label = kf === 0 ? 'first' : kf === duration ? 'last' : 't' + kf;
  _flyFrames.push({
    label: label, time: kfFrame / fps, frameIndex: kfFrame,
    dataUrl: offR.domElement.toDataURL('image/jpeg', 0.92)
  });
}

// --- Main recording pass: wall-clock driven ---
// Camera position is derived from elapsed wall-clock time, NOT frame count.
// This guarantees the full track is traversed in exactly `duration` seconds
// regardless of how long each render() takes. If rendering is slow, we get
// fewer frames (lower effective fps) but correct duration and full traversal.
var recordingDurationMs = duration * 1000;
var frameInterval = 1000 / fps;
recorder.start();
var recordingStart = performance.now();
var f = 0;

while (true) {
  var elapsed = performance.now() - recordingStart;
  if (elapsed >= recordingDurationMs) break;

  // Camera position based on elapsed time, not frame count
  var t = elapsed / recordingDurationMs;
  if (isClosed) {
    t = t % 1;
  } else {
    t = Math.min(t, 0.9999);
  }
  var lookT = t + 0.02;
  if (isClosed) { lookT = lookT % 1; } else { lookT = Math.min(lookT, 0.9999); }

  var point = flyCurve.getPointAt(t);
  var lookPt = flyCurve.getPointAt(lookT);
  var tangent = flyCurve.getTangentAt(t).normalize();

  offCam.position.set(
    point.x - tangent.x * 10,
    point.y + camH,
    point.z - tangent.z * 10
  );
  offCam.lookAt(lookPt.x, lookPt.y + camH * 0.3, lookPt.z);
  offCam.updateMatrixWorld(true);

  offR.clear(); offR.render(scene, offCam);
  if (hasRF) vTrack.requestFrame();

  f++;
  var pct = Math.min(100, Math.round(elapsed / recordingDurationMs * 100));
  progEl.textContent = 'Recording ' + pct + '% (' + f + ' frames)';

  // Sleep remaining time until next frame interval
  var nextFrameTime = recordingStart + f * frameInterval;
  var sleepMs = nextFrameTime - performance.now();
  if (sleepMs > 1) {
    await new Promise(function(r) { setTimeout(r, sleepMs); });
  } else {
    // Render took longer than frame interval — just yield and continue.
    // We'll get fewer frames but wall-clock stays correct.
    await new Promise(function(r) { setTimeout(r, 0); });
  }
}

// Ensure we hit exactly the target duration before stopping
var remaining = recordingDurationMs - (performance.now() - recordingStart);
if (remaining > 10) {
  await new Promise(function(r) { setTimeout(r, remaining); });
}

// Remove temporary environment objects and restore scene
scene.remove(skyDome); skyGeo.dispose(); skyMat.dispose();
scene.remove(starField); starGeo.dispose(); starMat.dispose();
scene.remove(groundMesh); groundGeo.dispose(); groundMat.dispose();
scene.background = _origBg;
scene.fog = _origFog;

// Restore hidden objects
hidden.forEach(function(obj) { obj.visible = true; });

await new Promise(function(resolve) {
recorder.onstop = function() {
_flyBlob = new Blob(chunks, { type: blobType });
resolve();
};
recorder.stop();
});

// Fix WebM duration metadata so Runway can parse it (MP4 is fine as-is)
if (blobType.startsWith('video/webm')) {
_flyBlob = await fixWebmDuration(_flyBlob, duration * 1000);
}

var videoEl = document.getElementById('fly-video');
videoEl.src = URL.createObjectURL(_flyBlob);
videoEl.style.display = 'block';
progEl.textContent = 'Recorded ' + duration + 's flythrough (' + f + ' frames)';
offR.dispose();
btn.disabled = false; btn.textContent = 'Record Flythrough';
toast('Flythrough recorded');
}

function downloadFlythrough() {
if (!_flyBlob) { toast('Record a flythrough first'); return; }
var a = document.createElement('a'); a.href = URL.createObjectURL(_flyBlob);
var ext = (_flyBlob.type && _flyBlob.type.indexOf('mp4') !== -1) ? 'mp4' : 'webm';
a.download = 'flythrough.' + ext; a.click();
}

// ---- Download helpers ----
function downloadVideoUrl(url, filename) {
  var a = document.createElement('a');
  // If it's a blob URL we can download directly; for remote URLs fetch first
  if (url.startsWith('blob:')) {
    a.href = url; a.download = filename; a.click();
  } else {
    proxiedFetch(url).then(function(r) { return r.blob(); }).then(function(b) {
      var blobUrl = URL.createObjectURL(b);
      a.href = blobUrl; a.download = filename; a.click();
      setTimeout(function() { URL.revokeObjectURL(blobUrl); }, 1000);
    });
  }
}

function makeDownloadBtn(url, label, filename) {
  var btn = document.createElement('button');
  btn.className = 'btn';
  btn.textContent = label;
  btn.style.cssText = 'font-size:10px;padding:3px 8px;margin-top:2px';
  btn.onclick = function() { downloadVideoUrl(url, filename); };
  return btn;
}

// ---- Aleph model helpers ----
function onRunwayModelChange() {
  var model = document.getElementById('runway-model').value;
  var durSel = document.getElementById('runway-duration');
  var opt5 = document.getElementById('dur-opt-5');
  var opt10 = document.getElementById('dur-opt-10');
  if (model === 'gen4_aleph') {
    durSel.value = '5';
    durSel.disabled = true;
    opt5.textContent = '5 seconds (required for Aleph)';
    opt10.textContent = '10 seconds';
  } else {
    durSel.disabled = false;
    opt5.textContent = '5 seconds';
    opt10.textContent = '10 seconds (recommended)';
  }
}

function onProviderChange() {
  var provider = document.getElementById('stylize-provider').value;
  var modelSel = document.getElementById('runway-model');
  var btn = document.getElementById('runway-btn');
  var durRow = document.getElementById('stylize-duration-row');
  var decResRow = document.getElementById('decart-resolution-row');
  var descEl = document.getElementById('stylize-desc');
  var rwKeyRow = document.getElementById('apikey-runway-row');
  var dcKeyRow = document.getElementById('apikey-decart-row');

  if (provider === 'decart') {
    modelSel.innerHTML = '<option value="lucy-pro-v2v" selected>Lucy Pro V2V (video-to-video)</option>'
      + '<option value="lucy-pro-i2v">Lucy Pro I2V (image-to-video)</option>'
      + '<option value="lucy-dev-i2v">Lucy Dev I2V (fast/cheap)</option>'
      + '<option value="lucy-pro-t2v">Lucy Pro T2V (text-only)</option>';
    btn.textContent = 'Stylize with Decart';
    durRow.style.display = 'none';
    decResRow.style.display = '';
    rwKeyRow.style.display = 'none';
    dcKeyRow.style.display = '';
    descEl.innerHTML = 'Stylizes the flythrough using <span style="color:var(--accent2)">Decart Lucy</span>. <strong>V2V</strong> sends the flythrough video for style transfer. <strong>I2V</strong> animates keyframe images. <strong>T2V</strong> generates from the text prompt only. Output is ~5s per segment.';
  } else {
    modelSel.innerHTML = '<option value="gen4_turbo" selected>Gen-4 Turbo</option>'
      + '<option value="gen4_aleph">Gen-4 Aleph (video-to-video)</option>'
      + '<option value="gen3a_turbo">Gen-3 Alpha Turbo</option>';
    btn.textContent = 'Stylize with Runway';
    durRow.style.display = '';
    decResRow.style.display = 'none';
    rwKeyRow.style.display = '';
    dcKeyRow.style.display = 'none';
    descEl.innerHTML = 'Stylizes the flythrough using <span style="color:var(--accent2)">Runway</span>. Gen-4 Turbo/Gen-3 use image-to-video with keyframes per segment. <strong>Aleph</strong> uses video-to-video &mdash; sends actual flythrough chunks preserving camera motion (max 5s/segment). Longer tracks are auto-chunked and concatenated.';
    onRunwayModelChange();
  }
}

function onModelChange() {
  var provider = document.getElementById('stylize-provider').value;
  if (provider === 'runway') onRunwayModelChange();
}

function runStylize() {
  var provider = document.getElementById('stylize-provider').value;
  if (provider === 'decart') return runDecartStylize();
  return runRunwayStylize();
}

// ---- Decart pending state persistence ----
function saveDecartPending(jobId, apiKey) {
  localStorage.setItem('decart_pending', JSON.stringify({ jobId: jobId, apiKey: apiKey, time: Date.now() }));
}
function clearDecartPending() {
  localStorage.removeItem('decart_pending');
}
function showDecartPending() {
  var raw = localStorage.getItem('decart_pending'); if (!raw) return;
  try { var p = JSON.parse(raw); } catch(e) { return; }
  var age = Math.round((Date.now() - p.time) / 60000);
  if (age > 15) { clearDecartPending(); return; }
  var el = document.getElementById('runway-pending'); if (!el) return;
  document.getElementById('pending-title').textContent = 'Pending Decart generation found';
  document.getElementById('runway-pending-info').textContent = 'Job: ' + p.jobId.substring(0, 16) + '... (' + age + ' min ago)';
  el.style.display = 'block';
}

function checkPendingOperation() {
  var rwRaw = localStorage.getItem('runway_pending');
  var dcRaw = localStorage.getItem('decart_pending');
  if (dcRaw) return checkDecartOperation();
  if (rwRaw) return checkRunwayOperation();
  toast('No pending task');
}
function clearAllPending() {
  clearRunwayPending();
  clearDecartPending();
}

async function checkDecartOperation() {
  var raw = localStorage.getItem('decart_pending'); if (!raw) { toast('No pending Decart task'); return; }
  try { var p = JSON.parse(raw); } catch(e) { toast('Invalid pending data'); clearDecartPending(); return; }
  var progEl = document.getElementById('runway-progress');
  var pendEl = document.getElementById('runway-pending');
  progEl.style.display = 'block';
  progEl.textContent = 'Checking Decart job status...';
  pendEl.style.display = 'none';
  var apiKey = p.apiKey || document.getElementById('decart-apikey').value.trim();
  if (!apiKey) { toast('Enter your Decart API key first'); pendEl.style.display = 'block'; return; }
  try {
    var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + p.jobId, {
      headers: { 'X-API-KEY': apiKey }
    });
    if (!res.ok) throw new Error('Poll failed: ' + res.status);
    var data = await res.json();
    if (data.status === 'completed') {
      clearDecartPending();
      var vidUrl = await downloadDecartJob(p.jobId, apiKey);
      _runwayVideoUrl = vidUrl;
      var videoEl = document.getElementById('runway-video');
      videoEl.src = vidUrl; videoEl.style.display = 'block';
      var dlBar = document.getElementById('runway-download-bar');
      dlBar.style.display = 'flex'; dlBar.innerHTML = '';
      dlBar.appendChild(makeDownloadBtn(vidUrl, 'Download video', 'decart-stylized.mp4'));
      progEl.textContent = 'Decart stylization complete!';
      toast('Decart video ready');
    } else if (data.status === 'failed') {
      clearDecartPending();
      throw new Error('Decart job failed');
    } else {
      progEl.textContent = 'Still generating — resuming poll...';
      var vidUrl = await pollDecartJob(p.jobId, apiKey, progEl, '');
      _runwayVideoUrl = vidUrl;
      var videoEl = document.getElementById('runway-video');
      videoEl.src = vidUrl; videoEl.style.display = 'block';
      var dlBar = document.getElementById('runway-download-bar');
      dlBar.style.display = 'flex'; dlBar.innerHTML = '';
      dlBar.appendChild(makeDownloadBtn(vidUrl, 'Download video', 'decart-stylized.mp4'));
      progEl.textContent = 'Decart stylization complete!';
      toast('Decart video ready');
    }
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('Decart error: ' + err.message);
    console.error('Decart check error:', err);
  }
}

async function pollDecartJob(jobId, apiKey, progEl, prefix) {
  prefix = prefix || '';
  saveDecartPending(jobId, apiKey);
  var startTime = Date.now();
  var maxMs = 10 * 60 * 1000;
  while (Date.now() - startTime < maxMs) {
    await pollSleep(5000);
    var elapsed = Math.round((Date.now() - startTime) / 1000);
    progEl.textContent = prefix + 'Generating styled video... (' + elapsed + 's)';
    try {
      var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + jobId, {
        headers: { 'X-API-KEY': apiKey }
      });
      if (!res.ok) continue;
      var data = await res.json();
      if (data.status === 'completed') {
        clearDecartPending();
        return await downloadDecartJob(jobId, apiKey);
      }
      if (data.status === 'failed') { clearDecartPending(); throw new Error('Decart job failed' + (data.error ? ': ' + data.error : '')); }
      progEl.textContent = prefix + 'Decart: ' + data.status + ' (' + elapsed + 's)';
    } catch (e) {
      if (e.message.includes('Decart job failed')) throw e;
    }
  }
  throw new Error('Decart timed out (10 min)');
}

async function downloadDecartJob(jobId, apiKey) {
  var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + jobId + '/content', {
    headers: { 'X-API-KEY': apiKey }
  });
  if (!res.ok) throw new Error('Decart download failed: ' + res.status);
  var blob = await res.blob();
  return URL.createObjectURL(blob);
}

async function runDecartStylize() {
  var apiKey = document.getElementById('decart-apikey').value.trim();
  if (!apiKey) { toast('Enter a Decart API key'); return; }
  var prompt = document.getElementById('runway-prompt').value.trim();
  var model = document.getElementById('runway-model').value;
  var resolution = document.getElementById('decart-resolution').value;
  var isV2V = (model === 'lucy-pro-v2v');
  var isI2V = (model === 'lucy-pro-i2v' || model === 'lucy-dev-i2v');
  var isT2V = (model === 'lucy-pro-t2v');

  // Validation
  if (isV2V && !_flyBlob) { toast('Record a flythrough first'); return; }
  if (isI2V && (!_flyFrames.length || _flyFrames.length < 2)) { toast('Record a flythrough first'); return; }
  if (!prompt && isT2V) { toast('Enter a style prompt for text-to-video'); return; }

  var btn = document.getElementById('runway-btn');
  var progEl = document.getElementById('runway-progress');
  var segEl = document.getElementById('runway-segments');
  var dlBar = document.getElementById('runway-download-bar');
  btn.disabled = true; btn.textContent = 'Stylizing...';
  progEl.style.display = 'block';
  segEl.style.display = 'none'; segEl.innerHTML = '';
  dlBar.style.display = 'none'; dlBar.innerHTML = '';

  try {
    var segmentUrls = [];

    if (isT2V) {
      // ---- TEXT-TO-VIDEO: single generation, no input media ----
      progEl.textContent = 'Submitting to Decart (' + model + ')...';
      var form = new FormData();
      form.append('prompt', prompt);
      form.append('resolution', resolution);
      var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + model, {
        method: 'POST',
        headers: { 'X-API-KEY': apiKey },
        body: form
      });
      if (!res.ok) { var errBody = await res.text(); throw new Error('Decart (' + res.status + '): ' + errBody); }
      var jobData = await res.json();
      var vidUrl = await pollDecartJob(jobData.job_id, apiKey, progEl, '');
      segmentUrls.push(vidUrl);

    } else if (isV2V) {
      // ---- VIDEO-TO-VIDEO: send flythrough chunks ----
      // Decart V2V output is ~5s, so chunk the flythrough accordingly
      var segDuration = 5;
      var flyDur = _flyFrames.length ? _flyFrames[_flyFrames.length - 1].time : segDuration;
      var videoChunks;
      if (flyDur <= segDuration + 0.5) {
        videoChunks = [_flyBlob];
      } else {
        progEl.textContent = 'Splitting flythrough into ~5s chunks...';
        var rawChunks = await splitVideoIntoChunks(_flyBlob, segDuration);
        videoChunks = rawChunks.map(function(c) { return c.blob; });
      }
      var numChunks = videoChunks.length;

      for (var ci = 0; ci < numChunks; ci++) {
        var segLabel = numChunks > 1 ? 'Chunk ' + (ci + 1) + '/' + numChunks + ': ' : '';
        progEl.textContent = segLabel + 'Submitting to Decart V2V...';

        var form = new FormData();
        form.append('prompt', prompt);
        form.append('data', videoChunks[ci], 'flythrough.mp4');
        var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + model, {
          method: 'POST',
          headers: { 'X-API-KEY': apiKey },
          body: form
        });
        if (!res.ok) { var errBody = await res.text(); throw new Error('Decart V2V (' + res.status + '): ' + errBody); }
        var jobData = await res.json();
        var vidUrl = await pollDecartJob(jobData.job_id, apiKey, progEl, segLabel);
        segmentUrls.push(vidUrl);

        if (numChunks > 1) {
          segEl.style.display = 'block';
          var segVid = document.createElement('video');
          segVid.src = vidUrl; segVid.controls = true;
          segVid.style.cssText = 'width:100%;border-radius:4px;margin-bottom:4px;border:1px solid var(--border);background:#000';
          var segTitle = document.createElement('div');
          segTitle.textContent = 'Chunk ' + (ci + 1);
          segTitle.style.cssText = 'font-size:10px;color:var(--text-dim);margin-bottom:2px';
          segEl.appendChild(segTitle); segEl.appendChild(segVid);
          segEl.appendChild(makeDownloadBtn(vidUrl, 'Download chunk ' + (ci + 1), 'decart-chunk-' + (ci + 1) + '.mp4'));
        }
      }

    } else if (isI2V) {
      // ---- IMAGE-TO-VIDEO: animate keyframe images ----
      // Each I2V output is ~5s, so we create segments from keyframes
      var segDuration = 5;
      var totalDuration = _flyFrames[_flyFrames.length - 1].time;
      var numSegments = Math.max(1, Math.ceil(totalDuration / segDuration));
      var segments = [];
      for (var s = 0; s < numSegments; s++) {
        var startTime = s * segDuration;
        var kf = _flyFrames.reduce(function(best, f) {
          return Math.abs(f.time - startTime) < Math.abs(best.time - startTime) ? f : best;
        });
        segments.push(kf);
      }

      for (var si = 0; si < segments.length; si++) {
        var segLabel = segments.length > 1 ? 'Segment ' + (si + 1) + '/' + segments.length + ': ' : '';
        progEl.textContent = segLabel + 'Submitting to Decart I2V...';

        // Convert keyframe data URL to blob for multipart upload
        var kfDataUrl = segments[si].dataUrl;
        var kfBlob = await (await fetch(kfDataUrl)).blob();

        var form = new FormData();
        form.append('prompt', prompt);
        form.append('data', kfBlob, 'keyframe.jpg');
        form.append('resolution', resolution);
        var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + model, {
          method: 'POST',
          headers: { 'X-API-KEY': apiKey },
          body: form
        });
        if (!res.ok) { var errBody = await res.text(); throw new Error('Decart I2V (' + res.status + '): ' + errBody); }
        var jobData = await res.json();
        var vidUrl = await pollDecartJob(jobData.job_id, apiKey, progEl, segLabel);
        segmentUrls.push(vidUrl);

        if (segments.length > 1) {
          segEl.style.display = 'block';
          var segVid = document.createElement('video');
          segVid.src = vidUrl; segVid.controls = true;
          segVid.style.cssText = 'width:100%;border-radius:4px;margin-bottom:4px;border:1px solid var(--border);background:#000';
          var segTitle = document.createElement('div');
          segTitle.textContent = 'Segment ' + (si + 1);
          segTitle.style.cssText = 'font-size:10px;color:var(--text-dim);margin-bottom:2px';
          segEl.appendChild(segTitle); segEl.appendChild(segVid);
          segEl.appendChild(makeDownloadBtn(vidUrl, 'Download segment ' + (si + 1), 'decart-segment-' + (si + 1) + '.mp4'));
        }
      }
    }

    // Store segment URLs and display result
    _runwaySegmentUrls = segmentUrls;
    var numSegments = segmentUrls.length;

    if (numSegments === 1) {
      _runwayVideoUrl = segmentUrls[0];
      var videoEl = document.getElementById('runway-video');
      videoEl.src = _runwayVideoUrl;
      videoEl.style.display = 'block';
    } else {
      progEl.textContent = 'Downloading and concatenating ' + numSegments + ' segments...';
      _runwayVideoUrl = await concatenateSegments(segmentUrls, progEl);
      var videoEl = document.getElementById('runway-video');
      videoEl.src = _runwayVideoUrl;
      videoEl.style.display = 'block';
    }

    // Show download bar
    dlBar.style.display = 'flex'; dlBar.innerHTML = '';
    dlBar.appendChild(makeDownloadBtn(_runwayVideoUrl, numSegments > 1 ? 'Download full video' : 'Download video', 'decart-stylized.mp4'));
    if (numSegments > 1) {
      for (var di = 0; di < segmentUrls.length; di++) {
        dlBar.appendChild(makeDownloadBtn(segmentUrls[di], 'Seg ' + (di + 1), 'decart-part-' + (di + 1) + '.mp4'));
      }
    }

    progEl.textContent = 'Decart stylization complete!' + (numSegments > 1 ? ' (' + numSegments + ' segments joined)' : '');
    toast('Decart video ready');
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('Decart error: ' + err.message);
    console.error('Decart error:', err);
  } finally {
    btn.disabled = false; btn.textContent = 'Stylize with Decart';
  }
}

function blobToDataUrl(blob) {
  return new Promise(function(resolve, reject) {
    var reader = new FileReader();
    reader.onload = function() { resolve(reader.result); };
    reader.onerror = function() { reject(new Error('Failed to read blob')); };
    reader.readAsDataURL(blob);
  });
}

// Fix WebM duration metadata. MediaRecorder produces WebM blobs with
// missing or zero duration, which causes Runway's API to reject them.
// Patches the EBML Duration element (ID 0x4489) with the correct value.
async function fixWebmDuration(blob, durationMs) {
  var buffer = await blob.arrayBuffer();
  var bytes = new Uint8Array(buffer);

  // Search for the Duration EBML element: ID = 0x44 0x89
  for (var i = 0; i < bytes.length - 12; i++) {
    if (bytes[i] === 0x44 && bytes[i + 1] === 0x89) {
      var sizeTag = bytes[i + 2];
      if (sizeTag === 0x88) {
        // 8-byte float64 duration (most common)
        var dv = new DataView(buffer, i + 3, 8);
        dv.setFloat64(0, durationMs);
        return new Blob([buffer], { type: blob.type });
      } else if (sizeTag === 0x84) {
        // 4-byte float32 duration
        var dv = new DataView(buffer, i + 3, 4);
        dv.setFloat32(0, durationMs);
        return new Blob([buffer], { type: blob.type });
      }
    }
  }

  // Duration element not found — inject it into Segment Info.
  // Search for the Info element (ID 0x15 0x49 0xA9 0x66) and insert
  // a Duration element right after the Info header.
  for (var i = 0; i < bytes.length - 20; i++) {
    if (bytes[i] === 0x15 && bytes[i + 1] === 0x49 && bytes[i + 2] === 0xA9 && bytes[i + 3] === 0x66) {
      // Info element found. Read its VINT size to find where content starts.
      var sizeStart = i + 4;
      var infoByte = bytes[sizeStart];
      var vintLen = 0;
      for (var bit = 7; bit >= 0; bit--) {
        if (infoByte & (1 << bit)) { vintLen = 8 - bit; break; }
      }
      if (vintLen === 0) break;
      var insertPos = sizeStart + vintLen;

      // Build the Duration element: ID(2) + size(1) + float64(8) = 11 bytes
      var durEl = new Uint8Array(11);
      durEl[0] = 0x44; durEl[1] = 0x89; // Duration element ID
      durEl[2] = 0x88; // VINT size = 8 bytes
      var durView = new DataView(durEl.buffer, 3, 8);
      durView.setFloat64(0, durationMs);

      // We also need to increase the Info element's size by 11.
      // Read current size value
      var sizeMask = infoByte & ~(1 << (8 - vintLen));
      var sizeVal = sizeMask;
      for (var j = 1; j < vintLen; j++) {
        sizeVal = (sizeVal * 256) + bytes[sizeStart + j];
      }
      sizeVal += 11;

      // Write updated size back (same VINT length)
      var newSizeBytes = new Uint8Array(vintLen);
      var tmp = sizeVal;
      for (var j = vintLen - 1; j >= 0; j--) {
        newSizeBytes[j] = tmp & 0xFF;
        tmp = Math.floor(tmp / 256);
      }
      newSizeBytes[0] |= (1 << (8 - vintLen)); // set VINT marker bit

      // Assemble: before insert | duration element | after insert
      var before = bytes.slice(0, insertPos);
      var after = bytes.slice(insertPos);

      // Patch the size bytes in 'before'
      for (var j = 0; j < vintLen; j++) {
        before[sizeStart + j] = newSizeBytes[j];
      }

      var result = new Uint8Array(before.length + durEl.length + after.length);
      result.set(before, 0);
      result.set(durEl, before.length);
      result.set(after, before.length + durEl.length);
      return new Blob([result], { type: blob.type });
    }
  }

  console.warn('fixWebmDuration: could not patch duration metadata');
  return blob;
}

// Prefer MP4 for MediaRecorder (reliable duration metadata).
// Fall back to WebM (needs EBML duration patching for Runway).
function bestRecorderMime() {
  if (typeof MediaRecorder !== 'undefined') {
    if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')) return 'video/mp4;codecs=avc1';
    if (MediaRecorder.isTypeSupported('video/mp4')) return 'video/mp4';
  }
  if (typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) return 'video/webm;codecs=vp9';
  return 'video/webm';
}

// Upload a video blob to Runway via their ephemeral uploads endpoint.
// Returns a runway:// URI that can be used as videoUri.
// This avoids WebM duration metadata issues since Runway's server-side
// tools (ffprobe) can determine duration from the actual video frames.
async function uploadToRunway(blob, headers, progEl, prefix) {
  prefix = prefix || '';
  var ext = (blob.type && blob.type.indexOf('mp4') !== -1) ? 'mp4' : 'webm';

  progEl.textContent = prefix + 'Requesting Runway upload URL...';
  var initRes = await proxiedFetch('https://api.dev.runwayml.com/v1/uploads', {
    method: 'POST', headers: headers,
    body: JSON.stringify({ filename: 'flythrough.' + ext, type: 'ephemeral' })
  });
  if (!initRes.ok) {
    var errText = await initRes.text();
    throw new Error('Runway upload init failed (' + initRes.status + '): ' + errText);
  }
  var initData = await initRes.json();

  progEl.textContent = prefix + 'Uploading video to Runway...';
  var formData = new FormData();
  var fields = initData.fields || {};
  for (var key in fields) {
    if (fields.hasOwnProperty(key)) formData.append(key, fields[key]);
  }
  formData.append('file', blob, 'flythrough.' + ext);

  // Upload goes directly to the presigned URL (not proxied)
  var upRes = await fetch(initData.uploadUrl, { method: 'POST', body: formData });
  if (!upRes.ok && upRes.status !== 204) {
    throw new Error('Runway file upload failed (' + upRes.status + ')');
  }

  return initData.runwayUri;
}

// Split a video blob into chunks of segDur seconds each.
// Returns an array of { blob, duration } objects.
async function splitVideoIntoChunks(videoBlob, segDur) {
  var video = document.createElement('video');
  video.muted = true; video.playsInline = true;
  video.preload = 'auto';
  video.src = URL.createObjectURL(videoBlob);

  // Wait for metadata so we know the full duration
  await new Promise(function(res, rej) {
    video.onloadedmetadata = function() { res(); };
    video.onerror = function() { rej(new Error('Cannot load video for chunking')); };
  });

  var totalDur = video.duration;
  if (!isFinite(totalDur) || totalDur <= 0) {
    // WebM duration can be unknown; fall back to flythrough keyframe time
    totalDur = _flyFrames.length ? _flyFrames[_flyFrames.length - 1].time : segDur;
  }
  var numChunks = Math.max(1, Math.ceil(totalDur / segDur));
  var chunks = [];

  var canvas = document.createElement('canvas');
  canvas.width = 1280; canvas.height = 720;
  var ctx = canvas.getContext('2d');

  for (var i = 0; i < numChunks; i++) {
    var startT = i * segDur;
    var endT = Math.min((i + 1) * segDur, totalDur);
    var chunkDur = endT - startT;

    // Seek to start of this chunk
    await new Promise(function(res) {
      video.currentTime = startT;
      video.onseeked = function() { res(); };
    });

    // Record this chunk via canvas + MediaRecorder
    var cStream = canvas.captureStream(30);
    var mimeType = bestRecorderMime();
    var blobType = mimeType.split(';')[0]; // clean MIME for blob/data URI
    var rec = new MediaRecorder(cStream, { mimeType: mimeType, videoBitsPerSecond: 8000000 });
    var parts = [];
    rec.ondataavailable = function(e) { if (e.data.size) parts.push(e.data); };

    var chunkBlob = await new Promise(function(resolve, reject) {
      rec.start();
      video.play();

      function drawLoop() {
        if (video.paused || video.ended || video.currentTime >= endT) {
          video.pause();
          rec.onstop = function() {
            resolve(new Blob(parts, { type: blobType }));
          };
          rec.stop();
          return;
        }
        ctx.drawImage(video, 0, 0, 1280, 720);
        requestAnimationFrame(drawLoop);
      }

      // Also stop on timeupdate to catch endT precisely
      video.ontimeupdate = function() {
        if (video.currentTime >= endT) {
          video.pause();
        }
      };
      drawLoop();
    });

    // Fix WebM duration metadata (MP4 has reliable duration already)
    var fixedBlob = blobType.startsWith('video/webm')
      ? await fixWebmDuration(chunkBlob, chunkDur * 1000)
      : chunkBlob;
    chunks.push({ blob: fixedBlob, duration: Math.max(2, Math.round(chunkDur)) });
  }

  URL.revokeObjectURL(video.src);
  return chunks;
}

async function runRunwayStylize() {
var apiKey = document.getElementById('runway-apikey').value.trim();
if (!apiKey) { toast('Enter a Runway API key'); return; }
var prompt = document.getElementById('runway-prompt').value.trim();
var model = document.getElementById('runway-model').value;
var isAleph = (model === 'gen4_aleph');
var segDuration = parseInt(document.getElementById('runway-duration').value);
if (isAleph) segDuration = Math.min(segDuration, 5); // Aleph hard cap

// Validation: Aleph needs the video blob, image-to-video needs keyframes
if (isAleph) {
  if (!_flyBlob) { toast('Record a flythrough first'); return; }
} else {
  if (!_flyFrames.length || _flyFrames.length < 2) { toast('Record a flythrough first'); return; }
}

var btn = document.getElementById('runway-btn');
var progEl = document.getElementById('runway-progress');
var segEl = document.getElementById('runway-segments');
var dlBar = document.getElementById('runway-download-bar');
btn.disabled = true; btn.textContent = 'Stylizing...';
progEl.style.display = 'block';
segEl.style.display = 'none'; segEl.innerHTML = '';
dlBar.style.display = 'none'; dlBar.innerHTML = '';

var headers = {
'Content-Type': 'application/json',
'Authorization': 'Bearer ' + apiKey,
'X-Runway-Version': '2024-11-06'
};

try {
var segmentUrls = [];
var numSegments;

if (isAleph) {
  // ---- ALEPH: video-to-video path ----
  // Prepend motion-preservation instruction so Aleph follows the source
  // camera path exactly instead of hallucinating new curves/turns
  var alephPrompt = 'Preserve the exact camera motion, direction, and trajectory from the source video. Do not add turns, curves, or direction changes that are not in the original. ' + prompt;

  // Check if flythrough fits in a single chunk — skip re-encoding
  var flyDur = _flyFrames.length ? _flyFrames[_flyFrames.length - 1].time : segDuration;
  var videoChunks;
  if (flyDur <= segDuration + 0.5) {
    // Single chunk: use the already-duration-fixed _flyBlob directly
    videoChunks = [{ blob: _flyBlob, duration: Math.max(2, Math.round(flyDur)) }];
  } else {
    progEl.textContent = 'Splitting flythrough into ' + segDuration + 's chunks...';
    videoChunks = await splitVideoIntoChunks(_flyBlob, segDuration);
  }
  numSegments = videoChunks.length;
  progEl.textContent = numSegments === 1
    ? 'Submitting to Runway Aleph...'
    : 'Stylizing ' + numSegments + ' chunks with Aleph (video-to-video)...';

  for (var ci = 0; ci < videoChunks.length; ci++) {
    var chunk = videoChunks[ci];
    var segLabel = numSegments > 1 ? 'Chunk ' + (ci + 1) + '/' + numSegments + ': ' : '';

    // Upload video to Runway (avoids WebM duration metadata issues with data URIs)
    var runwayUri = await uploadToRunway(chunk.blob, headers, progEl, segLabel);

    progEl.textContent = segLabel + 'Submitting to Runway Aleph...';
    var res = await proxiedFetch('https://api.dev.runwayml.com/v1/video_to_video', {
      method: 'POST', headers: headers,
      body: JSON.stringify({
        model: 'gen4_aleph',
        videoUri: runwayUri,
        promptText: alephPrompt,
        ratio: '1280:720',
        duration: Math.max(2, chunk.duration || segDuration)
      })
    });
    if (!res.ok) { var errBody = await res.text(); throw new Error('Runway Aleph (' + res.status + '): ' + errBody); }
    var taskData = await res.json();
    var taskId = taskData.id;

    var segUrl = await pollRunwayTask(taskId, apiKey, progEl, segLabel);
    segmentUrls.push(segUrl);

    if (numSegments > 1) {
      segEl.style.display = 'block';
      var segVid = document.createElement('video');
      segVid.src = segUrl; segVid.controls = true;
      segVid.style.cssText = 'width:100%;border-radius:4px;margin-bottom:4px;border:1px solid var(--border);background:#000';
      var segTitle = document.createElement('div');
      segTitle.textContent = 'Chunk ' + (ci + 1);
      segTitle.style.cssText = 'font-size:10px;color:var(--text-dim);margin-bottom:2px';
      segEl.appendChild(segTitle); segEl.appendChild(segVid);
      segEl.appendChild(makeDownloadBtn(segUrl, 'Download chunk ' + (ci + 1), 'runway-chunk-' + (ci + 1) + '.mp4'));
    }
  }
} else {
  // ---- IMAGE-TO-VIDEO path (Gen-4 Turbo / Gen-3 Alpha Turbo) ----
  var totalDuration = _flyFrames[_flyFrames.length - 1].time;
  numSegments = Math.max(1, Math.ceil(totalDuration / segDuration));

  // Build segment boundaries using captured keyframes
  var segments = [];
  for (var s = 0; s < numSegments; s++) {
    var startTime = s * segDuration;
    var endTime = Math.min((s + 1) * segDuration, totalDuration);
    var firstKF = _flyFrames.reduce(function(best, f) {
      return Math.abs(f.time - startTime) < Math.abs(best.time - startTime) ? f : best;
    });
    var lastKF = _flyFrames.reduce(function(best, f) {
      return Math.abs(f.time - endTime) < Math.abs(best.time - endTime) ? f : best;
    });
    if (firstKF === lastKF && _flyFrames.length > 1) {
      var idx = _flyFrames.indexOf(firstKF);
      lastKF = _flyFrames[Math.min(idx + 1, _flyFrames.length - 1)];
    }
    segments.push({ index: s, firstKF: firstKF, lastKF: lastKF, duration: segDuration });
  }

  progEl.textContent = numSegments === 1
    ? 'Submitting to Runway (' + model + ')...'
    : 'Stylizing ' + numSegments + ' segments with ' + model + '...';

  for (var si = 0; si < segments.length; si++) {
    var seg = segments[si];
    var segLabel = numSegments > 1 ? 'Segment ' + (si + 1) + '/' + numSegments + ': ' : '';
    var promptImage = seg.firstKF.dataUrl;

    progEl.textContent = segLabel + 'Submitting to Runway...';
    var res = await proxiedFetch('https://api.dev.runwayml.com/v1/image_to_video', {
      method: 'POST', headers: headers,
      body: JSON.stringify({
        model: model,
        promptImage: promptImage,
        promptText: prompt,
        ratio: '1280:720',
        duration: seg.duration
      })
    });
    if (!res.ok) { var errBody = await res.text(); throw new Error('Runway (' + res.status + '): ' + errBody); }
    var taskData = await res.json();
    var taskId = taskData.id;

    var segUrl = await pollRunwayTask(taskId, apiKey, progEl, segLabel);
    segmentUrls.push(segUrl);

    if (numSegments > 1) {
      segEl.style.display = 'block';
      var segVid = document.createElement('video');
      segVid.src = segUrl; segVid.controls = true;
      segVid.style.cssText = 'width:100%;border-radius:4px;margin-bottom:4px;border:1px solid var(--border);background:#000';
      var segTitle = document.createElement('div');
      segTitle.textContent = 'Segment ' + (si + 1);
      segTitle.style.cssText = 'font-size:10px;color:var(--text-dim);margin-bottom:2px';
      segEl.appendChild(segTitle); segEl.appendChild(segVid);
      segEl.appendChild(makeDownloadBtn(segUrl, 'Download segment ' + (si + 1), 'runway-segment-' + (si + 1) + '.mp4'));
    }
  }
}

// Store all segment URLs for Marble pipeline
_runwaySegmentUrls = segmentUrls;

if (numSegments === 1) {
  _runwayVideoUrl = segmentUrls[0];
  var videoEl = document.getElementById('runway-video');
  videoEl.src = _runwayVideoUrl;
  videoEl.style.display = 'block';
} else {
  // Concatenate segments client-side
  progEl.textContent = 'Downloading and concatenating ' + numSegments + ' segments...';
  _runwayVideoUrl = await concatenateSegments(segmentUrls, progEl);
  var videoEl = document.getElementById('runway-video');
  videoEl.src = _runwayVideoUrl;
  videoEl.style.display = 'block';
}

// Show download bar
dlBar.style.display = 'flex';
dlBar.innerHTML = '';
dlBar.appendChild(makeDownloadBtn(_runwayVideoUrl, numSegments > 1 ? 'Download full video' : 'Download video', 'runway-stylized.mp4'));
if (numSegments > 1) {
  for (var di = 0; di < segmentUrls.length; di++) {
    dlBar.appendChild(makeDownloadBtn(segmentUrls[di], (isAleph ? 'Chunk ' : 'Seg ') + (di + 1), 'runway-part-' + (di + 1) + '.mp4'));
  }
}

progEl.textContent = 'Runway stylization complete!' + (numSegments > 1 ? ' (' + numSegments + ' segments joined)' : '');
toast('Runway video ready');
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Runway error: ' + err.message);
console.error('Runway error:', err);
} finally {
btn.disabled = false; btn.textContent = 'Stylize with Runway';
}
}

var _runwaySegmentUrls = [];

async function concatenateSegments(urls, progEl) {
// Fetch all segment videos
var blobs = [];
for (var i = 0; i < urls.length; i++) {
  progEl.textContent = 'Downloading segment ' + (i + 1) + '/' + urls.length + '...';
  var res = await proxiedFetch(urls[i]);
  blobs.push(await res.blob());
}

// Concatenate via hidden video → canvas → MediaRecorder
progEl.textContent = 'Joining segments...';
var canvas = document.createElement('canvas');
canvas.width = 1280; canvas.height = 720;
var ctx = canvas.getContext('2d');
var stream = canvas.captureStream(30);
var mimeType = bestRecorderMime();
var blobType = mimeType.split(';')[0];
var recorder = new MediaRecorder(stream, { mimeType: mimeType, videoBitsPerSecond: 8000000 });
var recChunks = [];
recorder.ondataavailable = function(e) { if (e.data.size) recChunks.push(e.data); };
recorder.start();

var vid = document.createElement('video');
vid.muted = true; vid.playsInline = true;
var totalRecordedSec = 0;

for (var i = 0; i < blobs.length; i++) {
  progEl.textContent = 'Encoding segment ' + (i + 1) + '/' + blobs.length + '...';
  var blobUrl = URL.createObjectURL(blobs[i]);

  // Load video and wait for play() to actually start
  await new Promise(function(res, rej) {
    vid.src = blobUrl;
    vid.onloadeddata = function() {
      vid.play().then(res).catch(function(e) {
        // Autoplay may be blocked; try muted play
        vid.muted = true;
        vid.play().then(res).catch(rej);
      });
    };
    vid.onerror = function() { rej(new Error('Failed to load segment ' + (i + 1))); };
  });

  // Draw frames until this segment ends
  var segDur = vid.duration;
  await new Promise(function(res) {
    var done = false;
    function finish() {
      if (done) return;
      done = true;
      if (isFinite(segDur)) totalRecordedSec += segDur;
      res();
    }
    vid.onended = finish;
    // Safety timeout: if onended doesn't fire, stop after expected duration + buffer
    var safetyMs = (isFinite(segDur) ? segDur : 10) * 1000 + 2000;
    var safetyTimer = setTimeout(finish, safetyMs);
    function drawFrame() {
      if (done) { clearTimeout(safetyTimer); return; }
      if (vid.ended) { clearTimeout(safetyTimer); finish(); return; }
      ctx.drawImage(vid, 0, 0, 1280, 720);
      requestAnimationFrame(drawFrame);
    }
    drawFrame();
  });

  URL.revokeObjectURL(blobUrl);
}

// Stop recorder and build final blob with fixed duration
var finalBlobUrl = await new Promise(function(resolve) {
  recorder.onstop = async function() {
    var rawBlob = new Blob(recChunks, { type: blobType });
    var fixedBlob = blobType.startsWith('video/webm')
      ? await fixWebmDuration(rawBlob, totalRecordedSec * 1000)
      : rawBlob;
    resolve(URL.createObjectURL(fixedBlob));
  };
  recorder.stop();
});
return finalBlobUrl;
}

async function pollRunwayTask(taskId, apiKey, progEl, prefix) {
prefix = prefix || '';
var headers = { 'Authorization': 'Bearer ' + apiKey, 'X-Runway-Version': '2024-11-06' };
saveRunwayPending(taskId, apiKey);
var startTime = Date.now();
var maxMs = 10 * 60 * 1000; // 10 min wall-clock timeout
while (Date.now() - startTime < maxMs) {
await pollSleep(5000);
var elapsed = Math.round((Date.now() - startTime) / 1000);
progEl.textContent = prefix + 'Generating styled video... (' + elapsed + 's)';
try {
var res = await proxiedFetch('https://api.dev.runwayml.com/v1/tasks/' + taskId, { headers: headers });
if (!res.ok) continue;
var data = await res.json();
if (data.status === 'SUCCEEDED') { clearRunwayPending(); return data.output[0]; }
if (data.status === 'FAILED') { clearRunwayPending(); throw new Error('Runway failed: ' + (data.failureCode || 'unknown')); }
if (data.status === 'CANCELED') { clearRunwayPending(); throw new Error('Runway task canceled'); }
progEl.textContent = prefix + 'Runway: ' + data.status + ' (' + elapsed + 's)';
} catch (e) {
if (e.message.includes('Runway failed') || e.message.includes('canceled')) throw e;
}
}
throw new Error('Runway timed out (10 min)');
}

async function runMarbleFromVideo() {
var marbleKey = document.getElementById('marble-apikey').value.trim();
if (!marbleKey) { toast('Enter a Marble API key (panel 1)'); return; }
if (!_runwayVideoUrl) { toast('Run Runway stylization first (stage 2)'); return; }
var quality = document.getElementById('marble-quality').value;
var prompt = document.getElementById('marble-prompt').value.trim();
var btn = document.getElementById('marble-vid-btn');
var progEl = document.getElementById('marble-vid-progress');
btn.disabled = true; btn.textContent = 'Generating...';
progEl.style.display = 'block';

var headers = { 'Content-Type': 'application/json', 'WLT-Api-Key': marbleKey };

try {
// Download the Runway video and re-upload to Marble as a media asset
progEl.textContent = 'Downloading styled video...';
var vidRes = await proxiedFetch(_runwayVideoUrl);
if (!vidRes.ok) throw new Error('Video download failed: ' + vidRes.status);
var videoBlob = await vidRes.blob();

progEl.textContent = 'Uploading video to Marble...';
var upRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/media-assets:prepare_upload', {
method: 'POST', headers: headers,
body: JSON.stringify({ file_name: 'styled-flythrough.mp4', kind: 'video', extension: 'mp4' })
});
if (!upRes.ok) throw new Error('Marble upload setup failed: ' + upRes.status);
var upData = await upRes.json();
var mediaId = upData.media_asset.media_asset_id;
var upUrl = upData.upload_info.upload_url;
var upMethod = upData.upload_info.upload_method || 'PUT';
var upHeaders = upData.upload_info.required_headers || {};
await proxiedFetch(upUrl, { method: upMethod, headers: upHeaders, body: videoBlob });

progEl.textContent = 'Generating 3D world from video (1-5 min)...';
var genRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/worlds:generate', {
method: 'POST', headers: headers,
body: JSON.stringify({
display_name: 'Styled Track Environment',
model: 'Marble 0.1-plus',
world_prompt: {
type: 'video',
video_prompt: { source: 'media_asset', media_asset_id: mediaId },
text_prompt: prompt || ''
}
})
});
if (!genRes.ok) {
if (genRes.status === 401) throw new Error('Invalid Marble API key');
var errText = await genRes.text();
throw new Error('Marble generation failed (' + genRes.status + '): ' + errText);
}

var genData = await genRes.json();
var opId = genData.operation_id || genData.name;
var worldData = null;
if (genData.done && genData.response) { worldData = genData.response; }
else if (opId) {
saveMarblePending(opId, marbleKey, quality);
worldData = await pollMarbleOp(opId, marbleKey, quality, progEl);
} else { worldData = genData.world || genData; }

handleMarbleResult(worldData, quality);
progEl.textContent = 'Pipeline complete — 3D world loaded!';
toast('3D world reconstructed!');
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Error: ' + err.message);
console.error('Marble video error:', err);
} finally {
btn.disabled = false; btn.textContent = 'Reconstruct 3D World';
}
}

async function runFullPipeline() {
var btn = document.getElementById('pipeline-full-btn');
var progEl = document.getElementById('pipeline-progress');
btn.disabled = true; progEl.style.display = 'block';
try {
progEl.textContent = 'Stage 1/3: Recording flythrough...';
await recordFlythrough();
var provider = document.getElementById('stylize-provider').value;
progEl.textContent = 'Stage 2/3: ' + (provider === 'decart' ? 'Decart' : 'Runway') + ' stylization...';
await runStylize();
progEl.textContent = 'Stage 3/3: Marble 3D reconstruction...';
await runMarbleFromVideo();
progEl.textContent = 'Full pipeline complete!';
toast('Pipeline complete!');
} catch (err) {
progEl.textContent = 'Pipeline error: ' + err.message;
toast('Pipeline error: ' + err.message);
} finally { btn.disabled = false; }
}

async function loadSplatFromURL() {
var url = document.getElementById('splat-url').value.trim();
if (!url) { toast('Enter a splat URL'); return; }
var infoEl = document.getElementById('splat-info');
infoEl.textContent = 'Loading Spark.js...';
try {
await ensureSparkLoaded();
if (_splatMesh) { scene.remove(_splatMesh); if (_splatMesh.dispose) _splatMesh.dispose(); _splatMesh = null; }
infoEl.textContent = 'Loading splat from URL...';
var Spark = window.Spark;
_splatMesh = new Spark.SplatMesh({
url: url,
onLoad: function(mesh) {
var numSplats = mesh.numSplats || 'unknown';
infoEl.textContent = 'Loaded: ' + numSplats + ' splats';
toast('Splat loaded (' + numSplats + ' splats)');
syncSplatSlidersToMesh();
}
});
scene.add(_splatMesh);
} catch (err) {
infoEl.textContent = 'Error: ' + err.message;
toast('Failed to load splat: ' + err.message);
console.error(err);
}
}

function loadSplatFromFile() {
var fileInput = document.getElementById('splat-file-input');
fileInput.onchange = async function() {
if (!this.files[0]) return;
var file = this.files[0];
var infoEl = document.getElementById('splat-info');
infoEl.textContent = 'Loading Spark.js...';
try {
await ensureSparkLoaded();
if (_splatMesh) { scene.remove(_splatMesh); if (_splatMesh.dispose) _splatMesh.dispose(); _splatMesh = null; }
infoEl.textContent = 'Loading ' + file.name + '...';
var bytes = new Uint8Array(await file.arrayBuffer());
var Spark = window.Spark;
_splatMesh = new Spark.SplatMesh({
fileBytes: bytes,
onLoad: function(mesh) {
var numSplats = mesh.numSplats || 'unknown';
infoEl.textContent = 'Loaded: ' + file.name + ' (' + numSplats + ' splats, ' + (file.size/1e6).toFixed(1) + ' MB)';
toast('Splat loaded: ' + file.name);
syncSplatSlidersToMesh();
}
});
scene.add(_splatMesh);
} catch (err) {
infoEl.textContent = 'Error: ' + err.message;
toast('Failed: ' + err.message);
}
};
fileInput.click();
}

function removeSplat() {
if (_splatMesh) {
scene.remove(_splatMesh);
if (_splatMesh.dispose) _splatMesh.dispose();
_splatMesh = null;
document.getElementById('splat-info').textContent = 'Splat removed';
document.getElementById('splat-url').value = '';
toast('Splat removed');
}
}

function syncSplatSlidersToMesh() {
if (!_splatMesh) return;
if (trackData.length > 10) {
var cx = 0, cy = 0, cz = 0;
trackData.forEach(function(pt) { cx += pt[0][0]; cy += pt[0][1]; cz += pt[0][2]; });
cx /= trackData.length; cy /= trackData.length; cz /= trackData.length;
_splatMesh.position.set(cx, cy, cz);
}
var p = _splatMesh.position;
document.getElementById('s-splatpx').value = Math.round(p.x);
document.getElementById('v-splatpx').textContent = Math.round(p.x);
document.getElementById('s-splatpy').value = Math.round(p.y);
document.getElementById('v-splatpy').textContent = Math.round(p.y);
document.getElementById('s-splatpz').value = Math.round(p.z);
document.getElementById('v-splatpz').textContent = Math.round(p.z);
document.getElementById('s-splatrx').value = 0;
document.getElementById('v-splatrx').textContent = '0';
document.getElementById('s-splatry').value = 0;
document.getElementById('v-splatry').textContent = '0';
document.getElementById('s-splatscale').value = 1;
document.getElementById('v-splatscale').textContent = '1.0';
document.getElementById('s-splatopacity').value = 1;
document.getElementById('v-splatopacity').textContent = '1.0';
}

function applySplatSettings() {
if (!_splatMesh) return;
var opacity = parseFloat(document.getElementById('s-splatopacity').value);
var scale = parseFloat(document.getElementById('s-splatscale').value);
var px = parseFloat(document.getElementById('s-splatpx').value);
var py = parseFloat(document.getElementById('s-splatpy').value);
var pz = parseFloat(document.getElementById('s-splatpz').value);
var rx = parseFloat(document.getElementById('s-splatrx').value) * Math.PI / 180;
var ry = parseFloat(document.getElementById('s-splatry').value) * Math.PI / 180;
_splatMesh.opacity = opacity;
_splatMesh.scale.setScalar(scale);
_splatMesh.position.set(px, py, pz);
_splatMesh.rotation.set(rx, ry, 0);
}

function splatBackdropPreset() {
if (!_splatMesh) { toast('Load a splat first'); return; }
var minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
if (trackData.length > 10) {
trackData.forEach(function(p) {
minX=Math.min(minX,p[0][0]);maxX=Math.max(maxX,p[0][0]);
minY=Math.min(minY,p[0][1]);maxY=Math.max(maxY,p[0][1]);
minZ=Math.min(minZ,p[0][2]);maxZ=Math.max(maxZ,p[0][2]);
});
}
var cx = (minX+maxX)/2, cy = (minY+maxY)/2, cz = (minZ+maxZ)/2;
var sc = 30;
document.getElementById('s-splatscale').value = sc;
document.getElementById('v-splatscale').textContent = sc.toFixed(1);
document.getElementById('s-splatpx').value = Math.round(cx);
document.getElementById('v-splatpx').textContent = Math.round(cx);
document.getElementById('s-splatpy').value = Math.round(cy);
document.getElementById('v-splatpy').textContent = Math.round(cy);
document.getElementById('s-splatpz').value = Math.round(cz);
document.getElementById('v-splatpz').textContent = Math.round(cz);
document.getElementById('s-splatrx').value = 0;
document.getElementById('v-splatrx').textContent = '0';
document.getElementById('s-splatry').value = 0;
document.getElementById('v-splatry').textContent = '0';
applySplatSettings();
toast('Backdrop preset applied (scale 30x, centered on track)');
}

function splatResetTransform() {
if (!_splatMesh) { toast('Load a splat first'); return; }
document.getElementById('s-splatscale').value = 1;
document.getElementById('v-splatscale').textContent = '1.0';
document.getElementById('s-splatpx').value = 0;
document.getElementById('v-splatpx').textContent = '0';
document.getElementById('s-splatpy').value = 0;
document.getElementById('v-splatpy').textContent = '0';
document.getElementById('s-splatpz').value = 0;
document.getElementById('v-splatpz').textContent = '0';
document.getElementById('s-splatrx').value = 0;
document.getElementById('v-splatrx').textContent = '0';
document.getElementById('s-splatry').value = 0;
document.getElementById('v-splatry').textContent = '0';
document.getElementById('s-splatopacity').value = 1;
document.getElementById('v-splatopacity').textContent = '1.0';
applySplatSettings();
toast('Transform reset');
}

// ============================================================
// UI BINDING
// ============================================================
function bindUI(){
var sliders={'smooth-iter':'smooth-iter-val','smooth-str':'smooth-str-val','cp-count':'cp-count-val','spline-resolution':'spline-res-val','loop-blend':'loop-blend-val','loop-pts':'loop-pts-val','elev-offset':'elev-val','s-imgscale':'v-imgscale','s-imgpts':'v-imgpts','s-imgsmooth':'v-imgsmooth','s-splatopacity':'v-splatopacity','s-splatscale':'v-splatscale'};
Object.keys(sliders).forEach(function(a){var b=sliders[a];var sl=document.getElementById(a),vl=document.getElementById(b);if(sl&&vl)sl.addEventListener('input',function(){vl.textContent=sl.value})});
document.querySelectorAll('input[type="range"]').forEach(function(sl){
var vid='v-'+sl.id.substring(2);var vlbl=document.getElementById(vid);
if(vlbl)sl.addEventListener('input',function(){vlbl.textContent=sl.value});
});
['s-splatopacity','s-splatscale','s-splatpx','s-splatpy','s-splatpz','s-splatrx','s-splatry'].forEach(function(id){
var el = document.getElementById(id);
if (el) el.addEventListener('input', applySplatSettings);
});
// Training view sliders
['s-trainviews','s-trainres'].forEach(function(id){
var sl=document.getElementById(id);if(!sl)return;
var vlbl=document.getElementById('v-'+id.slice(2));
if(vlbl)sl.addEventListener('input',function(){vlbl.textContent=sl.value});
});
// Proxy URL persistence: ?proxy=<url> to set, ?proxy=clear to remove
var _proxyParam = new URLSearchParams(window.location.search).get('proxy');
if (_proxyParam === '' || _proxyParam === 'clear') { localStorage.removeItem('proxy_url'); _proxyUrl = ''; }
else if (_proxyParam) { var _pu = _proxyParam.replace(/\/+$/, ''); localStorage.setItem('proxy_url', _pu); _proxyUrl = _pu; }
else { _proxyUrl = localStorage.getItem('proxy_url') || ''; }
// API key persistence: load from localStorage, URL params override
var _apiKeyIds = ['runway-apikey', 'decart-apikey', 'marble-apikey'];
if (_proxyUrl) {
  _apiKeyIds.forEach(function(id) {
    var el = document.getElementById(id); if (!el) return;
    el.value = 'proxy-managed';
    el.disabled = true;
    el.style.opacity = '0.5';
    el.title = 'API key managed by proxy: ' + _proxyUrl;
  });
} else {
  _apiKeyIds.forEach(function(id) {
    var el = document.getElementById(id); if (!el) return;
    var saved = localStorage.getItem('apikey_' + id);
    if (saved && !el.value) el.value = saved;
    el.addEventListener('input', function() {
      var v = el.value.trim();
      if (v) localStorage.setItem('apikey_' + id, v);
      else localStorage.removeItem('apikey_' + id);
    });
  });
  // URL params override localStorage (Runway, Decart, Marble)
  var rkParam=new URLSearchParams(window.location.search).get('rk');
  if(rkParam){var rkEl=document.getElementById('runway-apikey');if(rkEl)rkEl.value=rkParam}
  var dkParam=new URLSearchParams(window.location.search).get('dk');
  if(dkParam){var dkEl=document.getElementById('decart-apikey');if(dkEl)dkEl.value=dkParam}
  var mkParam=new URLSearchParams(window.location.search).get('mk');
  if(mkParam){var mkEl=document.getElementById('marble-apikey');if(mkEl)mkEl.value=mkParam}
}
}

// ============================================================
// EXPORT TRAINING VIEWS for 3DGS
// ============================================================
async function exportTrainingViews(){
var numViews=parseInt(document.getElementById('s-trainviews').value);
var res=parseInt(document.getElementById('s-trainres').value);
var btn=document.getElementById('btn-export-views');
var prog=document.getElementById('export-views-progress');
btn.disabled=true;btn.textContent='Rendering...';prog.style.display='block';

// Compute scene bounding box from track + terrain
var bbox=new THREE.Box3();
if(trackRibbon)bbox.expandByObject(trackRibbon);
if(terrainMesh)bbox.expandByObject(terrainMesh);
if(tLine)bbox.expandByObject(tLine);
if(_splatMesh)bbox.expandByObject(_splatMesh);
if(bbox.isEmpty()){
trackData.forEach(function(p){bbox.expandByPoint(new THREE.Vector3(p[0][0],p[0][1],p[0][2]))});
}
var center=new THREE.Vector3();bbox.getCenter(center);
var size=new THREE.Vector3();bbox.getSize(size);
var radius=Math.max(size.x,size.y,size.z)*0.7;
if(radius<100)radius=500;

// Offscreen renderer
var offRndr=new THREE.WebGLRenderer({antialias:true,preserveDrawingBuffer:true});
offRndr.setSize(res,res);offRndr.setPixelRatio(1);
offRndr.outputColorSpace=THREE.LinearSRGBColorSpace;

var fov=50;
var offCam=new THREE.PerspectiveCamera(fov,1,1,radius*10);

// Generate camera poses — orbits at 3 elevations + top-down
var frames=[];
var elevations=[0.3,0.55,0.8]; // fraction of PI (low, mid, high)
var viewsPerRing=Math.floor(numViews/elevations.length);
var extraTop=numViews-viewsPerRing*elevations.length;

for(var e=0;e<elevations.length;e++){
var phi=Math.PI*elevations[e];
var n=viewsPerRing+(e<extraTop?1:0);
for(var i=0;i<n;i++){
var theta=(2*Math.PI*i)/n;
var x=center.x+radius*Math.sin(phi)*Math.cos(theta);
var y=center.y+radius*Math.cos(phi);
var z=center.z+radius*Math.sin(phi)*Math.sin(theta);
frames.push({pos:[x,y,z],target:[center.x,center.y,center.z]});
}
}

// Render each frame and collect PNGs
var zip=new JSZip();
var imgFolder=zip.folder('images');
var transforms={
camera_model:'OPENCV',
fl_x:res/(2*Math.tan(fov*Math.PI/360)),
fl_y:res/(2*Math.tan(fov*Math.PI/360)),
cx:res/2,cy:res/2,
w:res,h:res,
frames:[]
};

for(var i=0;i<frames.length;i++){
prog.textContent='Rendering view '+(i+1)+' / '+frames.length;
offCam.position.set(frames[i].pos[0],frames[i].pos[1],frames[i].pos[2]);
offCam.lookAt(frames[i].target[0],frames[i].target[1],frames[i].target[2]);
offCam.updateMatrixWorld(true);

offRndr.clear();offRndr.render(scene,offCam);

// Build nerfstudio-format transform matrix (c2w, OpenGL convention)
// Three.js matrixWorld is already camera-to-world
var m=offCam.matrixWorld.clone();
// Convert from Three.js (Y-up, -Z forward) to OpenGL (Y-up, -Z forward) — same convention, just emit the 4x4
var me=m.elements; // column-major
var c2w=[
[me[0],me[4],me[8],me[12]],
[me[1],me[5],me[9],me[13]],
[me[2],me[6],me[10],me[14]],
[me[3],me[7],me[11],me[15]]
];

var fname='images/frame_'+String(i).padStart(5,'0')+'.png';
transforms.frames.push({file_path:fname,transform_matrix:c2w});

// Canvas to PNG blob
var dataUrl=offRndr.domElement.toDataURL('image/png');
var b64=dataUrl.split(',')[1];
imgFolder.file('frame_'+String(i).padStart(5,'0')+'.png',b64,{base64:true});

// Yield to keep UI responsive
if(i%4===0)await new Promise(function(r){setTimeout(r,0)});
}

offRndr.dispose();

prog.textContent='Compressing ZIP...';
zip.file('transforms.json',JSON.stringify(transforms,null,2));

var blob=await zip.generateAsync({type:'blob'},function(meta){
prog.textContent='Compressing... '+Math.round(meta.percent)+'%';
});

var url=URL.createObjectURL(blob);
var a=document.createElement('a');a.href=url;a.download='training_views.zip';a.click();
URL.revokeObjectURL(url);

btn.disabled=false;btn.textContent='Export Views ZIP';
prog.textContent='Done — '+frames.length+' views at '+res+'px';
toast('Training views exported');
}

// ============================================================
// DRAWER (mobile)
// ============================================================
function setupDrawer(){}
function toggleDrawer(){var sb=document.getElementById('sidebar');drawerOpen=!drawerOpen;sb.classList.toggle('open',drawerOpen)}

// ============================================================
// ANIMATION
// ============================================================
function animate(time){
requestAnimationFrame(animate);
updCam();
rndr.clear();
rndr.render(scene, cam);
var s=isMobile?70:120;var d=new THREE.Vector3().subVectors(cam.position,orb.tgt).normalize();cCam.position.copy(d.multiplyScalar(3.5));cCam.lookAt(0,0,0);
var vp=rndr.getSize(new THREE.Vector2());rndr.setViewport(vp.x-s-10,vp.y-s-10,s,s);rndr.setScissor(vp.x-s-10,vp.y-s-10,s,s);rndr.setScissorTest(true);rndr.clearDepth();rndr.render(cScene,cCam);rndr.setScissorTest(false);rndr.setViewport(0,0,vp.x,vp.y);
}

// Expose for inline HTML handlers
Object.assign(window,{switchTab,toggleDrawer,fitView,loadFile,exportTrack,undoAll,handleFile,handleImageUpload,setEditMode,smoothSelection,smoothAll,applyElevation,extractControlPoints,rebuildFromSpline,updateCPFromInput,insertCPAfter,deleteSelectedCP,onDefaultWidthChange,setAllWidths,onCPWidthChange,widthPreset,rebuildWithWidth,previewLoop,makeLoop,removeLoop,generateTerrain,clearTerrain,toggleSpeedPads,placeSpeedPads,toggleAICars,placeAICars,generateScenery,clearScenery,toggleScenery,exportAll,startGame,stopGame,generateMarbleWorld,trackAwarePrompt,loadSplatFromURL,loadSplatFromFile,removeSplat,splatBackdropPreset,splatResetTransform,checkMarbleOperation,clearMarblePending,checkRunwayOperation,clearRunwayPending,exportTrainingViews,recordFlythrough,downloadFlythrough,runRunwayStylize,runMarbleFromVideo,runFullPipeline});
init();fitView();showMarblePending();showRunwayPending();onRunwayModelChange();
</script>

</body>
</html>
