<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,maximum-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Horizon Drive</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
canvas{display:block;width:100%;height:100%}

#ui-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:10;pointer-events:none}
#ui-overlay>*{pointer-events:auto}

/* HUD */
#hud{position:absolute;top:0;left:0;right:0;display:flex;justify-content:space-between;align-items:center;padding:8px 16px;font:700 14px/1 system-ui,sans-serif;color:#fff;background:linear-gradient(180deg,rgba(0,0,0,.5),transparent);display:none}
#hud .speed{font-size:22px;color:#0ff;text-shadow:0 0 10px #0ff}
#hud .time{font-size:18px;color:#ffd700;text-shadow:0 0 8px rgba(255,215,0,.5)}
#hud .progress{font-size:12px;opacity:.7}

/* Start screen */
#start-screen{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(ellipse at 50% 60%,#1a0040,#0a001a);z-index:20}
#start-screen h1{font:900 2.8rem/1 system-ui;background:linear-gradient(135deg,#ff6ec7,#ffd700);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:.3rem}
#start-screen .sub{font:400 .85rem/1 system-ui;color:#a080d0;margin-bottom:2.5rem}
#start-btn{
  background:linear-gradient(135deg,#ff6ec7,#ff3cac);color:#fff;border:none;
  padding:16px 48px;border-radius:14px;font:700 1.1rem system-ui;cursor:pointer;
  box-shadow:0 4px 24px rgba(255,60,172,.4);-webkit-tap-highlight-color:transparent;
}
#start-btn:active{transform:scale(.96)}
.controls-hint{font:400 .7rem/1.5 system-ui;color:#8060b0;margin-top:1.5rem;text-align:center}

/* Countdown */
#countdown{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font:900 6rem system-ui;color:#fff;text-shadow:0 0 40px #ff6ec7,0 0 80px #ff3cac;display:none;z-index:15}

/* Finish screen */
#finish-screen{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.75);backdrop-filter:blur(8px);display:none;z-index:20}
#finish-screen h2{font:900 2rem system-ui;color:#ffd700;text-shadow:0 0 20px rgba(255,215,0,.5);margin-bottom:.5rem}
#finish-screen .final-time{font:700 3.5rem system-ui;color:#fff;margin-bottom:.3rem}
#finish-screen .label{font:400 .8rem system-ui;color:#a080d0;margin-bottom:2rem}
#restart-btn{
  background:linear-gradient(135deg,#6e3cff,#3c8cff);color:#fff;border:none;
  padding:14px 40px;border-radius:14px;font:700 1rem system-ui;cursor:pointer;
  box-shadow:0 4px 20px rgba(60,140,255,.35);-webkit-tap-highlight-color:transparent;
}

/* Tilt indicator */
#tilt-indicator{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:120px;height:6px;background:rgba(255,255,255,.1);border-radius:3px;display:none}
#tilt-dot{position:absolute;top:50%;left:50%;width:14px;height:14px;background:#ff6ec7;border-radius:50%;transform:translate(-50%,-50%);box-shadow:0 0 10px #ff6ec7;transition:left .05s}

/* Loading */
#loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#a080d0;font:600 1rem system-ui;z-index:25}
</style>
</head>
<body>

<div id="ui-overlay">
  <div id="loading">Loading track...</div>

  <div id="start-screen" style="display:none">
    <h1>HORIZON DRIVE</h1>
    <p class="sub">Accelerometer Racing</p>
    <button id="start-btn">START</button>
    <p class="controls-hint">Tilt phone to steer &bull; Auto-gas<br>Or use arrow keys on desktop</p>
  </div>

  <div id="hud">
    <div><span class="speed" id="speed-val">0</span> <span style="font-size:11px;opacity:.5">km/h</span></div>
    <div class="time" id="time-val">0:00.0</div>
    <div class="progress" id="progress-val">0%</div>
    <div id="boost-hud" style="display:none;color:#0f0;font-size:16px;font-weight:900;text-shadow:0 0 12px #0f0,0 0 24px #0f0">BOOST!</div>
  </div>
  <div id="position-hud" style="position:absolute;top:50px;right:16px;font:900 28px system-ui;color:#ffd700;text-shadow:0 0 12px rgba(255,215,0,.6);display:none"><span id="pos-num">1</span><span id="pos-suffix" style="font-size:14px;opacity:.7">st</span><span style="font-size:12px;opacity:.5;margin-left:4px">/ 6</span></div>

  <div id="countdown"></div>

  <div id="finish-screen">
    <h2>FINISH!</h2>
    <div class="final-time" id="final-time">0:00.00</div>
    <div class="label">Your Time</div>
    <button id="restart-btn">RACE AGAIN</button>
  </div>

  <div id="tilt-indicator">
    <div id="tilt-dot"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
(function(){
'use strict';

// ── CONFIG ──
const CFG = {
  maxSpeed: 540,       // max km/h (3x)
  accel: 135,          // km/h per second acceleration (3x)
  brake: 240,          // km/h per second braking (3x)
  friction: 24,        // passive decel km/h/s (3x)
  steerSpeed: 2.8,     // lateral offset speed
  maxLateral: 9,        // max lateral offset from center
  roadWidth: 20,       // road visual width
  cameraHeight: 4.5,
  cameraDist: 12,
  cameraLerp: 0.08,
  fov: 72,
  // Boost pads
  boostCount: 40,       // lots of boost pads throughout the track
  boostSpeed: 780,      // speed during boost (km/h) (3x)
  boostDuration: 1.5,   // seconds of boost (shorter since there are more)
  boostPadWidth: 6,     // pad width on road
  boostPadLength: 4,    // pad length along track
  // AI opponents
  aiCount: 5,           // number of AI cars
  aiMinSpeed: 330,      // slowest AI base speed (km/h) (3x)
  aiMaxSpeed: 495,      // fastest AI base speed (km/h) (3x)
  aiWeaveAmp: 2.5,      // lateral weave amplitude
  aiWeaveFreq: 0.3,     // weave frequency (Hz)
};

// ── STATE ──
let trackData = null;
let curve = null;
let trackLength = 0;
let scene, camera, renderer, composer, bloomPass;
let roadMesh, groundMesh;
let carGroup, carBody;
let barrierLeft, barrierRight;
let boostPads = [];     // [{t: 0..1, mesh, used: false}]
let boostTimer = 0;     // remaining boost seconds
let boostMeshes = [];   // for animation
let aiCars = [];        // [{group, progress, speed, baseSpeed, lateral, weavePhase}]
let playerPosition = 1; // 1-based position among all racers

let gameState = 'loading'; // loading, ready, countdown, racing, finished
let raceStartTime = 0;
let raceTime = 0;
let speed = 0;         // km/h
let trackProgress = 0; // 0..1
let lateralOffset = 0; // left/right offset from track center
let steerInput = 0;    // -1 to 1

// Input
let keys = {};
let gyroGamma = 0;
let gyroCal = 0;
let gyroAvailable = false;
const DEADZONE = 8; // degrees

// DOM
const $loading = document.getElementById('loading');
const $startScreen = document.getElementById('start-screen');
const $startBtn = document.getElementById('start-btn');
const $hud = document.getElementById('hud');
const $speedVal = document.getElementById('speed-val');
const $timeVal = document.getElementById('time-val');
const $progressVal = document.getElementById('progress-val');
const $countdown = document.getElementById('countdown');
const $finishScreen = document.getElementById('finish-screen');
const $finalTime = document.getElementById('final-time');
const $restartBtn = document.getElementById('restart-btn');
const $tiltIndicator = document.getElementById('tilt-indicator');
const $tiltDot = document.getElementById('tilt-dot');
const $positionHud = document.getElementById('position-hud');
const $posNum = document.getElementById('pos-num');
const $posSuffix = document.getElementById('pos-suffix');

// ── LOAD TRACK ──
fetch('track.json')
  .then(r => r.json())
  .then(data => {
    trackData = data;
    init();
  })
  .catch(e => {
    $loading.textContent = 'Failed to load track: ' + e.message;
  });

function init() {
  // Build Three.js curve from track data
  // Use every 3rd point to keep it manageable (1000 control points)
  const points = [];
  for (let i = 0; i < trackData.length; i += 3) {
    const p = trackData[i][0];
    // Swap Y/Z for Three.js coordinate system (Y up)
    points.push(new THREE.Vector3(p[0], p[2], -p[1]));
  }
  curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
  trackLength = curve.getLength();

  setupScene();
  buildTrack();
  buildCar();
  buildAICars();
  buildEnvironment();
  setupInput();
  setupUI();

  $loading.style.display = 'none';
  $startScreen.style.display = 'flex';
  gameState = 'ready';

  // Position camera at start
  updateCarPosition(0, 0);
  updateCamera(true);

  animate();
}

// ── SCENE SETUP ──
function setupScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a001a);
  scene.fog = new THREE.FogExp2(0x0a001a, 0.004);

  camera = new THREE.PerspectiveCamera(CFG.fov, innerWidth/innerHeight, 0.5, 800);
  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambient = new THREE.AmbientLight(0x4040a0, 0.4);
  scene.add(ambient);

  const dirLight = new THREE.DirectionalLight(0xffeedd, 0.8);
  dirLight.position.set(50, 100, 50);
  scene.add(dirLight);

  // Neon glow from below
  const underLight = new THREE.PointLight(0xff6ec7, 0.6, 100);
  underLight.position.set(0, -5, 0);
  scene.add(underLight);

  // ── BLOOM POST-PROCESSING ──
  const renderPass = new THREE.RenderPass(scene, camera);
  bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    1.4,   // bloom strength (Horizon Drive uses heavy bloom)
    0.6,   // bloom radius (how far glow spreads)
    0.15   // bloom threshold (low = more things glow)
  );
  composer = new THREE.EffectComposer(renderer);
  composer.addPass(renderPass);
  composer.addPass(bloomPass);

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
  });
}

// ── BUILD TRACK ──
function buildTrack() {
  const divisions = 2000;
  const halfWidth = CFG.roadWidth / 2;

  // Road surface
  const roadGeo = new THREE.BufferGeometry();
  const vertices = [];
  const colors = [];
  const indices = [];

  for (let i = 0; i <= divisions; i++) {
    const t = i / divisions;
    const point = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();

    // If cross product is degenerate, use fallback
    if (right.length() < 0.1) {
      right.set(1, 0, 0);
    }

    const lx = point.x - right.x * halfWidth;
    const ly = point.y - right.y * halfWidth;
    const lz = point.z - right.z * halfWidth;
    const rx = point.x + right.x * halfWidth;
    const ry = point.y + right.y * halfWidth;
    const rz = point.z + right.z * halfWidth;

    vertices.push(lx, ly, lz, rx, ry, rz);

    // Neon road coloring - subtle stripe pattern
    const stripe = (i % 40 < 2) ? 1.0 : 0.15;
    const edgeGlow = 0.5;
    // Left edge: pink, Right edge: cyan, Center: dark
    colors.push(stripe * 0.8, stripe * 0.1, stripe * 0.5, 1); // left - pink
    colors.push(stripe * 0.1, stripe * 0.5, stripe * 0.8, 1); // right - cyan

    if (i < divisions) {
      const base = i * 2;
      indices.push(base, base + 1, base + 2);
      indices.push(base + 1, base + 3, base + 2);
    }
  }

  roadGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  roadGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));
  roadGeo.setIndex(indices);
  roadGeo.computeVertexNormals();

  const roadMat = new THREE.MeshStandardMaterial({
    vertexColors: true,
    metalness: 0.8,
    roughness: 0.2,
    emissive: new THREE.Color(0x330066),
    emissiveIntensity: 0.6,
    side: THREE.DoubleSide,
  });

  roadMesh = new THREE.Mesh(roadGeo, roadMat);
  scene.add(roadMesh);

  // Edge barriers (neon rails)
  buildBarriers(divisions, halfWidth);

  // Start/finish line
  buildStartLine();

  // Boost pads
  buildBoostPads();
}

function buildBarriers(divisions, halfWidth) {
  const step = 4;
  const leftPts = [];
  const rightPts = [];

  for (let i = 0; i <= divisions; i += step) {
    const t = i / divisions;
    const point = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
    if (right.length() < 0.1) right.set(1, 0, 0);

    leftPts.push(new THREE.Vector3(
      point.x - right.x * (halfWidth + 0.3),
      point.y + 0.4,
      point.z - right.z * (halfWidth + 0.3)
    ));
    rightPts.push(new THREE.Vector3(
      point.x + right.x * (halfWidth + 0.3),
      point.y + 0.4,
      point.z + right.z * (halfWidth + 0.3)
    ));
  }

  // Glowing tube barriers using TubeGeometry on CatmullRomCurve3
  const leftCurve = new THREE.CatmullRomCurve3(leftPts, false, 'catmullrom', 0.5);
  const rightCurve = new THREE.CatmullRomCurve3(rightPts, false, 'catmullrom', 0.5);

  // Left barrier - hot pink neon glow
  const leftGeo = new THREE.TubeGeometry(leftCurve, divisions / step, 0.12, 6, false);
  const leftMat = new THREE.MeshBasicMaterial({ color: 0xff6ec7 });
  barrierLeft = new THREE.Mesh(leftGeo, leftMat);
  scene.add(barrierLeft);

  // Right barrier - cyan neon glow
  const rightGeo = new THREE.TubeGeometry(rightCurve, divisions / step, 0.12, 6, false);
  const rightMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  barrierRight = new THREE.Mesh(rightGeo, rightMat);
  scene.add(barrierRight);
}

function buildStartLine() {
  const geo = new THREE.PlaneGeometry(CFG.roadWidth, 1.5);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffd700,
    side: THREE.DoubleSide,
  });
  const startLine = new THREE.Mesh(geo, mat);

  const p = curve.getPointAt(0);
  const t = curve.getTangentAt(0).normalize();
  const up = new THREE.Vector3(0, 1, 0);
  startLine.position.copy(p);
  startLine.position.y += 0.05;
  startLine.lookAt(p.clone().add(t));
  startLine.rotateX(-Math.PI / 2);
  scene.add(startLine);
}

function buildBoostPads() {
  boostPads = [];
  boostMeshes = [];

  // Shared geometries — bigger and brighter
  const baseGeo = new THREE.PlaneGeometry(CFG.boostPadWidth, CFG.boostPadLength);
  const baseMat = new THREE.MeshBasicMaterial({
    color: 0x00ffaa, transparent: true, opacity: 0.55, side: THREE.DoubleSide,
    depthWrite: false,
  });
  const arrowMat = new THREE.MeshBasicMaterial({
    color: 0x44ffaa, side: THREE.DoubleSide, depthWrite: false,
  });

  // Build a bigger, chunkier chevron arrow (pointing backward in local Y so it faces forward after lookAt)
  const arrowShape = new THREE.Shape();
  arrowShape.moveTo(0, -1.1);
  arrowShape.lineTo(-0.7, 0.3);
  arrowShape.lineTo(-0.3, 0.3);
  arrowShape.lineTo(0, -0.2);
  arrowShape.lineTo(0.3, 0.3);
  arrowShape.lineTo(0.7, 0.3);
  arrowShape.closePath();
  const arrowGeo = new THREE.ShapeGeometry(arrowShape);

  for (let i = 0; i < CFG.boostCount; i++) {
    const t = 0.05 + (i / CFG.boostCount) * 0.9;

    const tA = Math.max(0, t - 0.001);
    const tB = Math.min(0.9999, t + 0.001);
    const point = curve.getPointAt(t);
    const pA = curve.getPointAt(tA);
    const pB = curve.getPointAt(tB);

    const tangent = new THREE.Vector3().subVectors(pB, pA).normalize();
    const worldUp = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, worldUp).normalize();
    if (right.lengthSq() < 0.01) right.set(1, 0, 0);
    const normal = new THREE.Vector3().crossVectors(right, tangent).normalize();

    const padGroup = new THREE.Group();
    padGroup.position.copy(point);
    // Lift above road surface to avoid z-fighting
    padGroup.position.addScaledVector(normal, 0.2);

    // Orient: look along the tangent (track forward), with surface normal as up
    const lookTarget = point.clone().add(tangent);
    lookTarget.addScaledVector(normal, 0.2);
    padGroup.up.copy(normal);
    padGroup.lookAt(lookTarget);

    // Base rectangle — XY plane facing up after lookAt
    const base = new THREE.Mesh(baseGeo, baseMat.clone());
    base.rotation.x = -Math.PI / 2;
    padGroup.add(base);

    // 3 chevron arrows spread along the forward (local Z) direction
    for (let a = -1; a <= 1; a++) {
      const arrow = new THREE.Mesh(arrowGeo, arrowMat);
      arrow.rotation.x = -Math.PI / 2;
      arrow.position.set(0, 0.02, a * 1.3);
      arrow.scale.set(1.5, 1.5, 1.5);
      padGroup.add(arrow);
    }

    // Edge glow strips on left/right sides
    const edgeGeo = new THREE.PlaneGeometry(0.3, CFG.boostPadLength);
    const edgeMat = new THREE.MeshBasicMaterial({
      color: 0x00ff44, side: THREE.DoubleSide, depthWrite: false,
    });
    const edgeL = new THREE.Mesh(edgeGeo, edgeMat);
    edgeL.rotation.x = -Math.PI / 2;
    edgeL.position.set(-CFG.boostPadWidth / 2, 0.01, 0);
    padGroup.add(edgeL);
    const edgeR = new THREE.Mesh(edgeGeo, edgeMat);
    edgeR.rotation.x = -Math.PI / 2;
    edgeR.position.set(CFG.boostPadWidth / 2, 0.01, 0);
    padGroup.add(edgeR);

    scene.add(padGroup);
    boostPads.push({ t: t, group: padGroup, active: false });
    boostMeshes.push(padGroup);
  }
}

// ── BUILD CAR ──
function buildCar() {
  carGroup = new THREE.Group();

  // Load GLB model
  const loader = new THREE.GLTFLoader();
  loader.load('base_basic_shaded.glb', (gltf) => {
    const model = gltf.scene;

    // Auto-center and scale the model
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    // Scale to fit roughly 8 units long (car length)
    const targetLength = 8;
    const maxDim = Math.max(size.x, size.y, size.z);
    const s = targetLength / maxDim;
    model.scale.setScalar(s);

    // Re-center after scaling
    box.setFromObject(model);
    box.getCenter(center);
    model.position.sub(center);
    // Sit on ground plane
    box.setFromObject(model);
    model.position.y -= box.min.y;

    carGroup.add(model);
  });

  // Headlight beams
  const beamLight = new THREE.SpotLight(0xffffff, 2.0, 80, Math.PI/6, 0.5);
  beamLight.position.set(0, 0.5, 2);
  beamLight.target.position.set(0, 0, 20);
  carGroup.add(beamLight);
  carGroup.add(beamLight.target);

  // Neon underglow
  const underGlow = new THREE.PointLight(0xff6ec7, 2.5, 12);
  underGlow.position.set(0, -0.1, 0);
  carGroup.add(underGlow);

  // Underglow visible mesh
  const ugGeo = new THREE.PlaneGeometry(1.4, 2.8);
  const ugMat = new THREE.MeshBasicMaterial({
    color: 0xff6ec7, transparent: true, opacity: 0.4, side: THREE.DoubleSide,
  });
  const ugMesh = new THREE.Mesh(ugGeo, ugMat);
  ugMesh.rotation.x = -Math.PI / 2;
  ugMesh.position.y = 0.02;
  carGroup.add(ugMesh);

  scene.add(carGroup);
}

// ── AI CARS ──
function buildAICars() {
  aiCars = [];
  const aiColors = [0xff3333, 0x33aaff, 0xffaa00, 0xaa33ff, 0x33ff88];

  for (let i = 0; i < CFG.aiCount; i++) {
    const group = new THREE.Group();

    // Simple box car body
    const bodyGeo = new THREE.BoxGeometry(2.2, 1.0, 4.5);
    const bodyMat = new THREE.MeshStandardMaterial({
      color: aiColors[i % aiColors.length],
      emissive: new THREE.Color(aiColors[i % aiColors.length]),
      emissiveIntensity: 0.4,
      metalness: 0.7,
      roughness: 0.3,
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.7;
    group.add(body);

    // Roof
    const roofGeo = new THREE.BoxGeometry(1.8, 0.6, 2.2);
    const roof = new THREE.Mesh(roofGeo, bodyMat);
    roof.position.set(0, 1.35, -0.3);
    group.add(roof);

    // Tail lights (red glow)
    const tailGeo = new THREE.BoxGeometry(1.8, 0.2, 0.1);
    const tailMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
    const tail = new THREE.Mesh(tailGeo, tailMat);
    tail.position.set(0, 0.7, -2.3);
    group.add(tail);

    // Neon underglow matching car color
    const ugLight = new THREE.PointLight(aiColors[i % aiColors.length], 1.5, 8);
    ugLight.position.set(0, -0.1, 0);
    group.add(ugLight);

    scene.add(group);

    // Stagger starting positions: AI cars start slightly behind player
    const startProgress = -0.002 * (i + 1);
    // Each AI has a different base speed
    const baseSpeed = CFG.aiMinSpeed + (CFG.aiMaxSpeed - CFG.aiMinSpeed) * (i / Math.max(1, CFG.aiCount - 1));

    aiCars.push({
      group: group,
      progress: startProgress,
      speed: 0,
      baseSpeed: baseSpeed,
      lateral: (i - 2) * 3,  // spread across the road
      weavePhase: Math.random() * Math.PI * 2,
      boostTimer: 0,
      finished: false,
    });
  }
}

function updateAICar(ai, dt) {
  if (ai.finished) return;

  // Accelerate toward base speed
  if (ai.speed < ai.baseSpeed) {
    ai.speed += CFG.accel * 0.8 * dt;
  } else {
    ai.speed -= CFG.friction * dt;
  }
  ai.speed = Math.max(0, ai.speed);

  // Boost pad detection for AI
  const padHitZone = (CFG.boostPadLength / trackLength) / 2;
  for (let bp of boostPads) {
    if (Math.abs(ai.progress - bp.t) < padHitZone && ai.boostTimer <= 0) {
      ai.boostTimer = CFG.boostDuration * 0.8; // slightly shorter AI boost
    }
  }
  if (ai.boostTimer > 0) {
    ai.boostTimer -= dt;
    ai.speed = Math.max(ai.speed, CFG.boostSpeed * 0.9);
  }

  // Add slight speed variation (personality)
  const speedVariation = Math.sin(performance.now() * 0.001 + ai.weavePhase * 10) * 8;
  const effectiveSpeed = ai.speed + speedVariation;

  // Progress along track
  const metersPerSec = Math.max(0, effectiveSpeed) / 3.6;
  ai.progress += (metersPerSec * dt) / trackLength;

  // Lateral weaving
  ai.lateral = Math.sin(performance.now() * 0.001 * CFG.aiWeaveFreq + ai.weavePhase) * CFG.aiWeaveAmp;

  // Finish check
  if (ai.progress >= 1) {
    ai.progress = 1;
    ai.finished = true;
  }

  // Position the car on track
  const t = Math.max(0, Math.min(0.9999, ai.progress));
  const point = curve.getPointAt(t);
  const tangent = curve.getTangentAt(t).normalize();
  const up = new THREE.Vector3(0, 1, 0);
  const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
  if (right.length() < 0.1) right.set(1, 0, 0);

  ai.group.position.set(
    point.x + right.x * ai.lateral,
    point.y + 0.15,
    point.z + right.z * ai.lateral
  );

  const lookTarget = new THREE.Vector3(
    point.x + tangent.x * 5 + right.x * ai.lateral,
    point.y + tangent.y * 5,
    point.z + tangent.z * 5 + right.z * ai.lateral
  );
  ai.group.lookAt(lookTarget);
}

function calcPosition() {
  let pos = 1;
  for (let ai of aiCars) {
    if (ai.progress > trackProgress) pos++;
  }
  return pos;
}

function positionSuffix(n) {
  if (n === 1) return 'st';
  if (n === 2) return 'nd';
  if (n === 3) return 'rd';
  return 'th';
}

// ── ENVIRONMENT ──
function buildEnvironment() {
  // Ground plane
  const groundGeo = new THREE.PlaneGeometry(8000, 8000);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x050010,
    roughness: 1,
    metalness: 0,
  });
  groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI/2;
  groundMesh.position.y = -2;
  scene.add(groundMesh);

  // Grid lines on ground
  const gridHelper = new THREE.GridHelper(4000, 200, 0x1a0040, 0x0a0020);
  gridHelper.position.y = -1.9;
  scene.add(gridHelper);

  // Starfield
  const starCount = 2000;
  const starGeo = new THREE.BufferGeometry();
  const starPositions = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount; i++) {
    starPositions[i*3] = (Math.random() - 0.5) * 4000;
    starPositions[i*3+1] = Math.random() * 400 + 20;
    starPositions[i*3+2] = (Math.random() - 0.5) * 4000;
  }
  starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: true });
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // Decorative neon pillars along the track
  buildTrackDecorations();
}

function buildTrackDecorations() {
  const pillarGeo = new THREE.CylinderGeometry(0.12, 0.12, 8, 6);
  const glowOrbGeo = new THREE.SphereGeometry(0.35, 8, 8);
  const neonColors = [0xff6ec7, 0x00ffff, 0xffd700, 0x6e3cff];
  const halfWidth = CFG.roadWidth / 2;
  const count = 120;

  // Pre-create materials for reuse
  const pillarMats = neonColors.map(c => new THREE.MeshStandardMaterial({
    color: 0x111122,
    emissive: new THREE.Color(c),
    emissiveIntensity: 0.15,
    metalness: 0.9,
    roughness: 0.3,
  }));
  const orbMats = neonColors.map(c => new THREE.MeshBasicMaterial({ color: c }));

  for (let i = 0; i < count; i++) {
    const t = i / count;
    const point = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
    if (right.length() < 0.1) continue;

    const side = (i % 2 === 0) ? -1 : 1;
    const ci = i % neonColors.length;

    // Dark pillar with faint emissive
    const pillar = new THREE.Mesh(pillarGeo, pillarMats[ci]);
    pillar.position.set(
      point.x + right.x * (halfWidth + 3) * side,
      point.y + 4,
      point.z + right.z * (halfWidth + 3) * side
    );
    scene.add(pillar);

    // Bright glowing orb on top — this blooms hard
    const orb = new THREE.Mesh(glowOrbGeo, orbMats[ci]);
    orb.position.set(pillar.position.x, pillar.position.y + 4.3, pillar.position.z);
    scene.add(orb);
  }
}

// ── INPUT ──
function setupInput() {
  // Keyboard
  document.addEventListener('keydown', e => { keys[e.code] = true; });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  // Touch steering (left/right halves of screen)
  let touchSteer = 0;
  document.addEventListener('touchstart', handleTouch, { passive: false });
  document.addEventListener('touchmove', handleTouch, { passive: false });
  document.addEventListener('touchend', () => { touchSteer = 0; });

  function handleTouch(e) {
    if (gameState !== 'racing') return;
    e.preventDefault();
    const touch = e.touches[0];
    if (!touch) { touchSteer = 0; return; }
    const x = touch.clientX / innerWidth;
    touchSteer = (x - 0.5) * 2; // -1 to 1
  }

  // Update steer input each frame
  window._getTouchSteer = () => touchSteer;
}

function requestGyro() {
  if (typeof DeviceOrientationEvent !== 'undefined' &&
      typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission().then(state => {
      if (state === 'granted') enableGyro();
    }).catch(() => {});
  } else {
    enableGyro();
  }
}

function enableGyro() {
  let samples = 0;
  let sumAbs = 0;
  window.addEventListener('deviceorientation', e => {
    const g = e.gamma || 0;
    gyroGamma = g;
    // Only mark gyro as available after seeing consistent real tilt data
    // (avoids false positives from desktop sensors / noise)
    if (!gyroAvailable) {
      samples++;
      sumAbs += Math.abs(g);
      if (samples >= 10 && (sumAbs / samples) > 2) {
        gyroAvailable = true;
        $tiltIndicator.style.display = 'block';
      }
    }
  });
}

function getSteerInput() {
  // Priority: gyro > keyboard > touch
  if (gyroAvailable) {
    const adjusted = gyroGamma - gyroCal;
    if (Math.abs(adjusted) < DEADZONE) return 0;
    const raw = (adjusted - Math.sign(adjusted) * DEADZONE) / (45 - DEADZONE);
    return Math.max(-1, Math.min(1, raw));
  }

  if (keys['ArrowLeft'] || keys['KeyA']) return -1;
  if (keys['ArrowRight'] || keys['KeyD']) return 1;

  const ts = window._getTouchSteer ? window._getTouchSteer() : 0;
  if (Math.abs(ts) > 0.05) return Math.max(-1, Math.min(1, ts));

  return 0;
}

function getBrakeInput() {
  return (keys['ArrowDown'] || keys['KeyS'] || keys['Space']) ? 1 : 0;
}

// ── UI ──
function setupUI() {
  $startBtn.addEventListener('click', startRace);
  $restartBtn.addEventListener('click', restartRace);
}

function startRace() {
  requestGyro();
  gyroCal = gyroGamma;
  $startScreen.style.display = 'none';
  gameState = 'countdown';
  doCountdown();
}

function doCountdown() {
  $countdown.style.display = 'block';
  let count = 3;
  $countdown.textContent = count;

  const interval = setInterval(() => {
    count--;
    if (count > 0) {
      $countdown.textContent = count;
    } else if (count === 0) {
      $countdown.textContent = 'GO!';
      $countdown.style.color = '#0f0';
    } else {
      clearInterval(interval);
      $countdown.style.display = 'none';
      $countdown.style.color = '#fff';
      gameState = 'racing';
      raceStartTime = performance.now();
      $hud.style.display = 'flex';
      $positionHud.style.display = '';
      if (gyroAvailable) $tiltIndicator.style.display = 'block';
    }
  }, 800);
}

function finishRace() {
  gameState = 'finished';
  $hud.style.display = 'none';
  $positionHud.style.display = 'none';
  $tiltIndicator.style.display = 'none';
  const t = raceTime;
  const min = Math.floor(t / 60);
  const sec = (t % 60).toFixed(2);
  $finalTime.textContent = min + ':' + (sec < 10 ? '0' : '') + sec;
  // Show final position
  const pos = calcPosition();
  document.querySelector('#finish-screen .label').textContent =
    'You finished ' + pos + positionSuffix(pos) + ' out of ' + (CFG.aiCount + 1);
  $finishScreen.style.display = 'flex';
}

function restartRace() {
  $finishScreen.style.display = 'none';
  speed = 0;
  trackProgress = 0;
  lateralOffset = 0;
  steerInput = 0;
  raceTime = 0;
  boostTimer = 0;
  playerPosition = 1;
  for (let bp of boostPads) { bp.active = false; }
  // Reset AI cars
  for (let i = 0; i < aiCars.length; i++) {
    aiCars[i].progress = -0.002 * (i + 1);
    aiCars[i].speed = 0;
    aiCars[i].boostTimer = 0;
    aiCars[i].finished = false;
    aiCars[i].lateral = (i - 2) * 3;
  }
  updateCarPosition(0, 0);
  updateCamera(true);
  startRace();
}

function formatTime(t) {
  const min = Math.floor(t / 60);
  const sec = Math.floor(t % 60);
  const ms = Math.floor((t * 10) % 10);
  return min + ':' + (sec < 10 ? '0' : '') + sec + '.' + ms;
}

// ── CAR POSITION ──
function updateCarPosition(progress, lateral) {
  const t = Math.max(0, Math.min(0.9999, progress));
  const point = curve.getPointAt(t);
  const tangent = curve.getTangentAt(t).normalize();
  const up = new THREE.Vector3(0, 1, 0);
  const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
  if (right.length() < 0.1) right.set(1, 0, 0);

  carGroup.position.set(
    point.x + right.x * lateral,
    point.y + 0.15,
    point.z + right.z * lateral
  );

  // Orient car along track direction
  const lookTarget = new THREE.Vector3(
    point.x + tangent.x * 5 + right.x * lateral,
    point.y + tangent.y * 5,
    point.z + tangent.z * 5 + right.z * lateral
  );
  carGroup.lookAt(lookTarget);
}

// ── CAMERA ──
const camPos = new THREE.Vector3();
const camTarget = new THREE.Vector3();

function updateCamera(instant) {
  const t = Math.max(0, Math.min(0.9999, trackProgress));
  const point = curve.getPointAt(t);
  const tangent = curve.getTangentAt(t).normalize();
  const up = new THREE.Vector3(0, 1, 0);
  const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
  if (right.length() < 0.1) right.set(1, 0, 0);

  // Camera behind and above car
  const idealPos = new THREE.Vector3(
    point.x - tangent.x * CFG.cameraDist + right.x * lateralOffset * 0.5,
    point.y + CFG.cameraHeight,
    point.z - tangent.z * CFG.cameraDist + right.z * lateralOffset * 0.5
  );

  const idealTarget = new THREE.Vector3(
    point.x + tangent.x * 10 + right.x * lateralOffset,
    point.y + 1,
    point.z + tangent.z * 10 + right.z * lateralOffset
  );

  if (instant) {
    camPos.copy(idealPos);
    camTarget.copy(idealTarget);
  } else {
    camPos.lerp(idealPos, CFG.cameraLerp);
    camTarget.lerp(idealTarget, CFG.cameraLerp);
  }

  camera.position.copy(camPos);
  camera.lookAt(camTarget);
}

// ── GAME LOOP ──
let lastTime = 0;
function animate(now = 0) {
  requestAnimationFrame(animate);
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  if (gameState === 'racing') {
    // Timing
    raceTime = (performance.now() - raceStartTime) / 1000;
    $timeVal.textContent = formatTime(raceTime);

    // Steering — purely player input, no auto-centering
    steerInput = getSteerInput();
    lateralOffset += steerInput * CFG.steerSpeed * dt * (speed / CFG.maxSpeed + 0.3);
    lateralOffset = Math.max(-CFG.maxLateral, Math.min(CFG.maxLateral, lateralOffset));

    // Speed: always accelerating (auto-gas)
    const braking = getBrakeInput();
    if (braking) {
      speed -= CFG.brake * dt;
    } else {
      speed += CFG.accel * dt;
    }
    speed -= CFG.friction * dt;
    speed = Math.max(0, Math.min(CFG.maxSpeed, speed));

    // Boost pad detection — hit zone matches the visual pad length
    const padHitZone = (CFG.boostPadLength / trackLength) / 2;
    for (let bp of boostPads) {
      if (Math.abs(trackProgress - bp.t) < padHitZone && !bp.active) {
        bp.active = true;
        boostTimer = CFG.boostDuration;
      }
    }
    // Reset active flag once car passes through
    for (let bp of boostPads) {
      if (bp.active && Math.abs(trackProgress - bp.t) >= padHitZone) {
        bp.active = false;
      }
    }

    // Apply boost
    if (boostTimer > 0) {
      boostTimer -= dt;
      speed = Math.max(speed, CFG.boostSpeed);
      document.getElementById('boost-hud').style.display = '';
    } else {
      document.getElementById('boost-hud').style.display = 'none';
    }

    // Animate boost pads (pulse glow)
    const pulse = 0.4 + Math.sin(performance.now() * 0.005) * 0.15;
    for (let bp of boostPads) {
      bp.group.children[0].material.opacity = pulse;
    }

    // Progress along track
    const effectiveSpeed = boostTimer > 0 ? Math.max(speed, CFG.boostSpeed) : speed;
    const metersPerSec = effectiveSpeed / 3.6;
    trackProgress += (metersPerSec * dt) / trackLength;

    // Update AI cars
    for (let ai of aiCars) {
      updateAICar(ai, dt);
    }

    // Update position
    playerPosition = calcPosition();
    $posNum.textContent = playerPosition;
    $posSuffix.textContent = positionSuffix(playerPosition);

    // Update HUD
    $speedVal.textContent = Math.round(speed);
    $progressVal.textContent = Math.round(trackProgress * 100) + '%';

    // Update tilt indicator
    if (gyroAvailable) {
      const pct = 50 + (steerInput * 40);
      $tiltDot.style.left = pct + '%';
    }

    // Check finish
    if (trackProgress >= 1) {
      trackProgress = 1;
      finishRace();
    }

    updateCarPosition(trackProgress, lateralOffset);
  }

  updateCamera(false);

  // Move ground to follow camera loosely
  if (groundMesh) {
    groundMesh.position.x = camera.position.x;
    groundMesh.position.z = camera.position.z;
  }

  composer.render();
}

})();
</script>
</body>
</html>
