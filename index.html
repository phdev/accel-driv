<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>accel-driv — Track Suite</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&family=Outfit:wght@300;400;600;700&display=swap');
  *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  :root{--bg:#0a0a0f;--surface:#12121a;--surface2:#1a1a28;--border:#2a2a3a;--text:#e0e0f0;--text-dim:#7a7a9a;--accent:#ff6b35;--accent2:#00d4aa;--accent3:#5b8cff;--danger:#ff4466;--cp-color:#ffcc00;--drawer-height:58vh}
  body{background:var(--bg);color:var(--text);font-family:'Outfit',sans-serif;overflow:hidden;height:100dvh;width:100vw;touch-action:none}
  #app{display:flex;height:100dvh;width:100vw}
  #sidebar{width:330px;min-width:330px;background:var(--surface);border-right:1px solid var(--border);display:flex;flex-direction:column;z-index:10;overflow-y:auto;overflow-x:hidden}
  #sidebar::-webkit-scrollbar{width:4px}#sidebar::-webkit-scrollbar-track{background:transparent}#sidebar::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
  .drawer-toggle{display:none;width:100%;padding:8px 0;text-align:center;cursor:pointer;flex-shrink:0;-webkit-user-select:none;user-select:none}
  .drawer-toggle span{display:inline-block;font-size:18px;color:var(--text-dim);transition:transform .3s}
  #sidebar.open .drawer-toggle span{transform:rotate(180deg)}
  .sidebar-header{padding:14px 16px 10px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between}
  .sidebar-header h1{font-size:15px;font-weight:700;letter-spacing:-0.5px;color:var(--accent);font-family:'JetBrains Mono',monospace}
  .sidebar-header .subtitle{font-size:10px;color:var(--text-dim);font-family:'JetBrains Mono',monospace}
  .panel{padding:12px 14px;border-bottom:1px solid var(--border)}
  .panel-title{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:1.5px;color:var(--text-dim);margin-bottom:8px}
  .stat-row{display:flex;justify-content:space-between;align-items:center;font-size:12px;margin-bottom:4px}
  .stat-label{color:var(--text-dim)}.stat-value{color:var(--text);font-family:'JetBrains Mono',monospace;font-size:11px}
  .btn-group{display:flex;gap:5px;flex-wrap:wrap;margin-bottom:6px}
  .btn{background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:7px 10px;border-radius:6px;font-size:11px;cursor:pointer;font-family:'Outfit',sans-serif;transition:all .15s;flex:1;min-width:60px;text-align:center;-webkit-user-select:none;user-select:none}
  .btn:hover{background:var(--border);border-color:var(--text-dim)}.btn:active{transform:scale(.96)}
  .btn-accent{border-color:var(--accent);color:var(--accent)}.btn-accent:hover{background:var(--accent);color:#000}
  .btn-accent2{border-color:var(--accent2);color:var(--accent2)}.btn-accent2:hover{background:var(--accent2);color:#000}
  .btn-danger{border-color:var(--danger);color:var(--danger)}.btn-danger:hover{background:var(--danger);color:#fff}
  .btn-cp{border-color:var(--cp-color);color:var(--cp-color)}.btn-cp:hover{background:var(--cp-color);color:#000}
  .slider-group{margin-bottom:8px}
  .slider-label{display:flex;justify-content:space-between;font-size:11px;margin-bottom:3px;color:var(--text-dim)}
  .slider-label span:last-child{color:var(--accent);font-family:'JetBrains Mono',monospace}
  input[type="range"]{width:100%;height:5px;-webkit-appearance:none;background:var(--border);border-radius:3px;outline:none}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid var(--bg)}
  label.chk{display:flex;align-items:center;gap:8px;font-size:11px;color:var(--text-dim);margin-bottom:5px;cursor:pointer;padding:2px 0}
  label.chk input[type="checkbox"]{width:16px;height:16px}
  .top-tabs{display:flex;gap:0;border-bottom:1px solid var(--border);flex-shrink:0}
  .top-tab{flex:1;padding:10px 6px;background:var(--surface);border:none;border-bottom:2px solid transparent;font-size:12px;font-weight:600;color:var(--text-dim);cursor:pointer;text-align:center;font-family:'Outfit',sans-serif;transition:all .15s;-webkit-user-select:none;user-select:none}
  .top-tab.active{color:var(--accent);border-bottom-color:var(--accent);background:var(--surface2)}
  .top-tab:hover:not(.active){background:var(--surface2);color:var(--text)}
  .mode-tabs{display:flex;gap:3px;margin-bottom:10px}
  .mode-tab{flex:1;padding:6px 4px;background:var(--surface2);border:1px solid var(--border);border-radius:5px;font-size:11px;color:var(--text-dim);cursor:pointer;text-align:center;font-family:'Outfit',sans-serif;transition:all .15s;-webkit-user-select:none;user-select:none}
  .mode-tab.active{background:var(--accent);color:#000;border-color:var(--accent);font-weight:600}
  .mode-tab:hover:not(.active){background:var(--border)}
  .cp-input-row{display:flex;align-items:center;gap:6px;margin-bottom:3px}
  .cp-input-row label{font-size:10px;font-family:'JetBrains Mono',monospace;color:var(--text-dim);width:24px}
  .cp-input-row input{flex:1;background:var(--bg);border:1px solid var(--border);color:var(--text);padding:5px 6px;border-radius:4px;font-size:12px;font-family:'JetBrains Mono',monospace}
  .color-row{display:flex;align-items:center;gap:6px;margin-bottom:5px;font-size:11px;color:var(--text-dim)}
  .color-row input[type="color"]{width:24px;height:20px;border:1px solid var(--border);background:none;border-radius:3px;cursor:pointer;padding:0}
  .width-viz{margin-top:6px;background:var(--bg);border:1px solid var(--border);border-radius:5px;padding:6px}
  .width-viz canvas{width:100%;height:50px;display:block;border-radius:3px}
  #viewport{flex:1;position:relative;overflow:hidden}#viewport canvas{display:block;touch-action:none}
  #mobile-toolbar{display:none;position:absolute;top:10px;left:10px;right:10px;z-index:15;gap:5px}
  #mobile-toolbar .mtb-btn{background:rgba(18,18,26,.9);border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:8px;font-size:15px;cursor:pointer;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);line-height:1}
  #toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%) translateY(80px);background:var(--surface2);border:1px solid var(--accent);color:var(--text);padding:8px 20px;border-radius:8px;font-size:12px;font-family:'JetBrains Mono',monospace;z-index:200;opacity:0;transition:all .3s;pointer-events:none;white-space:nowrap}
  #toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
  #help-overlay{position:absolute;bottom:10px;right:10px;background:rgba(10,10,15,.85);border:1px solid var(--border);border-radius:8px;padding:8px 12px;font-size:10px;color:var(--text-dim);font-family:'JetBrains Mono',monospace;line-height:1.7;z-index:5;pointer-events:none}
  #help-overlay kbd{background:var(--surface2);border:1px solid var(--border);padding:1px 4px;border-radius:3px;color:var(--text);font-size:9px}
  #file-input{display:none}
  .tab-content{display:none}.tab-content.active{display:block}
  @media(max-width:768px){
    #app{flex-direction:column}
    #sidebar{position:fixed;bottom:0;left:0;right:0;width:100%;min-width:100%;height:var(--drawer-height);border-right:none;border-top:1px solid var(--border);border-radius:16px 16px 0 0;z-index:50;transform:translateY(calc(var(--drawer-height) - 48px));transition:transform .35s cubic-bezier(.4,0,.2,1);will-change:transform}
    #sidebar.open{transform:translateY(0)}
    .drawer-toggle{display:block}
    #viewport{height:100dvh;width:100vw;padding-bottom:48px}
    #mobile-toolbar{display:flex}#help-overlay{display:none}
    .btn{padding:9px 10px;font-size:12px;min-height:38px}.mode-tab{padding:8px 4px;font-size:12px;min-height:36px}
    .top-tab{padding:9px 4px;font-size:12px}
    input[type="range"]::-webkit-slider-thumb{width:22px;height:22px}input[type="range"]{height:7px}
    #toast{bottom:58px;font-size:11px;padding:7px 14px}
  }
</style>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <div class="drawer-toggle" onclick="toggleDrawer()"><span>&#9650;</span></div>
    <div class="sidebar-header"><div><h1>ACCEL-DRIV</h1><div class="subtitle">track suite</div></div></div>
    <div class="top-tabs">
      <button class="top-tab active" data-tab="track" onclick="switchTab('track')">Track</button>
      <button class="top-tab" data-tab="terrain" onclick="switchTab('terrain')">Terrain</button>
      <button class="top-tab" data-tab="gameplay" onclick="switchTab('gameplay')">Game</button>
      <button class="top-tab" data-tab="play" onclick="switchTab('play')" style="color:var(--accent)">Play</button>
      <button class="top-tab" data-tab="splat" onclick="switchTab('splat')">Splat</button>
    </div>

<!-- ===== TRACK TAB ===== -->
<div class="tab-content active" id="tab-track">
  <div class="panel"><div class="panel-title">File</div><div class="btn-group"><button class="btn" onclick="loadFile()">Load</button><button class="btn btn-accent" onclick="exportTrack()">Export</button><button class="btn" onclick="undoAll()">Undo</button></div><input type="file" id="file-input" accept=".json" onchange="handleFile(event)"></div>
  <div class="panel"><div class="panel-title">Image to Track</div>
    <div class="btn-group"><button class="btn btn-accent2" onclick="document.getElementById('img-input').click()">Upload Image</button></div>
    <input type="file" id="img-input" accept="image/*" onchange="handleImageUpload(event)" style="display:none">
    <div class="slider-group"><div class="slider-label"><span>Track scale</span><span id="v-imgscale">2000</span></div><input type="range" id="s-imgscale" min="500" max="8000" value="2000" step="100"></div>
    <div class="slider-group"><div class="slider-label"><span>Point count</span><span id="v-imgpts">200</span></div><input type="range" id="s-imgpts" min="50" max="500" value="200" step="10"></div>
    <div class="slider-group"><div class="slider-label"><span>Smoothing</span><span id="v-imgsmooth">3</span></div><input type="range" id="s-imgsmooth" min="0" max="10" value="3" step="1"></div>
    <div id="img-preview" style="display:none;margin-top:8px;border:1px solid var(--border);border-radius:6px;overflow:hidden;position:relative"><canvas id="img-canvas" style="width:100%;display:block"></canvas><div id="img-status" style="position:absolute;bottom:4px;left:6px;font-size:10px;color:var(--accent);font-family:'JetBrains Mono',monospace;background:rgba(0,0,0,.7);padding:2px 6px;border-radius:3px"></div></div>
  </div>
  <div class="panel"><div class="panel-title">Track Info</div><div class="stat-row"><span class="stat-label">Points</span><span class="stat-value" id="stat-points">--</span></div><div class="stat-row"><span class="stat-label">Control Points</span><span class="stat-value" id="stat-cp">--</span></div><div class="stat-row"><span class="stat-label">Length</span><span class="stat-value" id="stat-length">--</span></div><div class="stat-row"><span class="stat-label">Elevation</span><span class="stat-value" id="stat-elevation">--</span></div></div>
  <div class="panel"><div class="panel-title">Edit Mode</div>
    <div class="mode-tabs"><button class="mode-tab active" data-mode="select" onclick="setEditMode('select')">Select</button><button class="mode-tab" data-mode="control-points" onclick="setEditMode('control-points')">Control Pts</button><button class="mode-tab" data-mode="width" onclick="setEditMode('width')">Width</button></div>
    <div id="mode-select"><div class="slider-group"><div class="slider-label"><span>Smooth iterations</span><span id="smooth-iter-val">3</span></div><input type="range" id="smooth-iter" min="1" max="20" value="3"></div><div class="slider-group"><div class="slider-label"><span>Smooth strength</span><span id="smooth-str-val">0.5</span></div><input type="range" id="smooth-str" min="0.1" max="1" step="0.1" value="0.5"></div><div class="btn-group"><button class="btn btn-accent2" onclick="smoothSelection()">Smooth Sel</button><button class="btn" onclick="smoothAll()">Smooth All</button></div><div class="slider-group"><div class="slider-label"><span>Elevation offset</span><span id="elev-val">0</span></div><input type="range" id="elev-offset" min="-200" max="200" value="0" step="1"></div><button class="btn" onclick="applyElevation()">Apply Elevation</button></div>
    <div id="mode-control-points" style="display:none"><div class="slider-group"><div class="slider-label"><span>CP count</span><span id="cp-count-val">20</span></div><input type="range" id="cp-count" min="5" max="80" value="20" step="1"></div><div class="slider-group"><div class="slider-label"><span>Spline resolution</span><span id="spline-res-val">10</span></div><input type="range" id="spline-resolution" min="2" max="30" value="10" step="1"></div><div class="btn-group"><button class="btn btn-cp" onclick="extractControlPoints()">Extract</button><button class="btn btn-accent2" onclick="rebuildFromSpline()">Rebuild</button></div><label class="chk"><input type="checkbox" id="show-cp-handles" checked><span>Show drag handles</span></label><div id="cp-selected-panel" style="display:none"><div style="margin-top:6px"><div class="stat-row"><span class="stat-label">CP Index</span><span class="stat-value" id="cp-sel-idx">--</span></div><div class="cp-input-row"><label>X</label><input type="number" id="cp-x" step="1" onchange="updateCPFromInput()"></div><div class="cp-input-row"><label>Y</label><input type="number" id="cp-y" step="1" onchange="updateCPFromInput()"></div><div class="cp-input-row"><label>Z</label><input type="number" id="cp-z" step="1" onchange="updateCPFromInput()"></div><div class="btn-group" style="margin-top:6px"><button class="btn" onclick="insertCPAfter()">+ Insert</button><button class="btn btn-danger" onclick="deleteSelectedCP()">Delete</button></div></div></div></div>
    <div id="mode-width" style="display:none"><div class="slider-group"><div class="slider-label"><span>Default width</span><span id="default-width-val">30</span></div><input type="range" id="default-width" min="5" max="100" value="30" step="1" oninput="onDefaultWidthChange()"></div><div class="btn-group"><button class="btn btn-accent2" onclick="setAllWidths()">Set All Default</button><button class="btn btn-cp" onclick="extractControlPoints()">Extract</button></div><div id="width-cp-panel" style="display:none;margin-top:8px"><div class="stat-row"><span class="stat-label">CP Index</span><span class="stat-value" id="width-cp-idx">--</span></div><div class="slider-group"><div class="slider-label"><span>Width at CP</span><span id="cp-width-val">30</span></div><input type="range" id="cp-width" min="5" max="150" value="30" step="1" oninput="onCPWidthChange()"></div><div class="btn-group"><button class="btn" onclick="widthPreset(15)">15</button><button class="btn" onclick="widthPreset(30)">30</button><button class="btn" onclick="widthPreset(60)">60</button><button class="btn" onclick="widthPreset(100)">100</button></div></div><div class="width-viz"><canvas id="width-graph"></canvas></div><div class="btn-group" style="margin-top:6px"><button class="btn btn-accent" onclick="rebuildWithWidth()">Rebuild Width</button></div></div>
  </div>
  <div class="panel"><div class="panel-title">Loop</div><div class="slider-group"><div class="slider-label"><span>Blend distance</span><span id="loop-blend-val">200</span></div><input type="range" id="loop-blend" min="50" max="800" value="200" step="10"></div><div class="slider-group"><div class="slider-label"><span>Points</span><span id="loop-pts-val">40</span></div><input type="range" id="loop-pts" min="10" max="200" value="40" step="5"></div><div class="btn-group"><button class="btn btn-accent2" onclick="previewLoop()">Preview</button><button class="btn btn-accent" onclick="makeLoop()">Loop</button><button class="btn btn-danger" onclick="removeLoop()">Unloop</button></div></div>
</div>

<!-- ===== TERRAIN TAB ===== -->
<div class="tab-content" id="tab-terrain">
  <div class="panel"><div class="panel-title">Noise</div>
    <div class="slider-group"><div class="slider-label"><span>Amplitude</span><span id="v-amp">80</span></div><input type="range" id="s-amp" min="5" max="300" value="80" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Frequency</span><span id="v-freq">0.003</span></div><input type="range" id="s-freq" min="0.0005" max="0.02" value="0.003" step="0.0005"></div>
    <div class="slider-group"><div class="slider-label"><span>Octaves</span><span id="v-oct">4</span></div><input type="range" id="s-oct" min="1" max="8" value="4" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Lacunarity</span><span id="v-lac">2.0</span></div><input type="range" id="s-lac" min="1.2" max="4" value="2.0" step="0.1"></div>
    <div class="slider-group"><div class="slider-label"><span>Persistence</span><span id="v-per">0.5</span></div><input type="range" id="s-per" min="0.1" max="0.9" value="0.5" step="0.05"></div>
    <div class="slider-group"><div class="slider-label"><span>Seed</span><span id="v-seed">42</span></div><input type="range" id="s-seed" min="1" max="999" value="42" step="1"></div>
  </div>
  <div class="panel"><div class="panel-title">Grid</div>
    <div class="slider-group"><div class="slider-label"><span>Resolution</span><span id="v-res">100</span></div><input type="range" id="s-res" min="20" max="200" value="100" step="10"></div>
    <div class="slider-group"><div class="slider-label"><span>Extent</span><span id="v-ext">600</span></div><input type="range" id="s-ext" min="100" max="2000" value="600" step="50"></div>
  </div>
  <div class="panel"><div class="panel-title">Track Blend</div>
    <div class="slider-group"><div class="slider-label"><span>Clearance</span><span id="v-clear">60</span></div><input type="range" id="s-clear" min="10" max="300" value="60" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Blend radius</span><span id="v-blend">200</span></div><input type="range" id="s-blend" min="30" max="800" value="200" step="10"></div>
    <div class="slider-group"><div class="slider-label"><span>Depression</span><span id="v-depress">-20</span></div><input type="range" id="s-depress" min="-100" max="50" value="-20" step="5"></div>
  </div>
  <div class="panel"><div class="panel-title">Appearance</div>
    <div class="color-row"><input type="color" id="c-low" value="#2a4a2a"><span>Low</span></div>
    <div class="color-row"><input type="color" id="c-mid" value="#5a8a3a"><span>Mid</span></div>
    <div class="color-row"><input type="color" id="c-high" value="#8a7a5a"><span>High</span></div>
    <div class="color-row"><input type="color" id="c-peak" value="#ccccbb"><span>Peak</span></div>
    <label class="chk"><input type="checkbox" id="chk-wire"><span>Wireframe</span></label>
    <label class="chk"><input type="checkbox" id="chk-flat" checked><span>Flat shading</span></label>
  </div>
  <div class="panel"><div class="stat-row"><span class="stat-label">Vertices</span><span class="stat-value" id="st-verts">--</span></div><div class="stat-row"><span class="stat-label">Triangles</span><span class="stat-value" id="st-tris">--</span></div><div class="stat-row"><span class="stat-label">Gen time</span><span class="stat-value" id="st-time">--</span></div></div>
  <div class="panel"><div class="btn-group"><button class="btn btn-accent" onclick="generateTerrain()">Generate</button><button class="btn" onclick="clearTerrain()">Clear</button></div></div>
</div>

<!-- ===== GAMEPLAY TAB ===== -->
<div class="tab-content" id="tab-gameplay">
  <div class="panel"><div class="panel-title">Speed Pads</div>
    <div class="slider-group"><div class="slider-label"><span>Count</span><span id="v-pads">4</span></div><input type="range" id="s-pads" min="0" max="20" value="4" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Boost</span><span id="v-boost">1.5</span></div><input type="range" id="s-boost" min="1.1" max="3.0" value="1.5" step="0.1"></div>
    <div class="slider-group"><div class="slider-label"><span>Pad length</span><span id="v-padlen">30</span></div><input type="range" id="s-padlen" min="10" max="80" value="30" step="5"></div>
    <label class="chk"><input type="checkbox" id="chk-pads" checked onchange="toggleSpeedPads()"><span>Show pads</span></label>
    <div class="btn-group"><button class="btn btn-accent2" onclick="placeSpeedPads()">Place Pads</button></div>
  </div>
  <div class="panel"><div class="panel-title">AI Cars</div>
    <div class="slider-group"><div class="slider-label"><span>Count</span><span id="v-aicount">6</span></div><input type="range" id="s-aicount" min="0" max="20" value="6" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Spacing</span><span id="v-aispacing">40</span></div><input type="range" id="s-aispacing" min="10" max="120" value="40" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Grid cols</span><span id="v-aigrid">2</span></div><input type="range" id="s-aigrid" min="1" max="4" value="2" step="1"></div>
    <div class="slider-group"><div class="slider-label"><span>Start offset</span><span id="v-aioffset">0</span></div><input type="range" id="s-aioffset" min="0" max="200" value="0" step="1"></div>
    <label class="chk"><input type="checkbox" id="chk-ai" checked onchange="toggleAICars()"><span>Show cars</span></label>
    <div class="btn-group"><button class="btn btn-accent2" onclick="placeAICars()">Place Cars</button></div>
  </div>
  <div class="panel"><div class="panel-title">Scenery</div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>Theme</span></div>
      <select id="scenery-theme" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
        <option value="neon">Neon City</option>
        <option value="canyon">Canyon</option>
        <option value="scifi">Sci-Fi</option>
      </select>
    </div>
    <div class="slider-group"><div class="slider-label"><span>Density</span><span id="v-scenerydensity">1.0</span></div><input type="range" id="s-scenerydensity" min="0.2" max="3" value="1" step="0.1"></div>
    <div class="slider-group"><div class="slider-label"><span>Building height</span><span id="v-sceneryheight">60</span></div><input type="range" id="s-sceneryheight" min="10" max="200" value="60" step="5"></div>
    <div class="slider-group"><div class="slider-label"><span>Setback</span><span id="v-scenerysetback">40</span></div><input type="range" id="s-scenerysetback" min="20" max="120" value="40" step="5"></div>
    <label class="chk"><input type="checkbox" id="chk-barriers" checked><span>Barriers</span></label>
    <label class="chk"><input type="checkbox" id="chk-buildings" checked><span>Buildings</span></label>
    <label class="chk"><input type="checkbox" id="chk-arches" checked><span>Arches</span></label>
    <label class="chk"><input type="checkbox" id="chk-lights" checked><span>Streetlights</span></label>
    <label class="chk"><input type="checkbox" id="chk-scenery" checked onchange="toggleScenery()"><span>Show scenery</span></label>
    <div class="btn-group"><button class="btn btn-accent2" onclick="generateScenery()">Generate</button><button class="btn" onclick="clearScenery()">Clear</button></div>
  </div>
  <div class="panel"><div class="btn-group"><button class="btn btn-accent" onclick="exportAll()">Export Scene</button></div></div>
</div>

<!-- ===== PLAY TAB ===== -->
<div class="tab-content" id="tab-play">
  <div class="panel"><div class="panel-title">Horizon Drive</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:8px">
      Race your track inline with the accel-driv engine. Press <span style="color:var(--accent)">ESC</span> or the exit button to return to the editor.
    </div>
    <div class="btn-group"><button class="btn btn-accent" onclick="startGame()" style="font-size:16px;padding:14px 24px">PLAY</button></div>
  </div>
  <div class="panel"><div class="panel-title">Track Info</div>
    <div class="stat-row"><span class="stat-label">Points</span><span class="stat-value" id="play-pts">--</span></div>
    <div class="stat-row"><span class="stat-label">Length</span><span class="stat-value" id="play-len">--</span></div>
    <div class="stat-row"><span class="stat-label">Closed loop</span><span class="stat-value" id="play-loop">--</span></div>
  </div>
  <div class="panel"><div class="panel-title">Game Controls</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.8">
      <div>Auto-accelerate (always moving)</div>
      <div><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">A</kbd><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">D</kbd> / <kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">left</kbd><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">right</kbd> Steer</div>
      <div><kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">S</kbd> / <kbd style="background:var(--surface2);border:1px solid var(--border);padding:1px 5px;border-radius:3px;font-size:10px">down</kbd> Brake</div>
      <div style="margin-top:4px;color:var(--accent2)">Tilt to steer on mobile</div>
      <div style="color:var(--accent)">Race to the end against 5 AI opponents</div>
    </div>
  </div>
</div>

<!-- ===== SPLAT TAB ===== -->
<div class="tab-content" id="tab-splat">
  <div class="panel"><div class="panel-title">1. Flythrough &rarr; Stylize</div>
    <div class="slider-group" style="margin-bottom:6px;display:none" id="apikey-runway-row">
      <div class="slider-label"><span>Runway API Key</span></div>
      <input type="password" id="runway-apikey" placeholder="rw_xxxxxxxx" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
    </div>
    <div class="slider-group" style="margin-bottom:6px;display:none" id="apikey-decart-row">
      <div class="slider-label"><span>Decart API Key</span></div>
      <input type="password" id="decart-apikey" placeholder="decart_xxxxxxxx" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
    </div>
    <div style="border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px">
      <div style="color:var(--accent);font-weight:600;font-size:12px;margin-bottom:6px">Stage 1 &mdash; Flythrough Video</div>
      <div style="font-size:10px;color:var(--text-dim);margin-bottom:6px">Camera follows the track spline, baking geometry into frames.</div>
      <div class="slider-group">
        <div class="slider-label"><span>Duration (s)</span><span id="v-flydur">10</span></div>
        <input type="range" id="s-flydur" min="2" max="60" value="10" step="1">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Camera height</span><span id="v-flyht">8</span></div>
        <input type="range" id="s-flyht" min="2" max="40" value="8" step="1">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Resolution</span></div>
        <select id="fly-res" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="720" selected>1280 x 720</option>
          <option value="1080">1920 x 1080</option>
        </select>
      </div>
      <div class="btn-group">
        <button class="btn btn-accent2" onclick="recordFlythrough()" id="fly-rec-btn">Record Flythrough</button>
        <button class="btn" onclick="downloadFlythrough()">Download</button>
      </div>
      <div id="fly-progress" style="display:none;font-size:11px;color:var(--accent2);margin-top:4px"></div>
      <video id="fly-video" style="display:none;width:100%;border-radius:6px;margin-top:8px;border:1px solid var(--border);background:#000" controls muted></video>
      <div id="fly-debug" style="display:none;margin-top:4px;padding:6px;background:var(--surface2);border:1px solid var(--border);border-radius:4px;font-family:monospace;font-size:10px;color:var(--text-dim);line-height:1.6;white-space:pre-wrap"></div>
    </div>
    <div style="border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px">
      <div style="color:var(--accent);font-weight:600;font-size:12px;margin-bottom:6px">Stage 2 &mdash; AI Stylization</div>
      <div id="stylize-desc" style="display:none"></div>
      <div class="slider-group">
        <div class="slider-label"><span>Provider</span></div>
        <select id="stylize-provider" onchange="onProviderChange()" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="runway" selected>Runway</option>
          <option value="decart">Decart</option>
        </select>
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Style prompt</span></div>
        <textarea id="runway-prompt" rows="2" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:6px 8px;border-radius:4px;font-size:11px;resize:vertical;font-family:system-ui">cinematic flythrough of a futuristic racing track through a detailed sci-fi cityscape environment, towering neon buildings on both sides, volumetric fog, reflective wet ground, dramatic sky with clouds, photorealistic</textarea>
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Model</span></div>
        <select id="runway-model" onchange="onModelChange()" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="gen4_turbo" selected>Gen-4 Turbo</option>
          <option value="gen4_aleph">Gen-4 Aleph (video-to-video)</option>
          <option value="gen3a_turbo">Gen-3 Alpha Turbo</option>
        </select>
      </div>
      <div class="slider-group" id="stylize-duration-row">
        <div class="slider-label"><span>Segment length</span></div>
        <select id="runway-duration" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="5" id="dur-opt-5">5 seconds</option>
          <option value="10" id="dur-opt-10" selected>10 seconds (recommended)</option>
        </select>
      </div>
      <div class="slider-group" id="decart-resolution-row" style="display:none">
        <div class="slider-label"><span>Resolution</span></div>
        <select id="decart-resolution" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="720p" selected>720p</option>
          <option value="480p">480p</option>
        </select>
      </div>
      <div class="btn-group">
        <button class="btn btn-accent2" onclick="runStylize()" id="runway-btn">Stylize with Runway</button>
      </div>
      <div id="runway-progress" style="display:none;font-size:11px;color:var(--accent2);margin-top:4px"></div>
      <div id="runway-segments" style="display:none;margin-top:6px"></div>
      <video id="runway-video" style="display:none;width:100%;border-radius:6px;margin-top:8px;border:1px solid var(--border);background:#000" controls></video>
      <div id="runway-download-bar" style="display:none;margin-top:4px" class="btn-group"></div>
      <div id="stylize-debug" style="display:none;margin-top:4px;padding:6px;background:var(--surface2);border:1px solid var(--border);border-radius:4px;font-family:monospace;font-size:10px;color:var(--text-dim);line-height:1.6;white-space:pre-wrap"></div>
      <div id="runway-pending" style="display:none;margin-top:6px;padding:8px;background:var(--surface2);border:1px solid var(--accent2);border-radius:4px;font-size:11px">
        <div style="color:var(--accent2);margin-bottom:4px" id="pending-title">Pending generation found</div>
        <div id="runway-pending-info" style="color:var(--text-dim);margin-bottom:6px"></div>
        <div class="btn-group"><button class="btn btn-accent2" onclick="checkPendingOperation()">Check Status</button><button class="btn" onclick="clearAllPending()">Dismiss</button></div>
      </div>
    </div>
    <div id="pipeline-progress" style="display:none;font-size:11px;color:var(--accent);margin-top:4px"></div>
  </div>

  <div class="panel"><div class="panel-title">2. Video &rarr; Splat Training</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:6px">
      Extract frames from a stylized video, pair with <span style="color:var(--accent2)">known camera poses</span>, and train 3DGS on <span style="color:var(--accent2)">RunPod</span> — no SfM needed.
    </div>
    <div id="v2s-pose-info" style="font-size:10px;color:var(--text-dim);margin-bottom:8px;padding:4px 8px;background:var(--surface2);border-radius:4px;font-family:'JetBrains Mono',monospace">No flythrough poses recorded yet</div>
    <div style="border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px">
      <div style="color:var(--accent);font-weight:600;font-size:11px;margin-bottom:6px">Stylized Video Input</div>
      <div class="btn-group" style="margin-bottom:4px">
        <button class="btn" onclick="document.getElementById('v2s-video-input').click()" style="font-size:10px">Choose Stylized Video</button>
        <button class="btn" onclick="useStylizedVideo()" style="font-size:10px" id="btn-use-stylized" title="Use the video from Stage 2 stylization">Use Stage 2 Output</button>
        <span id="v2s-video-name" style="font-size:10px;color:var(--text-dim);align-self:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px"></span>
      </div>
      <input type="file" id="v2s-video-input" accept="video/mp4,video/webm,.mp4,.webm" style="display:none">
      <div class="slider-group">
        <div class="slider-label"><span>Frame sampling</span></div>
        <select id="v2s-sampling" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="match" selected>Match all flythrough poses</option>
          <option value="2fps">2 fps (every 0.5s)</option>
          <option value="5fps">5 fps (every 0.2s)</option>
          <option value="10fps">10 fps (every 0.1s)</option>
        </select>
      </div>
    </div>
    <div style="border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px">
      <div style="color:var(--accent);font-weight:600;font-size:11px;margin-bottom:6px">RunPod 3DGS Training</div>
      <div class="slider-group" style="margin-bottom:6px">
        <div class="slider-label"><span>Mode</span></div>
        <select id="runpod-mode" onchange="toggleRunpodMode()" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
          <option value="serverless" selected>Serverless (recommended)</option>
          <option value="pod">Pod (manual)</option>
        </select>
      </div>
      <!-- Serverless config -->
      <div id="runpod-serverless-cfg">
        <div id="sls-endpoint-info" style="font-size:10px;color:var(--text-dim);margin-bottom:6px;padding:4px 8px;background:var(--surface2);border-radius:4px;font-family:'JetBrains Mono',monospace">Endpoint: auto-created on first run</div>
        <div class="slider-group">
          <div class="slider-label"><span>Training iterations</span><span id="v-serverless-iters">7000</span></div>
          <input type="range" id="s-serverless-iters" min="1000" max="60000" value="7000" step="1000">
        </div>
        <div class="slider-group">
          <div class="slider-label"><span>Max frames</span><span id="v-serverless-maxframes">150</span></div>
          <input type="range" id="s-serverless-maxframes" min="20" max="500" value="150" step="10">
        </div>
        <div class="btn-group">
          <button class="btn btn-accent" onclick="runpodServerlessTrain()" id="btn-serverless-train" style="width:100%">Train (Serverless)</button>
        </div>
        <div class="btn-group" style="margin-top:4px">
          <button class="btn" onclick="serverlessCheckStatus()" style="font-size:10px">Check Status</button>
          <button class="btn btn-danger" onclick="serverlessCancel()" style="font-size:10px">Cancel Job</button>
          <button class="btn" onclick="serverlessDeleteEndpoint()" style="font-size:10px" title="Delete cached serverless endpoint">Reset Endpoint</button>
          <button class="btn" onclick="extractStylizedTraining()" style="font-size:10px" id="btn-extract-stylized" title="Manual: download training ZIP">Export ZIP</button>
        </div>
      </div>
      <!-- Pod config (hidden by default) -->
      <div id="runpod-pod-cfg" style="display:none">
        <div class="slider-group" style="margin-bottom:6px;display:none" id="apikey-runpod-row">
          <div class="slider-label"><span>RunPod API Key</span></div>
          <input type="password" id="runpod-apikey" placeholder="rpa_xxxxxxxx" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
        </div>
        <div class="slider-group">
          <div class="slider-label"><span>GPU</span></div>
          <select id="runpod-gpu" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px">
            <option value="NVIDIA GeForce RTX 4090" selected>RTX 4090 (24GB, ~$0.40/hr)</option>
            <option value="NVIDIA GeForce RTX 3090">RTX 3090 (24GB, ~$0.25/hr)</option>
            <option value="NVIDIA RTX A5000">RTX A5000 (24GB, ~$0.25/hr)</option>
          </select>
        </div>
        <div class="slider-group">
          <div class="slider-label"><span>Training iterations</span><span id="v-runpod-iters">30000</span></div>
          <input type="range" id="s-runpod-iters" min="7000" max="60000" value="30000" step="1000">
        </div>
        <div class="btn-group">
          <button class="btn btn-accent" onclick="runpodTrain()" id="btn-runpod-train" style="width:100%">Train on RunPod</button>
        </div>
        <div class="btn-group" style="margin-top:4px">
          <button class="btn" onclick="runpodCheckStatus()" style="font-size:10px">Check Status</button>
          <button class="btn btn-danger" onclick="runpodTerminate()" style="font-size:10px">Terminate Pod</button>
          <button class="btn" onclick="extractStylizedTraining()" style="font-size:10px" title="Manual: download training ZIP">Export ZIP</button>
        </div>
      </div>
    </div>
    <div id="v2s-progress" style="display:none;font-size:11px;color:var(--accent2);margin-top:4px;line-height:1.6"></div>
    <div id="runpod-status" style="display:none;margin-top:6px;padding:6px;background:var(--surface2);border:1px solid var(--border);border-radius:4px;font-family:monospace;font-size:10px;color:var(--text-dim);line-height:1.6;white-space:pre-wrap"></div>
    <details id="sls-api-log-wrap" style="margin-top:6px">
      <summary style="cursor:pointer;font-size:10px;color:var(--text-dim);user-select:none">API Response Log <span onclick="event.stopPropagation();document.getElementById('sls-api-log').textContent='';toast('Log cleared')" style="margin-left:8px;color:var(--accent);cursor:pointer">[clear]</span></summary>
      <div id="sls-api-log" style="margin-top:4px;padding:6px;background:#0d0d0d;border:1px solid var(--border);border-radius:4px;font-family:'JetBrains Mono',monospace;font-size:9px;color:#8f8;line-height:1.5;white-space:pre-wrap;max-height:300px;overflow-y:auto">Waiting for API calls...
</div>
    </details>
  </div>

  <div class="panel"><div class="panel-title">3. Convert Splats</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:6px">
      Convert to <span style="color:var(--accent2)">.sog</span> format for optimal web delivery (~95% smaller than raw PLY).
    </div>
    <div class="btn-group">
      <button class="btn" onclick="window.open('https://supersplat.io','_blank')">SuperSplat (SPZ to SOG)</button>
    </div>
  </div>

  <div class="panel"><div class="panel-title">4. Preview and Load Splat</div>
    <div style="font-size:11px;color:var(--text-dim);line-height:1.6;margin-bottom:8px">
      Load a splat file into the 3D viewport via <span style="color:var(--accent2)">Spark.js</span>. Supports <b>.spz</b>, <b>.ply</b>, <b>.splat</b>, <b>.sog</b>.
    </div>
    <div class="slider-group" style="margin-bottom:6px">
      <div class="slider-label"><span>Splat URL</span></div>
      <input type="text" id="splat-url" placeholder="https://... .spz / .ply / .sog" style="width:100%;background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace">
    </div>
    <div class="btn-group">
      <button class="btn" onclick="loadSplatFromURL()">Load from URL</button>
      <button class="btn" onclick="loadSplatFromFile()">Load File</button>
      <button class="btn" onclick="removeSplat()">Remove</button>
    </div>
    <input type="file" id="splat-file-input" accept=".spz,.ply,.splat,.sog,.ksplat" style="display:none">
    <div class="slider-group"><div class="slider-label"><span>Splat opacity</span><span id="v-splatopacity">1.0</span></div><input type="range" id="s-splatopacity" min="0" max="1" value="1" step="0.05"></div>
    <div class="slider-group"><div class="slider-label"><span>Splat scale</span><span id="v-splatscale">1.0</span></div><input type="range" id="s-splatscale" min="0.01" max="100" value="1" step="0.1"></div>
    <div style="margin-top:8px;border-top:1px solid var(--border);padding-top:8px">
      <div class="slider-label" style="margin-bottom:4px"><span style="color:var(--accent)">Transform</span></div>
      <div class="slider-group"><div class="slider-label"><span>Position X</span><span id="v-splatpx">0</span></div><input type="range" id="s-splatpx" min="-500" max="500" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Position Y</span><span id="v-splatpy">0</span></div><input type="range" id="s-splatpy" min="-500" max="500" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Position Z</span><span id="v-splatpz">0</span></div><input type="range" id="s-splatpz" min="-500" max="500" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Rotation X</span><span id="v-splatrx">0</span></div><input type="range" id="s-splatrx" min="-180" max="180" value="0" step="1"></div>
      <div class="slider-group"><div class="slider-label"><span>Rotation Y</span><span id="v-splatry">0</span></div><input type="range" id="s-splatry" min="-180" max="180" value="0" step="1"></div>
    </div>
    <div class="btn-group" style="margin-top:6px">
      <button class="btn btn-accent2" onclick="splatBackdropPreset()">Use as Backdrop</button>
      <button class="btn" onclick="splatResetTransform()">Reset Transform</button>
    </div>
    <div id="splat-info" style="font-size:10px;color:var(--text-dim);margin-top:4px"></div>
  </div>
</div>

  </div>

  <div id="viewport">
    <div id="mobile-toolbar"><button class="mtb-btn" onclick="toggleDrawer()">&#9776;</button><button class="mtb-btn" onclick="fitView()">&#8862;</button><button class="mtb-btn" onclick="loadFile()">&#128194;</button><button class="mtb-btn" onclick="exportTrack()">&#128190;</button><div style="flex:1"></div><button class="mtb-btn" onclick="undoAll()">&#8617;</button></div>
    <div id="help-overlay"><kbd>LMB</kbd> orbit &middot; <kbd>RMB</kbd> pan &middot; <kbd>Scroll</kbd> zoom &middot; <kbd>F</kbd> fit<br><kbd>Shift+Click</kbd> range &middot; <kbd>Esc</kbd> deselect</div>
    <div id="game-overlay" style="display:none;position:absolute;top:0;left:0;right:0;bottom:0;z-index:100;background:#000">
      <iframe id="game-iframe" style="width:100%;height:100%;border:none" allow="accelerometer;gyroscope"></iframe>
      <button id="game-exit-btn" onclick="stopGame()" style="position:absolute;top:12px;left:12px;z-index:110;background:rgba(0,0,0,.7);color:#ff6ec7;border:2px solid #ff6ec7;padding:8px 18px;border-radius:8px;font:700 14px system-ui;cursor:pointer;backdrop-filter:blur(4px)">EXIT</button>
    </div>
  </div>
</div>
<div id="toast"></div>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/"}}</script>
<script type="module">
import * as THREE from 'three';
THREE.ColorManagement.enabled=false;
// ============================================================
// SHARED DATA
// ============================================================
const ET=[[400,-250,-400,0,1,0],[415.4,-250,-400.1,0,1,0],[435.9,-249.9,-400.5,0,1,0],[460.4,-249.9,-400.9,0,1,0],[487.5,-249.8,-401.2,0,1,0],[516.2,-249.8,-401.5,0,1,0],[545.3,-249.8,-401.4,0,1,0],[573.6,-249.9,-401,0,1,0],[600,-250,-400,0,1,0],[625,-250.2,-398.6,-0.0011,0.9998,0.0174],[650,-250.6,-396.9,-0.0026,0.9994,0.0348],[675,-250.9,-394.8,-0.0046,0.9986,0.0521],[700,-251.4,-392.5,-0.0069,0.9976,0.0694],[725,-251.8,-389.8,-0.0097,0.9962,0.0866],[750,-252.2,-386.9,-0.013,0.9945,0.1037],[775,-252.7,-383.6,-0.0166,0.9925,0.1207],[800,-253,-380,-0.0223,0.9903,0.1374],[825,-253.3,-375.5,-0.0296,0.989,0.1448],[850,-253.7,-369.8,-0.0368,0.9877,0.1521],[875,-254,-363.4,-0.0412,0.9863,0.1598],[900,-254.3,-356.9,-0.0425,0.9848,0.1684],[925,-254.6,-350.8,-0.0403,0.9833,0.1777],[950,-254.8,-345.5,-0.0337,0.9816,0.1878],[975,-254.9,-341.8,-0.022,0.9799,0.1982],[1000,-255,-340,-0.0058,0.9781,0.2078],[1025,-254.9,-340.4,0.0103,0.9799,0.1991],[1050,-254.8,-342.6,0.0217,0.9816,0.1896],[1075,-254.6,-346.1,0.029,0.9833,0.1799],[1100,-254.3,-350.6,0.0326,0.9848,0.1706],[1125,-254,-355.7,0.0331,0.9863,0.1617],[1150,-253.7,-360.9,0.031,0.9877,0.1533],[1175,-253.3,-365.8,0.0266,0.989,0.1454],[1200,-253,-370,0.0225,0.9903,0.1373],[1225,-252.7,-374,0.0197,0.9925,0.1203],[1250,-252.2,-378.2,0.0177,0.9945,0.103],[1275,-251.8,-382.6,0.0149,0.9962,0.0859],[1300,-251.4,-386.9,0.0115,0.9976,0.0688],[1325,-250.9,-390.9,0.008,0.9986,0.0517],[1350,-250.6,-394.6,0.0047,0.9994,0.0346],[1375,-250.2,-397.7,0.0019,0.9998,0.0174],[1400,-250,-400,0,1,0],[1425,-249.8,-401.6,0,1,0],[1450,-249.6,-402.6,0,1,0],[1475,-249.3,-403.1,0,1,0],[1500,-249.2,-403.1,0,1,0],[1525,-249.1,-402.8,0,1,0],[1550,-249.2,-402.1,0,1,0],[1575,-249.5,-401.2,0,1,0],[1600,-250,-400,0,1,0],[1625.3,-250.7,-398.7,-0.0023,0.999,0.0436],[1651.2,-251.7,-397.3,-0.005,0.9962,0.087],[1677.2,-252.8,-395.7,-0.009,0.9914,0.1302],[1703.1,-254.1,-393.7,-0.0148,0.9848,0.173],[1728.7,-255.4,-391.3,-0.0234,0.9763,0.2152],[1753.5,-256.9,-388.3,-0.0356,0.9659,0.2564],[1777.4,-258.4,-384.6,-0.0527,0.9537,0.296],[1800,-260,-380,-0.0747,0.9397,0.3338],[1821.5,-261.7,-374.7,-0.0939,0.9312,0.3522],[1842.2,-263.5,-368.7,-0.1137,0.9222,0.3696],[1862.1,-265.5,-362.2,-0.1357,0.9127,0.3855],[1881.3,-267.5,-355,-0.1599,0.9026,0.3997],[1899.6,-269.5,-347.2,-0.1862,0.892,0.4119],[1917.2,-271.5,-338.7,-0.2147,0.8809,0.4218],[1934,-273.3,-329.7,-0.2453,0.8693,0.4292],[1950,-275,-320,-0.2781,0.8572,0.4335],[1965.4,-276.6,-309.6,-0.301,0.8572,0.4179],[1980.2,-278.2,-298.3,-0.323,0.8572,0.4012],[1994.2,-279.8,-286.3,-0.3439,0.8572,0.3834],[2007.5,-281.2,-273.7,-0.3642,0.8572,0.3642],[2019.8,-282.6,-260.7,-0.3841,0.8572,0.3432],[2031.1,-283.7,-247.3,-0.4038,0.8572,0.3197],[2041.2,-284.5,-233.7,-0.4236,0.8572,0.2929],[2050,-285,-220,-0.4437,0.8572,0.2615],[2057.4,-285.1,-206.2,-0.463,0.8572,0.2257],[2063.6,-284.8,-192.1,-0.4795,0.8572,0.1881],[2068.6,-284.2,-177.8,-0.4923,0.8572,0.1513],[2072.5,-283.4,-163.1,-0.5016,0.8572,0.1168],[2075.5,-282.5,-148.1,-0.5079,0.8572,0.0857],[2077.7,-281.6,-132.6,-0.5116,0.8572,0.059],[2079.1,-280.7,-116.6,-0.5137,0.8572,0.037],[2080,-280,-100,-0.5148,0.8572,0.0158],[2080.2,-279.4,-82.5,-0.5094,0.8605,-0.0078],[2079.5,-278.7,-64.1,-0.5029,0.8638,-0.0301],[2077.9,-278.1,-45.1,-0.4957,0.8671,-0.0493],[2075.6,-277.5,-25.6,-0.4879,0.8704,-0.0663],[2072.6,-276.9,-6.1,-0.4798,0.8736,-0.082],[2069,-276.2,13.2,-0.471,0.8767,-0.0973],[2064.8,-275.6,32,-0.4617,0.8799,-0.1127],[2060,-275,50,-0.4514,0.8829,-0.1289],[2054.7,-274.4,67.3,-0.4404,0.886,-0.1451],[2048.8,-273.7,84.1,-0.4288,0.889,-0.1606],[2042.2,-273.1,100.7,-0.4168,0.892,-0.1751],[2035,-272.5,116.9,-0.4045,0.8949,-0.1884],[2027.2,-271.9,132.9,-0.3921,0.8978,-0.2004],[2018.8,-271.2,148.7,-0.3798,0.9007,-0.211],[2009.7,-270.6,164.4,-0.3677,0.9035,-0.2201],[2000,-270,180,-0.3557,0.9063,-0.2282],[1989.6,-269.4,195.8,-0.3403,0.9109,-0.2336],[1978.3,-268.8,211.6,-0.3249,0.9153,-0.238],[1966.3,-268.2,227.5,-0.3098,0.9197,-0.2414],[1953.8,-267.6,243.1,-0.2947,0.9239,-0.2442],[1940.7,-267,258.4,-0.2794,0.928,-0.2465],[1927.3,-266.4,273,-0.2636,0.932,-0.2487],[1913.7,-265.7,287,-0.2473,0.9359,-0.2509],[1900,-265,300,-0.2317,0.9397,-0.2516],[1886.4,-264.2,312.2,-0.2115,0.9469,-0.2421],[1872.8,-263.4,323.8,-0.1914,0.9537,-0.2319],[1859.1,-262.6,334.7,-0.1699,0.96,-0.2224],[1845,-261.7,345,-0.1475,0.9659,-0.2127],[1830.3,-260.8,354.7,-0.125,0.9713,-0.2021],[1814.7,-259.9,363.8,-0.1032,0.9763,-0.1903],[1798,-258.9,372.2,-0.0828,0.9808,-0.1767],[1780,-258,380,-0.064,0.9848,-0.1614],[1760.5,-257,387.1,-0.0476,0.9884,-0.1445],[1739.7,-255.9,393.3,-0.0346,0.9914,-0.1258],[1717.8,-254.7,398.8,-0.0248,0.9941,-0.106],[1695,-253.6,403.8,-0.0174,0.9962,-0.0854],[1671.6,-252.5,408.2,-0.0117,0.9979,-0.0643],[1647.8,-251.5,412.3,-0.0072,0.999,-0.043],[1623.9,-250.6,416.2,-0.0034,0.9998,-0.0215],[1600,-250,420,0,1,0],[1576.6,-249.6,423.5,0,1,0],[1553.8,-249.4,426.6,0,1,0],[1530.9,-249.4,429.4,0,1,0],[1507.5,-249.5,431.9,0,1,0],[1483.2,-249.6,434.1,0,1,0],[1457.5,-249.8,436.2,0,1,0],[1429.9,-249.9,438.1,0,1,0],[1400,-250,440,0,1,0],[1367.3,-250,441.9,0,1,0],[1332,-250,443.7,0,1,0],[1294.8,-250,445.4,0,1,0],[1256.3,-250,446.9,0,1,0],[1216.9,-250,448.2,0,1,0],[1177.3,-250,449.1,0,1,0],[1138.2,-250,449.8,0,1,0],[1100,-250,450,0,1,0],[1061.8,-250,449.8,0,1,0],[1022.7,-250,449.1,0,1,0],[983.1,-250,448.2,0,1,0],[943.8,-250,446.9,0,1,0],[905.2,-250,445.4,0,1,0],[868,-250,443.7,0,1,0],[832.7,-250,441.9,0,1,0],[800,-250,440,0,1,0],[770.2,-249.9,438.1,0,1,0],[743,-249.8,436.2,0,1,0],[717.7,-249.6,434.1,0,1,0],[693.8,-249.5,431.9,0,1,0],[670.6,-249.4,429.4,0,1,0],[647.7,-249.4,426.6,0,1,0],[624.3,-249.6,423.5,0,1,0],[600,-250,420,0,1,0],[574.7,-250.6,416.2,0.0048,0.9995,-0.0324],[548.8,-251.4,412.3,0.01,0.9979,-0.0646],[522.8,-252.3,408.2,0.016,0.9952,-0.0967],[496.9,-253.4,403.8,0.0235,0.9914,-0.1284],[471.3,-254.5,398.8,0.0331,0.9866,-0.1595],[446.5,-255.7,393.3,0.0458,0.9808,-0.1896],[422.6,-256.8,387.1,0.0624,0.9739,-0.2183],[400,-258,380,0.0827,0.9659,-0.2453],[378.5,-259.1,372.2,0.1006,0.96,-0.2611],[357.8,-260.3,363.8,0.119,0.9537,-0.2762],[337.9,-261.5,354.7,0.1391,0.9469,-0.2898],[318.8,-262.7,345,0.161,0.9397,-0.3018],[300.4,-264,334.7,0.1845,0.932,-0.312],[282.8,-265.3,323.8,0.2096,0.9239,-0.3202],[266,-266.6,312.2,0.2361,0.9153,-0.3263],[250,-268,300,0.2653,0.9063,-0.329],[234.8,-269.5,287,0.292,0.9007,-0.3217],[220.3,-271,273,0.3182,0.8949,-0.3128],[206.6,-272.7,258.4,0.3424,0.889,-0.304],[193.8,-274.3,243.1,0.3649,0.8829,-0.2954],[181.6,-275.9,227.5,0.3858,0.8767,-0.2872],[170.3,-277.4,211.6,0.4054,0.8704,-0.2794],[159.8,-278.8,195.8,0.4239,0.8638,-0.2722],[150,-280,180,0.4422,0.8572,-0.2641],[141,-281,164.4,0.4515,0.8572,-0.2477],[132.8,-282,148.7,0.4614,0.8572,-0.2288],[125.4,-282.8,132.9,0.471,0.8572,-0.2083],[118.8,-283.6,116.9,0.4801,0.8572,-0.1864],[112.9,-284.2,100.7,0.4885,0.8572,-0.1632],[107.8,-284.6,84.1,0.4959,0.8572,-0.1393],[103.5,-284.9,67.3,0.5021,0.8572,-0.1149],[100,-285,50,0.5073,0.8572,-0.0889],[97.3,-284.9,32,0.5113,0.8572,-0.0619],[95.5,-284.5,13.2,0.5137,0.8572,-0.0371],[94.6,-283.9,-6.1,0.5148,0.8572,-0.0155],[94.4,-283.1,-25.6,0.515,0.8572,0.0039],[94.9,-282.3,-45.1,0.5146,0.8572,0.0219],[96,-281.5,-64.1,0.5135,0.8572,0.0393],[97.7,-280.7,-82.5,0.5119,0.8572,0.0569],[100,-280,-100,0.5094,0.8572,0.0759],[102.8,-279.4,-116.6,0.5003,0.8605,0.096],[106.3,-278.9,-132.6,0.4901,0.8638,0.1167],[110.3,-278.3,-148.1,0.4789,0.8671,0.1372],[115,-277.8,-163.1,0.4667,0.8704,0.1571],[120.3,-277.2,-177.8,0.4537,0.8736,0.1761],[126.3,-276.6,-192.1,0.4402,0.8767,0.1939],[132.8,-275.9,-206.2,0.4263,0.8799,0.2101],[140,-275,-220,0.4126,0.8829,0.224],[147.7,-274,-233.7,0.3909,0.891,0.2309],[156,-272.9,-247.1,0.3687,0.8988,0.2372],[164.9,-271.6,-260.3,0.3453,0.9063,0.2437],[174.4,-270.3,-273.1,0.3208,0.9135,0.25],[184.6,-269,-285.6,0.2954,0.9205,0.2558],[195.5,-267.6,-297.6,0.2691,0.9272,0.2606],[207.3,-266.3,-309.1,0.2422,0.9336,0.2641],[220,-265,-320,0.2129,0.9397,0.2677],[234.4,-263.7,-330.6,0.1786,0.9483,0.2623],[250.9,-262.4,-341,0.1503,0.9563,0.2508],[268.6,-261,-351.1,0.1278,0.9636,0.2347],[286.9,-259.7,-360.6,0.1093,0.9703,0.2158],[304.9,-258.4,-369.5,0.0935,0.9763,0.1952],[322,-257.1,-377.4,0.0797,0.9816,0.1734],[337.2,-256,-384.3,0.0675,0.9863,0.1506],[350,-255,-390,0.0545,0.9903,0.1281],[360.4,-254.1,-394.2,0.0413,0.9925,0.1147],[369.3,-253.3,-397,0.0271,0.9945,0.101],[376.8,-252.5,-398.6,0.015,0.9962,0.0858],[383.1,-251.9,-399.4,0.0062,0.9976,0.0695],[388.4,-251.3,-399.6,0.0013,0.9986,0.0523],[392.9,-250.8,-399.6,0.0001,0.9994,0.0349],[396.7,-250.4,-399.6,0.001,0.9998,0.0174],[400,-250,-400,0,1,0]];

let trackData=[],origData=null,selA=-1,selB=-1,loopAdded=0,editMode='select';
let cps=[],selCP=-1,dragCP=false,cpMeshes=[];
let defWidth=30,isMobile=window.innerWidth<=768;
let scene,cam,rndr,tLine,tRibbon,ptCloud,loopLine,selHL,cpGrp,splineLine,wRibbon,ray,mouse,gPlane,laneLineGroup;
let cScene,cCam;
let orb={rot:false,pan:false,lx:0,ly:0,tgt:new THREE.Vector3(600,0,0),phi:Math.PI/4,theta:Math.PI/4,dist:1500};
let tch={mode:null,last:null,initDist:0,tapTime:0,tapPos:null,moved:false};
let drawerOpen=false;
let terrainMesh=null,terrainWire=null;
let speedPadGroup=null,speedPadData=[];
let aiCarGroup=null,aiCarData=[];
let trackRibbon=null;
let sceneryGroup=null;
let activeTab='track';

function norm(v){var l=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])||1;return[v[0]/l,v[1]/l,v[2]/l]}
function crs(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}
function sub(a,b){return[a[0]-b[0],a[1]-b[1],a[2]-b[2]]}
function dst(a,b){return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2)}
function toast(m){var e=document.getElementById('toast');e.textContent=m;e.classList.add('show');setTimeout(function(){e.classList.remove('show')},2500)}

// ============================================================
// TAB SWITCHING
// ============================================================
function switchTab(tab) {
activeTab = tab;
document.querySelectorAll('.top-tab').forEach(function(t){t.classList.toggle('active', t.dataset.tab === tab)});
document.querySelectorAll('.tab-content').forEach(function(t){t.classList.toggle('active', t.id === 'tab-' + tab)});
if (tab === 'play') updatePlayInfo();
}

function updatePlayInfo() {
var pts = document.getElementById('play-pts');
var len = document.getElementById('play-len');
var loop = document.getElementById('play-loop');
if (pts) pts.textContent = trackData.length;
if (len) len.textContent = Math.round(getTrackLength()) + ' units';
if (loop && trackData.length >= 3) {
var f = trackData[0][0], l = trackData[trackData.length-1][0];
var gap = Math.hypot(f[0]-l[0], f[1]-l[1], f[2]-l[2]);
loop.textContent = gap < 50 ? 'Yes' : 'No (gap: ' + Math.round(gap) + ')';
}
}

// ============================================================
// INIT
// ============================================================
function init(){
trackData=ET.map(function(p){return[[p[0],p[1],p[2]],[p[3],p[4],p[5]]]});
origData=JSON.parse(JSON.stringify(trackData));
setupThree();buildVis();updateStats();bindUI();setupDrawer();_slsUpdateEndpointInfo();animate();
}

function setupThree(){
var c=document.getElementById('viewport'),w=c.clientWidth,h=c.clientHeight;
scene=new THREE.Scene();scene.background=new THREE.Color(0x0a0a0f);scene.fog=new THREE.Fog(0x0a0a0f,5000,12000);
cam=new THREE.PerspectiveCamera(50,w/h,1,20000);cam.position.set(600,400,600);
rndr=new THREE.WebGLRenderer({antialias:true});rndr.setSize(w,h);rndr.setPixelRatio(Math.min(window.devicePixelRatio,2));rndr.autoClear=false;rndr.outputColorSpace=THREE.LinearSRGBColorSpace;
c.appendChild(rndr.domElement);
scene.add(new THREE.AmbientLight(0x445566,1.57));var sun=new THREE.DirectionalLight(0xffeedd,2.51);sun.position.set(1000,2000,500);scene.add(sun);
var fill=new THREE.DirectionalLight(0x445566,0.94);fill.position.set(-500,500,-500);scene.add(fill);
var grid=new THREE.GridHelper(10000,100,0x1a1a2a,0x111118);scene.add(grid);
gPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0);cpGrp=new THREE.Group();scene.add(cpGrp);
cScene=new THREE.Scene();cScene.background=new THREE.Color(0x12121a);cCam=new THREE.PerspectiveCamera(50,1,.1,10);
cScene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0),new THREE.Vector3(),1,0xff4444,.25,.12));
cScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0),new THREE.Vector3(),1,0x44ff44,.25,.12));
cScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1),new THREE.Vector3(),1,0x4488ff,.25,.12));
ray=new THREE.Raycaster();mouse=new THREE.Vector2();

if(trackData.length>0){var cx=trackData.reduce(function(s,p){return s+p[0][0]},0)/trackData.length,cy=trackData.reduce(function(s,p){return s+p[0][1]},0)/trackData.length,cz=trackData.reduce(function(s,p){return s+p[0][2]},0)/trackData.length;orb.tgt.set(cx,cy,cz)}

c.addEventListener('mousedown', function(e){
if(e.button===2){orb.pan=true}else{orb.rot=true;if(activeTab==='track'&&editMode==='control-points'&&cps.length>0)trySelectCP(e);if(activeTab==='track'&&editMode!=='control-points')trySelectTrackPt(e)}
orb.lx=e.clientX;orb.ly=e.clientY;
});
c.addEventListener('contextmenu',function(e){e.preventDefault()});
window.addEventListener('mouseup',function(){orb.rot=false;orb.pan=false;if(dragCP){dragCP=false}});
window.addEventListener('mousemove',function(e){
var dx=e.clientX-orb.lx,dy=e.clientY-orb.ly;orb.lx=e.clientX;orb.ly=e.clientY;
if(dragCP&&selCP>=0){var ndc=new THREE.Vector2((e.clientX/window.innerWidth)*2-1,-(e.clientY/window.innerHeight)*2+1);dragCPTo(ndc);return}
if(orb.rot&&!dragCP){orb.theta+=dx*.005;orb.phi-=dy*.005;orb.phi=Math.max(.05,Math.min(Math.PI-.05,orb.phi))}
if(orb.pan) doPan(dx,dy);
});
c.addEventListener('wheel',function(e){e.preventDefault();orb.dist*=(1+e.deltaY*.001);orb.dist=Math.max(50,Math.min(15000,orb.dist))},{passive:false});

c.addEventListener('touchstart',function(e){e.preventDefault();var t=e.touches;if(t.length===1){tch.mode='orbit';tch.moved=false;tch.tapTime=Date.now();tch.tapPos={x:t[0].clientX,y:t[0].clientY};orb.lx=t[0].clientX;orb.ly=t[0].clientY}else if(t.length===2){tch.mode='pinch';tch.initDist=Math.hypot(t[1].clientX-t[0].clientX,t[1].clientY-t[0].clientY);tch.last=[{x:t[0].clientX,y:t[0].clientY},{x:t[1].clientX,y:t[1].clientY}]}},{passive:false});
c.addEventListener('touchmove',function(e){e.preventDefault();var t=e.touches;if(t.length===1&&tch.mode==='orbit'){var dx=t[0].clientX-orb.lx,dy=t[0].clientY-orb.ly;orb.lx=t[0].clientX;orb.ly=t[0].clientY;if(Math.abs(dx)>2||Math.abs(dy)>2)tch.moved=true;orb.theta+=dx*.005;orb.phi-=dy*.005;orb.phi=Math.max(.05,Math.min(Math.PI-.05,orb.phi))}if(t.length===2&&tch.mode==='pinch'){var nd=Math.hypot(t[1].clientX-t[0].clientX,t[1].clientY-t[0].clientY);orb.dist*=(1+(tch.initDist/nd-1)*.05);orb.dist=Math.max(50,Math.min(15000,orb.dist));tch.initDist=nd;var mx=(t[0].clientX+t[1].clientX)/2,my=(t[0].clientY+t[1].clientY)/2;if(tch.last&&tch.last.length===2){doPan(mx-(tch.last[0].x+tch.last[1].x)/2,my-(tch.last[0].y+tch.last[1].y)/2)}tch.last=[{x:t[0].clientX,y:t[0].clientY},{x:t[1].clientX,y:t[1].clientY}]}},{passive:false});
c.addEventListener('touchend',function(e){e.preventDefault();if(!tch.moved&&Date.now()-tch.tapTime<300&&tch.tapPos){var tp=tch.tapPos;if(activeTab==='track')trySelectTrackPt({clientX:tp.x,clientY:tp.y})}tch.mode=null;tch.last=null;if(e.touches.length===1){tch.mode='orbit';orb.lx=e.touches[0].clientX;orb.ly=e.touches[0].clientY}},{passive:false});
c.addEventListener('touchcancel',function(e){e.preventDefault();tch.mode=null;tch.last=null},{passive:false});

window.addEventListener('resize',function(){var w=c.clientWidth,h=c.clientHeight;cam.aspect=w/h;cam.updateProjectionMatrix();rndr.setSize(w,h);isMobile=window.innerWidth<=768});
window.addEventListener('keydown',function(e){if(e.key==='f'||e.key==='F')fitView();if(e.key==='Escape'){selA=selB=-1;selCP=-1;updateSelVis();updateCPPanel()}});
}

function doPan(dx,dy){var r=new THREE.Vector3(),u=new THREE.Vector3();r.crossVectors(cam.up,new THREE.Vector3().subVectors(orb.tgt,cam.position).normalize()).normalize();u.copy(cam.up);var s=orb.dist*.001;orb.tgt.add(r.multiplyScalar(dx*s));orb.tgt.add(u.multiplyScalar(dy*s))}
function updCam(){var sp=Math.sin(orb.phi),cp=Math.cos(orb.phi),st=Math.sin(orb.theta),ct=Math.cos(orb.theta);cam.position.set(orb.tgt.x+orb.dist*sp*ct,orb.tgt.y+orb.dist*cp,orb.tgt.z+orb.dist*sp*st);cam.lookAt(orb.tgt)}
function fitView(){if(!trackData.length)return;var a=Infinity,b=-Infinity,c=Infinity,d=-Infinity,e=Infinity,f=-Infinity;trackData.forEach(function(p){a=Math.min(a,p[0][0]);b=Math.max(b,p[0][0]);c=Math.min(c,p[0][1]);d=Math.max(d,p[0][1]);e=Math.min(e,p[0][2]);f=Math.max(f,p[0][2])});orb.tgt.set((a+b)/2,(c+d)/2,(e+f)/2);orb.dist=Math.max(b-a,d-c,f-e)*1.2;orb.phi=Math.PI/4;orb.theta=Math.PI/4}

// ============================================================
// TRACK VISUALIZATION
// ============================================================
function buildVis(){
if(tLine)scene.remove(tLine);if(tRibbon)scene.remove(tRibbon);if(ptCloud)scene.remove(ptCloud);if(selHL)scene.remove(selHL);if(trackRibbon)scene.remove(trackRibbon);if(laneLineGroup){scene.remove(laneLineGroup);laneLineGroup=null}
if(!trackData.length)return;
var pos=[],col=[];var mY=Infinity,MY=-Infinity;trackData.forEach(function(p){mY=Math.min(mY,p[0][1]);MY=Math.max(MY,p[0][1])});var yr=Math.max(MY-mY,1);
trackData.forEach(function(p){pos.push(p[0][0],p[0][1],p[0][2]);var t=(p[0][1]-mY)/yr;col.push(1-t*.6,.3+t*.4,.2+t*.6)});
var g1=new THREE.BufferGeometry();g1.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));g1.setAttribute('color',new THREE.Float32BufferAttribute(col,3));
tLine=new THREE.Line(g1,new THREE.LineBasicMaterial({vertexColors:true}));scene.add(tLine);
ptCloud=new THREE.Points(g1.clone(),new THREE.PointsMaterial({size:4,vertexColors:true,sizeAttenuation:false}));scene.add(ptCloud);
selHL=new THREE.Points(new THREE.BufferGeometry(),new THREE.PointsMaterial({size:8,color:0x00ffcc,sizeAttenuation:false}));scene.add(selHL);
updateSelVis();
buildTrackRibbon();
buildEditorLaneLines();
}

function buildTrackRibbon(){
if(trackRibbon)scene.remove(trackRibbon);
var w=15,verts=[],idx=[],cols=[];
for(var i=0;i<trackData.length;i++){
var p=trackData[i][0],n=trackData[i][1];var fwd;
if(i<trackData.length-1)fwd=sub(trackData[i+1][0],p);else fwd=sub(p,trackData[i-1][0]);
var fl=Math.sqrt(fwd[0]*fwd[0]+fwd[1]*fwd[1]+fwd[2]*fwd[2])||1;fwd=[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl];
var r=crs(fwd,n),rl=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2])||1;
verts.push(p[0]+r[0]/rl*w,p[1]+r[1]/rl*w+1,p[2]+r[2]/rl*w);
verts.push(p[0]-r[0]/rl*w,p[1]-r[1]/rl*w+1,p[2]-r[2]/rl*w);
cols.push(0.25,0.25,0.3, 0.25,0.25,0.3);
if(i<trackData.length-1){var vi=i*2;idx.push(vi,vi+1,vi+2,vi+1,vi+3,vi+2)}
}
var g=new THREE.BufferGeometry();
g.setAttribute('position',new THREE.Float32BufferAttribute(verts,3));
g.setAttribute('color',new THREE.Float32BufferAttribute(cols,3));
g.setIndex(idx);g.computeVertexNormals();
trackRibbon=new THREE.Mesh(g,new THREE.MeshPhongMaterial({vertexColors:true,side:THREE.DoubleSide}));
scene.add(trackRibbon);
}

function buildEditorLaneLines(){
if(laneLineGroup){scene.remove(laneLineGroup);laneLineGroup=null}
if(trackData.length<10)return;
laneLineGroup=new THREE.Group();
var w=15,dashLen=18,gapLen=24,dashW=1.2,edgeInset=2.5;
var dashMat=new THREE.MeshBasicMaterial({color:0xffffff,side:THREE.DoubleSide,transparent:true,opacity:0.5,depthWrite:false});
var edgeMat=new THREE.MeshBasicMaterial({color:0xffdd44,side:THREE.DoubleSide,transparent:true,opacity:0.4,depthWrite:false});
// Accumulate distance along track and place dashes
var dist=0,cycleLen=dashLen+gapLen;
var i=0;
while(i<trackData.length-1){
  var p=trackData[i][0],pn=trackData[Math.min(i+1,trackData.length-1)][0];
  var segLen=Math.sqrt((pn[0]-p[0])**2+(pn[1]-p[1])**2+(pn[2]-p[2])**2);
  var prevDist=dist;
  dist+=segLen;
  // Check if a dash start falls within this segment
  var nextDash=Math.ceil(prevDist/cycleLen)*cycleLen;
  while(nextDash<dist&&nextDash+dashLen*0.5<dist){
    // Find the midpoint index roughly at nextDash+dashLen/2
    var midDist=nextDash+dashLen/2;
    var mi=i;
    var acc=prevDist;
    while(mi<trackData.length-2){
      var d2=Math.sqrt((trackData[mi+1][0][0]-trackData[mi][0][0])**2+(trackData[mi+1][0][1]-trackData[mi][0][1])**2+(trackData[mi+1][0][2]-trackData[mi][0][2])**2);
      if(acc+d2>=midDist)break;
      acc+=d2;mi++;
    }
    var mp=trackData[mi][0],mn=trackData[mi][1];
    var fwd;
    if(mi<trackData.length-1)fwd=sub(trackData[mi+1][0],mp);else fwd=sub(mp,trackData[mi-1][0]);
    var fl=Math.sqrt(fwd[0]**2+fwd[1]**2+fwd[2]**2)||1;
    fwd=[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl];
    var r=crs(fwd,mn),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;
    r=[r[0]/rl,r[1]/rl,r[2]/rl];
    // Center dash
    var dg=new THREE.PlaneGeometry(dashW,dashLen);
    var dm=new THREE.Mesh(dg,dashMat);
    dm.position.set(mp[0],mp[1]+1.5,mp[2]);
    var la=new THREE.Vector3(mp[0]+fwd[0],mp[1]+fwd[1]+1.5,mp[2]+fwd[2]);
    dm.up.set(mn[0],mn[1],mn[2]);
    dm.lookAt(la);
    dm.rotateX(-Math.PI/2);
    laneLineGroup.add(dm);
    // Left edge dash
    var eg=new THREE.PlaneGeometry(dashW*0.6,dashLen*0.7);
    var el=new THREE.Mesh(eg,edgeMat);
    el.position.set(mp[0]-r[0]*(w-edgeInset),mp[1]-r[1]*(w-edgeInset)+1.5,mp[2]-r[2]*(w-edgeInset));
    el.up.set(mn[0],mn[1],mn[2]);
    el.lookAt(new THREE.Vector3(el.position.x+fwd[0],el.position.y+fwd[1],el.position.z+fwd[2]));
    el.rotateX(-Math.PI/2);
    laneLineGroup.add(el);
    // Right edge dash
    var er=new THREE.Mesh(eg.clone(),edgeMat);
    er.position.set(mp[0]+r[0]*(w-edgeInset),mp[1]+r[1]*(w-edgeInset)+1.5,mp[2]+r[2]*(w-edgeInset));
    er.up.set(mn[0],mn[1],mn[2]);
    er.lookAt(new THREE.Vector3(er.position.x+fwd[0],er.position.y+fwd[1],er.position.z+fwd[2]));
    er.rotateX(-Math.PI/2);
    laneLineGroup.add(er);
    nextDash+=cycleLen;
  }
  i++;
}
scene.add(laneLineGroup);
}

function updateSelVis(){if(!selHL)return;if(selA<0){selHL.geometry.setAttribute('position',new THREE.Float32BufferAttribute([],3));return}var lo=Math.min(selA,selB<0?selA:selB),hi=Math.max(selA,selB<0?selA:selB);var p=[];for(var i=lo;i<=hi&&i<trackData.length;i++)p.push(trackData[i][0][0],trackData[i][0][1],trackData[i][0][2]);selHL.geometry.setAttribute('position',new THREE.Float32BufferAttribute(p,3))}

function trySelectTrackPt(e){if(activeTab!=='track')return;var c=document.getElementById('viewport');mouse.x=(e.clientX/c.clientWidth)*2-1;mouse.y=-(e.clientY/c.clientHeight)*2+1;ray.setFromCamera(mouse,cam);var best=-1,bestD=40;for(var i=0;i<trackData.length;i++){var v=new THREE.Vector3(trackData[i][0][0],trackData[i][0][1],trackData[i][0][2]);v.project(cam);var sx=(v.x+1)/2*c.clientWidth,sy=(1-v.y)/2*c.clientHeight;var d=Math.hypot(sx-e.clientX,sy-e.clientY);if(d<bestD){bestD=d;best=i}}if(best>=0){if(e.shiftKey&&selA>=0){selB=best}else{selA=best;selB=-1}updateSelVis()}}

function trySelectCP(e){var c=document.getElementById('viewport');var ndc=new THREE.Vector2((e.clientX/c.clientWidth)*2-1,-(e.clientY/c.clientHeight)*2+1);var best=-1,bestD=30;for(var i=0;i<cps.length;i++){var v=new THREE.Vector3(cps[i].pos[0],cps[i].pos[1],cps[i].pos[2]);v.project(cam);var sx=(v.x+1)/2*c.clientWidth,sy=(1-v.y)/2*c.clientHeight;var d=Math.hypot(sx-e.clientX,sy-e.clientY);if(d<bestD){bestD=d;best=i}}if(best>=0){selCP=best;dragCP=true;orb.rot=false;updateCPVis();updateCPPanel()}}
function dragCPTo(ndc){ray.setFromCamera(ndc,cam);var v=new THREE.Vector3(),y=cps[selCP].pos[1],p=new THREE.Plane(new THREE.Vector3(0,1,0),-y);if(ray.ray.intersectPlane(p,v)){cps[selCP].pos[0]=v.x;cps[selCP].pos[2]=v.z;updateCPVis();updateCPPanel();rebuildSpline()}}
function updateCPPanel(){var p=document.getElementById('cp-selected-panel');var wp=document.getElementById('width-cp-panel');if(selCP<0){if(p)p.style.display='none';if(wp)wp.style.display='none';return}if(p){p.style.display='block';document.getElementById('cp-sel-idx').textContent=selCP;document.getElementById('cp-x').value=Math.round(cps[selCP].pos[0]);document.getElementById('cp-y').value=Math.round(cps[selCP].pos[1]);document.getElementById('cp-z').value=Math.round(cps[selCP].pos[2])}if(wp&&editMode==='width'){wp.style.display='block';document.getElementById('width-cp-idx').textContent=selCP;document.getElementById('cp-width').value=cps[selCP].width;document.getElementById('cp-width-val').textContent=Math.round(cps[selCP].width)}}
function updateCPFromInput(){if(selCP<0)return;cps[selCP].pos[0]=parseFloat(document.getElementById('cp-x').value)||0;cps[selCP].pos[1]=parseFloat(document.getElementById('cp-y').value)||0;cps[selCP].pos[2]=parseFloat(document.getElementById('cp-z').value)||0;updateCPVis();rebuildSpline()}
function extractControlPoints(){var n=parseInt(document.getElementById('cp-count').value);if(trackData.length<n){toast('Not enough pts');return}cps=[];var step=trackData.length/n;for(var i=0;i<n;i++){var idx=Math.min(Math.floor(i*step),trackData.length-1);cps.push({pos:[trackData[idx][0][0],trackData[idx][0][1],trackData[idx][0][2]],normal:[trackData[idx][1][0],trackData[idx][1][1],trackData[idx][1][2]],width:defWidth})}selCP=-1;updateCPVis();rebuildSpline();toast(n+' CPs extracted')}
function updateCPVis(){while(cpGrp.children.length)cpGrp.remove(cpGrp.children[0]);if(editMode!=='control-points'&&editMode!=='width')return;var show=document.getElementById('show-cp-handles');if(show&&show.checked===false)return;cps.forEach(function(c,i){var g=new THREE.SphereGeometry(6,8,6);var m=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:i===selCP?0x00ffcc:0xffcc00}));m.position.set(c.pos[0],c.pos[1],c.pos[2]);cpGrp.add(m)})}
function rebuildSpline(){if(splineLine)scene.remove(splineLine);if(cps.length<2)return;var cv=new THREE.CatmullRomCurve3(cps.map(function(c){return new THREE.Vector3(c.pos[0],c.pos[1],c.pos[2])}));var r=parseInt(document.getElementById('spline-resolution').value||'10');var p=cv.getPoints(cps.length*r);var g=new THREE.BufferGeometry().setFromPoints(p);splineLine=new THREE.Line(g,new THREE.LineDashedMaterial({color:0xff44cc,dashSize:10,gapSize:5}));splineLine.computeLineDistances();scene.add(splineLine)}
function rebuildFromSpline(){if(cps.length<2){toast('Extract CPs first');return}var r=parseInt(document.getElementById('spline-resolution').value);var cv=new THREE.CatmullRomCurve3(cps.map(function(c){return new THREE.Vector3(c.pos[0],c.pos[1],c.pos[2])}));var nc=new THREE.CatmullRomCurve3(cps.map(function(c){return new THREE.Vector3(c.normal[0],c.normal[1],c.normal[2])}));var tp=cps.length*r,pp=cv.getPoints(tp),np=nc.getPoints(tp);trackData=pp.map(function(p,i){var n=np[i],nl=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z)||1;return[[p.x,p.y,p.z],[n.x/nl,n.y/nl,n.z/nl]]});buildVis();updateStats();toast('Rebuilt: '+trackData.length+' pts')}
function insertCPAfter(){if(selCP<0||cps.length<2)return;var next=(selCP+1)%cps.length;var np={pos:[(cps[selCP].pos[0]+cps[next].pos[0])/2,(cps[selCP].pos[1]+cps[next].pos[1])/2,(cps[selCP].pos[2]+cps[next].pos[2])/2],normal:[cps[selCP].normal[0],cps[selCP].normal[1],cps[selCP].normal[2]],width:cps[selCP].width};cps.splice(selCP+1,0,np);selCP=selCP+1;updateCPVis();rebuildSpline();toast('Inserted CP')}
function deleteSelectedCP(){if(selCP<0||cps.length<=2)return;cps.splice(selCP,1);selCP=Math.min(selCP,cps.length-1);updateCPVis();rebuildSpline();toast('Deleted CP')}

function onDefaultWidthChange(){defWidth=parseInt(document.getElementById('default-width').value);document.getElementById('default-width-val').textContent=defWidth}
function setAllWidths(){cps.forEach(function(c){c.width=defWidth});if(editMode==='width')buildWRib();drawWGraph();toast('All widths set to '+defWidth)}
function onCPWidthChange(){if(selCP<0)return;cps[selCP].width=parseInt(document.getElementById('cp-width').value);document.getElementById('cp-width-val').textContent=cps[selCP].width;buildWRib();drawWGraph()}
function widthPreset(w){if(selCP<0)return;cps[selCP].width=w;document.getElementById('cp-width').value=w;document.getElementById('cp-width-val').textContent=w;buildWRib();drawWGraph()}
function interpWidths(){if(cps.length<2)return trackData.map(function(){return defWidth});var ws=[];var total=trackData.length;for(var i=0;i<total;i++){var t=i/(total-1)*(cps.length-1);var idx=Math.floor(t),frac=t-idx;var a=cps[Math.min(idx,cps.length-1)].width,b=cps[Math.min(idx+1,cps.length-1)].width;ws.push(a+(b-a)*frac)}return ws}
function buildWRib(){if(wRibbon)scene.remove(wRibbon);if(cps.length<2)return;var ws=interpWidths(),verts=[],idx=[],cols=[];for(var i=0;i<trackData.length;i++){var p=trackData[i][0],n=trackData[i][1];var fwd;if(i<trackData.length-1)fwd=sub(trackData[i+1][0],p);else fwd=sub(p,trackData[i-1][0]);var fl=Math.sqrt(fwd[0]**2+fwd[1]**2+fwd[2]**2)||1;fwd=[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl];var r=crs(fwd,n),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;var hw=ws[i]/2;verts.push(p[0]+r[0]/rl*hw,p[1]+r[1]/rl*hw+2,p[2]+r[2]/rl*hw);verts.push(p[0]-r[0]/rl*hw,p[1]-r[1]/rl*hw+2,p[2]-r[2]/rl*hw);cols.push(.2,.6,.4,.2,.6,.4);if(i<trackData.length-1){var vi=i*2;idx.push(vi,vi+1,vi+2,vi+1,vi+3,vi+2)}}var g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(verts,3));g.setAttribute('color',new THREE.Float32BufferAttribute(cols,3));g.setIndex(idx);g.computeVertexNormals();wRibbon=new THREE.Mesh(g,new THREE.MeshPhongMaterial({vertexColors:true,side:THREE.DoubleSide,transparent:true,opacity:.5}));scene.add(wRibbon)}
function rebuildWithWidth(){rebuildFromSpline();if(cps.length>=2)buildWRib();drawWGraph()}
function drawWGraph(){var cv=document.getElementById('width-graph');if(!cv||cps.length<2)return;var ctx=cv.getContext('2d');cv.width=cv.clientWidth*2;cv.height=cv.clientHeight*2;ctx.scale(2,2);var w=cv.clientWidth,h=cv.clientHeight;ctx.clearRect(0,0,w,h);var ws=interpWidths(),mx=Math.max.apply(null,ws.concat([1]));ctx.strokeStyle='#00d4aa';ctx.lineWidth=1.5;ctx.beginPath();ws.forEach(function(v,i){var x=i/(ws.length-1)*w,y=h-v/mx*(h-4)-2;i===0?ctx.moveTo(x,y):ctx.lineTo(x,y)});ctx.stroke()}

function smoothSelection(){var lo=Math.min(selA,selB<0?selA:selB),hi=Math.max(selA,selB<0?selA:selB);if(lo<0){toast('Select points first');return}var iter=parseInt(document.getElementById('smooth-iter').value),str=parseFloat(document.getElementById('smooth-str').value);for(var k=0;k<iter;k++){var old=trackData.map(function(p){return[[p[0][0],p[0][1],p[0][2]],[p[1][0],p[1][1],p[1][2]]]});for(var i=Math.max(1,lo);i<=Math.min(hi,trackData.length-2);i++){for(var j=0;j<3;j++){trackData[i][0][j]=old[i][0][j]*(1-str)+(old[i-1][0][j]+old[i+1][0][j])/2*str}}}buildVis();toast('Smoothed')}
function smoothAll(){selA=0;selB=trackData.length-1;smoothSelection();selA=selB=-1;updateSelVis()}
function applyElevation(){var lo=Math.min(selA,selB),hi=Math.max(selA,selB);if(lo<0){toast('Select points first');return}var o=parseInt(document.getElementById('elev-offset').value);for(var i=lo;i<=hi&&i<trackData.length;i++){var ed=Math.min(i-lo,hi-i),rg=Math.max(1,(hi-lo)/2),f=Math.min(1,ed/Math.min(10,rg));trackData[i][0][1]+=o*f}buildVis();document.getElementById('elev-offset').value=0;document.getElementById('elev-val').textContent=0;toast('Elevation applied')}

function previewLoop(){if(loopLine)scene.remove(loopLine);if(trackData.length<10)return;var pts=genLoop(parseInt(document.getElementById('loop-blend').value),parseInt(document.getElementById('loop-pts').value));var p=[];pts.forEach(function(q){p.push(q[0][0],q[0][1],q[0][2])});var g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(p,3));loopLine=new THREE.Line(g,new THREE.LineDashedMaterial({color:0xff44cc,dashSize:8,gapSize:4}));loopLine.computeLineDistances();scene.add(loopLine);toast('Preview: '+pts.length+' loop pts')}
function makeLoop(){if(loopAdded>0)removeLoop();var pts=genLoop(parseInt(document.getElementById('loop-blend').value),parseInt(document.getElementById('loop-pts').value));trackData=trackData.concat(pts);loopAdded=pts.length;if(loopLine){scene.remove(loopLine);loopLine=null}buildVis();updateStats();toast('Added '+pts.length+' loop pts')}
function removeLoop(){if(loopAdded<=0)return;trackData.splice(trackData.length-loopAdded,loopAdded);loopAdded=0;buildVis();updateStats();toast('Loop removed')}
function genLoop(bd,np){var s=trackData[0],e=trackData[trackData.length-1];var st=norm(sub(trackData[Math.min(5,trackData.length-1)][0],s[0])),et=norm(sub(e[0],trackData[Math.max(0,trackData.length-6)][0]));var pts=[];for(var i=1;i<=np;i++){var t=i/(np+1),h00=2*t*t*t-3*t*t+1,h10=t*t*t-2*t*t+t,h01=-2*t*t*t+3*t*t,h11=t*t*t-t*t;var p=[h00*e[0][0]+h10*et[0]*bd+h01*s[0][0]+h11*(-st[0])*bd,h00*e[0][1]+h10*et[1]*bd+h01*s[0][1]+h11*(-st[1])*bd,h00*e[0][2]+h10*et[2]*bd+h01*s[0][2]+h11*(-st[2])*bd];var n=norm([e[1][0]*(1-t)+s[1][0]*t,e[1][1]*(1-t)+s[1][1]*t,e[1][2]*(1-t)+s[1][2]*t]);pts.push([p,n])}return pts}

function loadFile(){document.getElementById('file-input').click()}
function handleFile(e){var f=e.target.files[0];if(!f)return;var r=new FileReader();r.onload=function(ev){try{var raw=JSON.parse(ev.target.result);var d=raw.track||raw;if(Array.isArray(d)&&d.length>0){if(Array.isArray(d[0])&&d[0].length===6)trackData=d.map(function(p){return[[p[0],p[1],p[2]],[p[3],p[4],p[5]]]});else if(Array.isArray(d[0])&&d[0].length===2)trackData=d;else throw new Error('Unknown format');origData=JSON.parse(JSON.stringify(trackData));cps=[];loopAdded=0;selCP=-1;buildVis();updateCPVis();updateStats();fitView();toast('Loaded '+trackData.length+' pts')}}catch(err){toast('Error: '+err.message)}};r.readAsText(f);e.target.value=''}
function exportTrack(){var d=trackData.map(function(p){return[Math.round(p[0][0]*10)/10,Math.round(p[0][1]*10)/10,Math.round(p[0][2]*10)/10,Math.round(p[1][0]*1e4)/1e4,Math.round(p[1][1]*1e4)/1e4,Math.round(p[1][2]*1e4)/1e4]});var ex={track:d,controlPoints:cps.length>0?cps.map(function(c){return{pos:c.pos.map(function(v){return Math.round(v*10)/10}),normal:c.normal.map(function(v){return Math.round(v*1e4)/1e4}),width:Math.round(c.width*10)/10}}):undefined,widths:cps.length>0?interpWidths().map(function(w){return Math.round(w*10)/10}):undefined};var b=new Blob([JSON.stringify(ex,null,2)],{type:'application/json'});var u=URL.createObjectURL(b);var a=document.createElement('a');a.href=u;a.download='track_with_width.json';a.click();URL.revokeObjectURL(u);toast('Exported')}
function undoAll(){if(!origData)return;trackData=JSON.parse(JSON.stringify(origData));cps=[];loopAdded=0;selCP=-1;buildVis();updateCPVis();updateStats();toast('Reverted')}

function setEditMode(m){editMode=m;document.querySelectorAll('.mode-tab').forEach(function(t){t.classList.toggle('active',t.dataset.mode===m)});document.getElementById('mode-select').style.display=m==='select'?'block':'none';document.getElementById('mode-control-points').style.display=m==='control-points'?'block':'none';document.getElementById('mode-width').style.display=m==='width'?'block':'none';if(m==='width'&&cps.length>=2)buildWRib();updateCPVis();drawWGraph()}

function updateStats(){document.getElementById('stat-points').textContent=trackData.length;document.getElementById('stat-cp').textContent=cps.length||'--';var l=0;for(var i=1;i<trackData.length;i++)l+=dst(trackData[i][0],trackData[i-1][0]);document.getElementById('stat-length').textContent=Math.round(l)+'m';if(trackData.length>0){var mY=Infinity,MY=-Infinity;trackData.forEach(function(p){mY=Math.min(mY,p[0][1]);MY=Math.max(MY,p[0][1])});document.getElementById('stat-elevation').textContent=Math.round(MY-mY)+'m'}}

// ============================================================
// TERRAIN GENERATION
// ============================================================
function SeededNoise(seed){
this.perm=new Uint8Array(512);var p=new Uint8Array(256);for(var i=0;i<256;i++)p[i]=i;
var s=seed;for(var i=255;i>0;i--){s=(s*16807+0)%2147483647;var j=s%(i+1);var tmp=p[i];p[i]=p[j];p[j]=tmp}
for(var i=0;i<512;i++)this.perm[i]=p[i&255];
this.grad=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
}
SeededNoise.prototype.dot2=function(g,x,y){return g[0]*x+g[1]*y};
SeededNoise.prototype.noise2D=function(x,y){var F2=0.5*(Math.sqrt(3)-1),G2=(3-Math.sqrt(3))/6;var s=(x+y)*F2;var i=Math.floor(x+s),j=Math.floor(y+s);var t=(i+j)*G2;var x0=x-(i-t),y0=y-(j-t);var i1=x0>y0?1:0,j1=x0>y0?0:1;var x1=x0-i1+G2,y1=y0-j1+G2;var x2=x0-1+2*G2,y2=y0-1+2*G2;var ii=i&255,jj=j&255;var gi0=this.perm[ii+this.perm[jj]]%8,gi1=this.perm[ii+i1+this.perm[jj+j1]]%8,gi2=this.perm[ii+1+this.perm[jj+1]]%8;var n0=0,n1=0,n2=0;var t0=0.5-x0*x0-y0*y0;if(t0>=0){t0*=t0;n0=t0*t0*this.dot2(this.grad[gi0],x0,y0)}var t1=0.5-x1*x1-y1*y1;if(t1>=0){t1*=t1;n1=t1*t1*this.dot2(this.grad[gi1],x1,y1)}var t2=0.5-x2*x2-y2*y2;if(t2>=0){t2*=t2;n2=t2*t2*this.dot2(this.grad[gi2],x2,y2)}return 70*(n0+n1+n2)};
SeededNoise.prototype.fbm=function(x,y,octaves,lacunarity,persistence){var val=0,amp=1,freq=1,maxAmp=0;for(var i=0;i<octaves;i++){val+=this.noise2D(x*freq,y*freq)*amp;maxAmp+=amp;amp*=persistence;freq*=lacunarity}return val/maxAmp};

function generateTerrain(){
var t0=performance.now();
var amp=parseFloat(document.getElementById('s-amp').value);
var freq=parseFloat(document.getElementById('s-freq').value);
var octaves=parseInt(document.getElementById('s-oct').value);
var lac=parseFloat(document.getElementById('s-lac').value);
var per=parseFloat(document.getElementById('s-per').value);
var seed=parseInt(document.getElementById('s-seed').value);
var res=parseInt(document.getElementById('s-res').value);
var ext=parseFloat(document.getElementById('s-ext').value);
var clearance=parseFloat(document.getElementById('s-clear').value);
var blendR=parseFloat(document.getElementById('s-blend').value);
var depress=parseFloat(document.getElementById('s-depress').value);
var wireOn=document.getElementById('chk-wire').checked;
var flatShade=document.getElementById('chk-flat').checked;
var colLow=hexToRGB(document.getElementById('c-low').value);
var colMid=hexToRGB(document.getElementById('c-mid').value);
var colHigh=hexToRGB(document.getElementById('c-high').value);
var colPeak=hexToRGB(document.getElementById('c-peak').value);
var noise=new SeededNoise(seed);
var minX=Infinity,maxX=-Infinity,minZ=Infinity,maxZ=-Infinity,avgH=0;
trackData.forEach(function(p){minX=Math.min(minX,p[0][0]);maxX=Math.max(maxX,p[0][0]);minZ=Math.min(minZ,p[0][2]);maxZ=Math.max(maxZ,p[0][2]);avgH+=p[0][1]});
avgH/=trackData.length;
var gMinX=minX-ext,gMaxX=maxX+ext,gMinZ=minZ-ext,gMaxZ=maxZ+ext;
var stepX=(gMaxX-gMinX)/res,stepZ=(gMaxZ-gMinZ)/res;
var tkPts=trackData.map(function(p){return{x:p[0][0],z:p[0][2],h:p[0][1]}});
function closestTrack(gx,gz){var bd=Infinity,bh=avgH;for(var i=0;i<tkPts.length;i++){var dx=gx-tkPts[i].x,dz=gz-tkPts[i].z,d=Math.sqrt(dx*dx+dz*dz);if(d<bd){bd=d;bh=tkPts[i].h}}return{dist:bd,h:bh}}
var cols=res+1,rows=res+1;var heights=new Float32Array(cols*rows);var minH=Infinity,maxH=-Infinity;
for(var iz=0;iz<=res;iz++){for(var ix=0;ix<=res;ix++){var gx=gMinX+ix*stepX,gz=gMinZ+iz*stepZ,idx=iz*cols+ix;
var h=noise.fbm(gx*freq,gz*freq,octaves,lac,per)*amp+avgH;
var tk=closestTrack(gx,gz);
if(tk.dist<clearance){h=tk.h+depress}else if(tk.dist<clearance+blendR){var t=(tk.dist-clearance)/blendR,s2=t*t*(3-2*t);h=(tk.h+depress)*(1-s2)+h*s2}
heights[idx]=h;minH=Math.min(minH,h);maxH=Math.max(maxH,h)}}
var positions=new Float32Array(cols*rows*3),colors=new Float32Array(cols*rows*3);var hRange=Math.max(maxH-minH,1);
for(var iz=0;iz<=res;iz++){for(var ix=0;ix<=res;ix++){var idx=iz*cols+ix,gx=gMinX+ix*stepX,gz=gMinZ+iz*stepZ,h=heights[idx];
positions[idx*3]=gx;positions[idx*3+1]=h;positions[idx*3+2]=gz;
var nt=(h-minH)/hRange;var r,g,b;
if(nt<.33){var lt=nt/.33;r=colLow[0]*(1-lt)+colMid[0]*lt;g=colLow[1]*(1-lt)+colMid[1]*lt;b=colLow[2]*(1-lt)+colMid[2]*lt}
else if(nt<.66){var lt=(nt-.33)/.33;r=colMid[0]*(1-lt)+colHigh[0]*lt;g=colMid[1]*(1-lt)+colHigh[1]*lt;b=colMid[2]*(1-lt)+colHigh[2]*lt}
else{var lt=(nt-.66)/.34;r=colHigh[0]*(1-lt)+colPeak[0]*lt;g=colHigh[1]*(1-lt)+colPeak[1]*lt;b=colHigh[2]*(1-lt)+colPeak[2]*lt}
var tk2=closestTrack(gx,gz);if(tk2.dist<clearance*1.5){var dT=Math.max(0,1-tk2.dist/(clearance*1.5));r*=(1-dT*.4);g*=(1-dT*.4);b*=(1-dT*.3)}
colors[idx*3]=r;colors[idx*3+1]=g;colors[idx*3+2]=b}}
var indices=[];for(var iz=0;iz<res;iz++){for(var ix=0;ix<res;ix++){var a=iz*cols+ix,b=a+1,c=(iz+1)*cols+ix,d=c+1;indices.push(a,c,b,b,c,d)}}
var geo=new THREE.BufferGeometry();geo.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));geo.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));geo.setIndex(indices);geo.computeVertexNormals();
if(terrainMesh)scene.remove(terrainMesh);if(terrainWire)scene.remove(terrainWire);
terrainMesh=new THREE.Mesh(geo,new THREE.MeshPhongMaterial({vertexColors:true,flatShading:flatShade,side:THREE.DoubleSide,shininess:5}));scene.add(terrainMesh);
if(wireOn){terrainWire=new THREE.LineSegments(new THREE.WireframeGeometry(geo),new THREE.LineBasicMaterial({color:0x1a3a2a,transparent:true,opacity:.3}));scene.add(terrainWire)}
var elapsed=(performance.now()-t0).toFixed(1);
document.getElementById('st-verts').textContent=(cols*rows).toLocaleString();
document.getElementById('st-tris').textContent=(res*res*2).toLocaleString();
document.getElementById('st-time').textContent=elapsed+'ms';
toast('Terrain generated');
}

function clearTerrain(){if(terrainMesh){scene.remove(terrainMesh);terrainMesh=null}if(terrainWire){scene.remove(terrainWire);terrainWire=null}toast('Terrain cleared')}
function hexToRGB(hex){return[parseInt(hex.substr(1,2),16)/255,parseInt(hex.substr(3,2),16)/255,parseInt(hex.substr(5,2),16)/255]}

// ============================================================
// GAMEPLAY - Speed Pads & AI Cars
// ============================================================
function getTrackLength(){var l=0;for(var i=1;i<trackData.length;i++)l+=dst(trackData[i][0],trackData[i-1][0]);return l}
function getTrackPointAt(frac){var total=getTrackLength(),target=frac*total;var accum=0;
for(var i=1;i<trackData.length;i++){var d=dst(trackData[i][0],trackData[i-1][0]);if(accum+d>=target){var t=(target-accum)/d;var pos=trackData[i-1][0].map(function(v,j){return v+(trackData[i][0][j]-v)*t});var fwd=sub(trackData[i][0],trackData[i-1][0]);var fl=Math.sqrt(fwd[0]**2+fwd[1]**2+fwd[2]**2)||1;var nrm=trackData[i-1][1].map(function(v,j){return v+(trackData[i][1][j]-v)*t});return{pos:pos,fwd:[fwd[0]/fl,fwd[1]/fl,fwd[2]/fl],norm:nrm}}accum+=d}
return{pos:[trackData[0][0][0],trackData[0][0][1],trackData[0][0][2]],fwd:[1,0,0],norm:[0,1,0]}}

function placeSpeedPads(){
var count=parseInt(document.getElementById('s-pads').value),boost=parseFloat(document.getElementById('s-boost').value),padLen=parseFloat(document.getElementById('s-padlen').value);
if(speedPadGroup)scene.remove(speedPadGroup);speedPadGroup=new THREE.Group();speedPadData=[];
for(var i=0;i<count;i++){var frac=i/count,tp=getTrackPointAt(frac),pw=20;
var fx=tp.fwd[0],fy=tp.fwd[1],fz=tp.fwd[2];var r=crs(tp.fwd,tp.norm),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;var hw=pw/2,hl=padLen/2;
var v=new Float32Array([tp.pos[0]-fx*hl+r[0]/rl*hw,tp.pos[1]-fy*hl+r[1]/rl*hw+3,tp.pos[2]-fz*hl+r[2]/rl*hw, tp.pos[0]-fx*hl-r[0]/rl*hw,tp.pos[1]-fy*hl-r[1]/rl*hw+3,tp.pos[2]-fz*hl-r[2]/rl*hw, tp.pos[0]+fx*hl+r[0]/rl*hw,tp.pos[1]+fy*hl+r[1]/rl*hw+3,tp.pos[2]+fz*hl+r[2]/rl*hw, tp.pos[0]+fx*hl-r[0]/rl*hw,tp.pos[1]+fy*hl-r[1]/rl*hw+3,tp.pos[2]+fz*hl-r[2]/rl*hw]);
var g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(v,3));g.setIndex([0,1,2,1,3,2]);g.computeVertexNormals();
g.setAttribute('color',new THREE.Float32BufferAttribute([0,.9,1,0,.9,1,1,.9,0,1,.9,0],3));
speedPadGroup.add(new THREE.Mesh(g,new THREE.MeshPhongMaterial({vertexColors:true,emissive:0x004455,side:THREE.DoubleSide,transparent:true,opacity:.85})));
var ag=new THREE.CylinderGeometry(0,3,8,4);var am=new THREE.Mesh(ag,new THREE.MeshPhongMaterial({color:0x00ffcc,emissive:0x00aa88}));am.position.set(tp.pos[0],tp.pos[1]+12,tp.pos[2]);am.rotation.x=Math.PI;speedPadGroup.add(am);
speedPadData.push({position:[tp.pos[0],tp.pos[1],tp.pos[2]],forward:[tp.fwd[0],tp.fwd[1],tp.fwd[2]],boost:boost,length:padLen,trackFraction:frac})}
scene.add(speedPadGroup);speedPadGroup.visible=document.getElementById('chk-pads').checked;toast(count+' pads placed')}

function toggleSpeedPads(){if(speedPadGroup)speedPadGroup.visible=document.getElementById('chk-pads').checked}

function placeAICars(){
var count=parseInt(document.getElementById('s-aicount').value),spacing=parseFloat(document.getElementById('s-aispacing').value),gridCols=parseInt(document.getElementById('s-aigrid').value),startOff=parseFloat(document.getElementById('s-aioffset').value);
if(aiCarGroup)scene.remove(aiCarGroup);aiCarGroup=new THREE.Group();aiCarData=[];
var total=getTrackLength(),laneW=8;
for(var i=0;i<count;i++){var row=Math.floor(i/gridCols),col=i%gridCols,dist=startOff+row*spacing,frac=(dist/total)%1;
var tp=getTrackPointAt(frac);var r=crs(tp.fwd,tp.norm),rl=Math.sqrt(r[0]**2+r[1]**2+r[2]**2)||1;
var lat=(col-(gridCols-1)/2)*laneW;var cx=tp.pos[0]+r[0]/rl*lat,cy=tp.pos[1]+r[1]/rl*lat+4,cz=tp.pos[2]+r[2]/rl*lat;
var hue=(i/count)*360;var body=new THREE.Mesh(new THREE.BoxGeometry(10,4,5),new THREE.MeshPhongMaterial({color:new THREE.Color().setHSL(hue/360,.8,.5)}));
body.position.set(cx,cy,cz);body.lookAt(cx+tp.fwd[0]*10,cy+tp.fwd[1]*10,cz+tp.fwd[2]*10);
var cab=new THREE.Mesh(new THREE.BoxGeometry(5,3,4.5),new THREE.MeshPhongMaterial({color:0x222233}));cab.position.y=3;body.add(cab);
aiCarGroup.add(body);aiCarData.push({position:[cx,cy,cz],forward:[tp.fwd[0],tp.fwd[1],tp.fwd[2]],lane:col,row:row,trackFraction:frac})}
scene.add(aiCarGroup);aiCarGroup.visible=document.getElementById('chk-ai').checked;toast(count+' cars placed')}

function toggleAICars(){if(aiCarGroup)aiCarGroup.visible=document.getElementById('chk-ai').checked}

// ============================================================
// PROCEDURAL SCENERY
// ============================================================
var THEMES = {
neon: {
  barrier: 0x00ffcc, barrierEmit: 0x004433, barrierH: 3,
  bldgColors: [0x1a1a2e, 0x16213e, 0x0f3460], bldgEmit: [0x001122, 0x000a1a, 0x000815],
  windowColor: 0x00ccff, windowEmit: 0x0088aa,
  archColor: 0xff6ec7, archEmit: 0x661144,
  lightColor: 0x00ffcc, lightEmit: 0x00aa88, lightIntensity: 3.14,
  poleColor: 0x333344
},
canyon: {
  barrier: 0x8b6914, barrierEmit: 0x2a1f05, barrierH: 2,
  bldgColors: [0x8b7355, 0x9b8465, 0x7a6245], bldgEmit: [0x1a1008, 0x1a1008, 0x1a1008],
  windowColor: 0x8b7355, windowEmit: 0x1a1008,
  archColor: 0xa0522d, archEmit: 0x3a1a0a,
  lightColor: 0xffaa44, lightEmit: 0xaa6622, lightIntensity: 2.51,
  poleColor: 0x5a4a3a
},
scifi: {
  barrier: 0x8844ff, barrierEmit: 0x220066, barrierH: 4,
  bldgColors: [0x0a0a1a, 0x111128, 0x080820], bldgEmit: [0x110033, 0x0a0022, 0x080020],
  windowColor: 0xaa66ff, windowEmit: 0x6633aa,
  archColor: 0x44aaff, archEmit: 0x113366,
  lightColor: 0xaa66ff, lightEmit: 0x6633aa, lightIntensity: 4.71,
  poleColor: 0x222233
}
};

function generateScenery() {
if (trackData.length < 20) { toast('Load a track first'); return; }
clearScenery();
sceneryGroup = new THREE.Group();
var theme = THEMES[document.getElementById('scenery-theme').value] || THEMES.neon;
var density = parseFloat(document.getElementById('s-scenerydensity').value);
var maxH = parseFloat(document.getElementById('s-sceneryheight').value);
var setback = parseFloat(document.getElementById('s-scenerysetback').value);
var doBarriers = document.getElementById('chk-barriers').checked;
var doBuildings = document.getElementById('chk-buildings').checked;
var doArches = document.getElementById('chk-arches').checked;
var doLights = document.getElementById('chk-lights').checked;
var trackLen = getTrackLength();
var step = 15 / density; // base spacing in world units

// Barriers — continuous wall along both sides
if (doBarriers) {
var barrierStep = 8 / density;
var bh = theme.barrierH, bw = 1.5;
var lVerts = [], rVerts = [], lIdx = [], rIdx = [];
var n = Math.floor(trackLen / barrierStep);
for (var i = 0; i <= n; i++) {
var frac = i / n;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
var hw = (defWidth / 2) + 2;
// Left barrier
var lx = tp.pos[0] - rv[0]*hw, ly = tp.pos[1] - rv[1]*hw + 1, lz = tp.pos[2] - rv[2]*hw;
lVerts.push(lx - rv[0]*bw, ly, lz - rv[2]*bw, lx - rv[0]*bw, ly+bh, lz - rv[2]*bw);
// Right barrier
var rx = tp.pos[0] + rv[0]*hw, ry = tp.pos[1] + rv[1]*hw + 1, rz = tp.pos[2] + rv[2]*hw;
rVerts.push(rx + rv[0]*bw, ry, rz + rv[2]*bw, rx + rv[0]*bw, ry+bh, rz + rv[2]*bw);
if (i > 0) {
var bi = (i-1)*2;
lIdx.push(bi, bi+1, bi+2, bi+1, bi+3, bi+2);
rIdx.push(bi, bi+1, bi+2, bi+1, bi+3, bi+2);
}
}
var bMat = new THREE.MeshPhongMaterial({color: theme.barrier, emissive: theme.barrierEmit, side: THREE.DoubleSide});
[{v:lVerts,i:lIdx},{v:rVerts,i:rIdx}].forEach(function(d){
var g = new THREE.BufferGeometry();
g.setAttribute('position', new THREE.Float32BufferAttribute(d.v, 3));
g.setIndex(d.i); g.computeVertexNormals();
sceneryGroup.add(new THREE.Mesh(g, bMat));
});
}

// Buildings — placed at intervals on both sides
if (doBuildings) {
var bldgStep = 50 / density;
var nBldg = Math.floor(trackLen / bldgStep);
var seed = 12345;
function prng() { seed = (seed * 16807 + 0) % 2147483647; return (seed - 1) / 2147483646; }
for (var i = 0; i < nBldg; i++) {
var frac = i / nBldg;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
for (var side = -1; side <= 1; side += 2) {
var h = maxH * (0.3 + prng() * 0.7);
var w = 12 + prng() * 20;
var d = 12 + prng() * 15;
var dist = setback + prng() * 20;
var cx = tp.pos[0] + rv[0] * side * dist;
var cy = tp.pos[1] + h/2;
var cz = tp.pos[2] + rv[2] * side * dist;
var ci = Math.floor(prng() * theme.bldgColors.length);
var bldg = new THREE.Mesh(
new THREE.BoxGeometry(w, h, d),
new THREE.MeshPhongMaterial({color: theme.bldgColors[ci], emissive: theme.bldgEmit[ci]})
);
bldg.position.set(cx, cy, cz);
// Orient along track
bldg.lookAt(cx + tp.fwd[0], cy, cz + tp.fwd[2]);
sceneryGroup.add(bldg);
// Window strips
var winRows = Math.floor(h / 8);
for (var wr = 0; wr < winRows; wr++) {
var wy = -h/2 + 6 + wr * 8;
var winStrip = new THREE.Mesh(
new THREE.BoxGeometry(w * 0.9, 1.5, d + 0.2),
new THREE.MeshPhongMaterial({color: theme.windowColor, emissive: theme.windowEmit, transparent: true, opacity: 0.6 + prng() * 0.4})
);
winStrip.position.y = wy;
bldg.add(winStrip);
}
}
}
}

// Arches — overhead gates at intervals
if (doArches) {
var archStep = 200 / density;
var nArch = Math.floor(trackLen / archStep);
for (var i = 0; i < nArch; i++) {
var frac = (i + 0.5) / nArch;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
var archW = defWidth + 10, archH = 25, poleR = 1.5;
var archMat = new THREE.MeshPhongMaterial({color: theme.archColor, emissive: theme.archEmit});
// Left pole
var lp = new THREE.Mesh(new THREE.CylinderGeometry(poleR, poleR, archH, 6), archMat);
lp.position.set(tp.pos[0] - rv[0]*archW/2, tp.pos[1] + archH/2, tp.pos[2] - rv[2]*archW/2);
sceneryGroup.add(lp);
// Right pole
var rp = new THREE.Mesh(new THREE.CylinderGeometry(poleR, poleR, archH, 6), archMat);
rp.position.set(tp.pos[0] + rv[0]*archW/2, tp.pos[1] + archH/2, tp.pos[2] + rv[2]*archW/2);
sceneryGroup.add(rp);
// Crossbar
var bar = new THREE.Mesh(new THREE.BoxGeometry(archW, 2, 3), archMat);
bar.position.set(tp.pos[0], tp.pos[1] + archH, tp.pos[2]);
bar.lookAt(tp.pos[0] + tp.fwd[0], tp.pos[1] + archH, tp.pos[2] + tp.fwd[2]);
sceneryGroup.add(bar);
}
}

// Streetlights — poles with point lights
if (doLights) {
var lightStep = 80 / density;
var nLights = Math.floor(trackLen / lightStep);
var poleMat = new THREE.MeshPhongMaterial({color: theme.poleColor});
var bulbMat = new THREE.MeshPhongMaterial({color: theme.lightColor, emissive: theme.lightEmit});
for (var i = 0; i < nLights; i++) {
var frac = i / nLights;
var tp = getTrackPointAt(frac);
var rv = crs(tp.fwd, tp.norm); var rl = Math.sqrt(rv[0]**2+rv[1]**2+rv[2]**2)||1;
rv = [rv[0]/rl, rv[1]/rl, rv[2]/rl];
var side = (i % 2 === 0) ? -1 : 1;
var dist = (defWidth / 2) + 5;
var px = tp.pos[0] + rv[0] * side * dist;
var pz = tp.pos[2] + rv[2] * side * dist;
var py = tp.pos[1];
// Pole
var pole = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 15, 4), poleMat);
pole.position.set(px, py + 7.5, pz);
sceneryGroup.add(pole);
// Bulb
var bulb = new THREE.Mesh(new THREE.SphereGeometry(1.2, 6, 4), bulbMat);
bulb.position.set(px, py + 15.5, pz);
sceneryGroup.add(bulb);
// Light
var pl = new THREE.PointLight(theme.lightColor, theme.lightIntensity, 40, 1);
pl.position.set(px, py + 15, pz);
sceneryGroup.add(pl);
}
}

scene.add(sceneryGroup);
sceneryGroup.visible = document.getElementById('chk-scenery').checked;
toast('Scenery generated');
}

function clearScenery() {
if (sceneryGroup) { scene.remove(sceneryGroup); sceneryGroup = null; }
}
function toggleScenery() { if (sceneryGroup) sceneryGroup.visible = document.getElementById('chk-scenery').checked; }

function exportAll(){
var d={track:trackData.map(function(p){return[Math.round(p[0][0]*10)/10,Math.round(p[0][1]*10)/10,Math.round(p[0][2]*10)/10,Math.round(p[1][0]*1e4)/1e4,Math.round(p[1][1]*1e4)/1e4,Math.round(p[1][2]*1e4)/1e4]}),
speedPads:speedPadData,aiCars:aiCarData,
terrain:{amplitude:parseFloat(document.getElementById('s-amp').value),frequency:parseFloat(document.getElementById('s-freq').value),octaves:parseInt(document.getElementById('s-oct').value),seed:parseInt(document.getElementById('s-seed').value),resolution:parseInt(document.getElementById('s-res').value),extent:parseFloat(document.getElementById('s-ext').value)}};
var b=new Blob([JSON.stringify(d,null,2)],{type:'application/json'});var u=URL.createObjectURL(b);var a=document.createElement('a');a.href=u;a.download='track_scene.json';a.click();URL.revokeObjectURL(u);toast('Scene exported')}

// ============================================================
// IMAGE TO TRACK
// ============================================================
var uploadedImage = null;

function handleImageUpload(e) {
var file = e.target.files[0];
if (!file) return;
var reader = new FileReader();
reader.onload = function(ev) {
var img = new Image();
img.onload = function() {
uploadedImage = img;
processImageToTrack(img);
};
img.src = ev.target.result;
};
reader.readAsDataURL(file);
e.target.value = '';
}

function processImageToTrack(img) {
var scale = parseFloat(document.getElementById('s-imgscale').value);
var targetPts = parseInt(document.getElementById('s-imgpts').value);
var smoothIter = parseInt(document.getElementById('s-imgsmooth').value);
var maxW = 600;
var ratio = Math.min(1, maxW / img.width);
var w = Math.round(img.width * ratio);
var h = Math.round(img.height * ratio);
var cv = document.getElementById('img-canvas');
cv.width = w; cv.height = h;
var ctx = cv.getContext('2d');
ctx.drawImage(img, 0, 0, w, h);
document.getElementById('img-preview').style.display = 'block';
document.getElementById('img-status').textContent = 'Processing...';
var imgData = ctx.getImageData(0, 0, w, h);
var data = imgData.data;
var gray = new Float32Array(w * h);
for (var i = 0; i < w * h; i++) {
gray[i] = (data[i*4] * 0.299 + data[i*4+1] * 0.587 + data[i*4+2] * 0.114) / 255;
}
var bestThresh = 0.5;
var bestVar = 0;
for (var t = 0.1; t < 0.9; t += 0.02) {
var w0 = 0, w1 = 0, s0 = 0, s1 = 0;
for (var i = 0; i < gray.length; i++) {
if (gray[i] < t) { w0++; s0 += gray[i]; }
else { w1++; s1 += gray[i]; }
}
if (w0 === 0 || w1 === 0) continue;
var m0 = s0/w0, m1 = s1/w1;
var v = w0 * w1 * (m0 - m1) * (m0 - m1);
if (v > bestVar) { bestVar = v; bestThresh = t; }
}
var mask = new Uint8Array(w * h);
for (var i = 0; i < gray.length; i++) {
mask[i] = gray[i] < bestThresh ? 1 : 0;
}
var dist = new Float32Array(w * h);
var queue = [];
for (var y = 0; y < h; y++) {
for (var x = 0; x < w; x++) {
var idx = y * w + x;
if (mask[idx] === 0) { dist[idx] = 0; queue.push(idx); }
else dist[idx] = 99999;
}
}
var qi = 0;
while (qi < queue.length) {
var idx = queue[qi++];
var x = idx % w, y = Math.floor(idx / w);
var d = dist[idx] + 1;
var neighbors = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
for (var ni = 0; ni < neighbors.length; ni++) {
var nx = neighbors[ni][0], ny = neighbors[ni][1];
if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
var nidx = ny * w + nx;
if (d < dist[nidx]) { dist[nidx] = d; queue.push(nidx); }
}
}
var ridge = [];
for (var y = 2; y < h - 2; y++) {
for (var x = 2; x < w - 2; x++) {
var idx = y * w + x;
if (mask[idx] === 0) continue;
var d = dist[idx];
if (d < 1.5) continue;
var isMax = true;
for (var dy = -1; dy <= 1 && isMax; dy++) {
for (var dx = -1; dx <= 1 && isMax; dx++) {
if (dx === 0 && dy === 0) continue;
if (dist[(y+dy)*w+(x+dx)] > d) isMax = false;
}
}
if (isMax) ridge.push({ x: x, y: y, d: d });
}
}
if (ridge.length < 10) {
document.getElementById('img-status').textContent = 'No line found! Try a clearer image.';
return;
}
var gridSize = 10;
var gridW = Math.ceil(w / gridSize), gridH = Math.ceil(h / gridSize);
var sgrid = new Array(gridW * gridH);
for(var i=0;i<sgrid.length;i++)sgrid[i]=[];
ridge.forEach(function(p, i) {
var gx = Math.floor(p.x / gridSize), gy = Math.floor(p.y / gridSize);
sgrid[gy * gridW + gx].push(i);
});
function findNearest(last, used, maxDist) {
var gx = Math.floor(last.x / gridSize), gy = Math.floor(last.y / gridSize);
var searchR = Math.ceil(maxDist / gridSize) + 1;
var bestIdx = -1, bestDist = maxDist * maxDist;
for (var dy = -searchR; dy <= searchR; dy++) {
for (var dx = -searchR; dx <= searchR; dx++) {
var nx = gx + dx, ny = gy + dy;
if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
var cell = sgrid[ny * gridW + nx];
for (var ci = 0; ci < cell.length; ci++) {
var j = cell[ci];
if (used.has(j)) continue;
var ddx = ridge[j].x - last.x, ddy = ridge[j].y - last.y;
var dd = ddx*ddx + ddy*ddy;
if (dd < bestDist) { bestDist = dd; bestIdx = j; }
}
}
}
return bestIdx;
}
var startIdx = 0;
var minY2 = Infinity;
for (var i = 0; i < ridge.length; i++) {
if (ridge[i].y < minY2) { minY2 = ridge[i].y; startIdx = i; }
}
var ordered = [ridge[startIdx]];
var used = new Set([startIdx]);
var maxGap = 25;
for (var iter = 0; iter < ridge.length - 1; iter++) {
var last = ordered[ordered.length - 1];
var bestIdx = findNearest(last, used, maxGap);
if (bestIdx < 0) break;
ordered.push(ridge[bestIdx]);
used.add(bestIdx);
}
var totalPathLen = ordered.reduce(function(sum, p, i) {
if (i === 0) return 0;
return sum + Math.hypot(p.x - ordered[i-1].x, p.y - ordered[i-1].y);
}, 0);
var step = totalPathLen / targetPts;
var sampled = [ordered[0]];
var accum = 0;
for (var i = 1; i < ordered.length; i++) {
accum += Math.hypot(ordered[i].x - ordered[i-1].x, ordered[i].y - ordered[i-1].y);
if (accum >= step) {
sampled.push(ordered[i]);
accum = 0;
}
}
var pts = sampled.map(function(p) { return { x: p.x, y: p.y }; });
for (var iter = 0; iter < smoothIter; iter++) {
var next = pts.map(function(p, i) {
if (i === 0 || i === pts.length - 1) return { x: p.x, y: p.y };
return {
x: p.x * 0.5 + (pts[i-1].x + pts[i+1].x) * 0.25,
y: p.y * 0.5 + (pts[i-1].y + pts[i+1].y) * 0.25
};
});
pts = next;
}
var imgCx = w / 2, imgCy = h / 2;
var worldScale = scale / Math.max(w, h);
var baseY = -250;
var newTrack = pts.map(function(p) {
var wx = (p.x - imgCx) * worldScale;
var wz = (p.y - imgCy) * worldScale;
return [[wx, baseY, wz], [0, 1, 0]];
});
if (newTrack.length >= 3) {
var first = newTrack[0][0], last = newTrack[newTrack.length - 1][0];
var gap = Math.hypot(first[0]-last[0], first[2]-last[2]);
if (gap < scale * 0.15) {
var closePts = Math.max(3, Math.round(gap / (totalPathLen * worldScale / targetPts)));
for (var i = 1; i <= closePts; i++) {
var t = i / (closePts + 1);
newTrack.push([
[last[0] + (first[0]-last[0])*t, baseY, last[2] + (first[2]-last[2])*t],
[0, 1, 0]
]);
}
newTrack.push([[first[0],first[1],first[2]], [0, 1, 0]]);
}
}
trackData = newTrack;
origData = JSON.parse(JSON.stringify(trackData));
cps = []; loopAdded = 0; selCP = -1;
buildVis(); updateCPVis(); updateStats(); fitView();
ctx.strokeStyle = '#ff6b35';
ctx.lineWidth = 2;
ctx.beginPath();
pts.forEach(function(p, i) { i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y); });
ctx.stroke();
ctx.fillStyle = 'rgba(0,212,170,0.3)';
ordered.forEach(function(p) { ctx.fillRect(p.x-1, p.y-1, 2, 2); });
document.getElementById('img-status').textContent = pts.length + ' pts traced (' + ridge.length + ' ridge px)';
toast('Track traced: ' + newTrack.length + ' points');
}

// ============================================================
// PLAY MODE
// ============================================================
var gameActive = false;

function startGame() {
try {
if (trackData.length < 20) { toast('Track too short to play'); return; }
var exportedTrack = trackData.map(function(p) { return [
[Math.round(p[0][0]*10)/10, Math.round(p[0][1]*10)/10, Math.round(p[0][2]*10)/10],
[Math.round(p[1][0]*1e4)/1e4, Math.round(p[1][1]*1e4)/1e4, Math.round(p[1][2]*1e4)/1e4]
]; });
toast('Loading Horizon Drive...');
var overlay = document.getElementById('game-overlay');
var iframe = document.getElementById('game-iframe');
// Listen for messages from the game iframe
window._gameMessageHandler = function(e) {
if (e.data && e.data.type === 'gameReady') {
  iframe.contentWindow.postMessage({ type: 'trackData', track: exportedTrack }, '*');
}
if (e.data && e.data.type === 'gameExit') {
  stopGame();
}
};
window.addEventListener('message', window._gameMessageHandler);
iframe.src = 'game.html';
overlay.style.display = 'block';
gameActive = true;
window._gameEscHandler = function(e) { if (e.key === 'Escape') stopGame(); };
window.addEventListener('keydown', window._gameEscHandler);
} catch(err) { toast('Launch error: ' + err.message); console.error(err); }
}

function stopGame() {
var overlay = document.getElementById('game-overlay');
var iframe = document.getElementById('game-iframe');
overlay.style.display = 'none';
iframe.src = 'about:blank';
gameActive = false;
if (window._gameMessageHandler) {
window.removeEventListener('message', window._gameMessageHandler);
window._gameMessageHandler = null;
}
if (window._gameEscHandler) {
window.removeEventListener('keydown', window._gameEscHandler);
window._gameEscHandler = null;
}
toast('Back to editor');
}

// ============================================================
// MARBLE WORLD GENERATION + SPARK.JS SPLAT VIEWER
// ============================================================
var _proxyUrl = 'https://accel-driv-proxy.phhowell.workers.dev';
var _RUNWAY_PREFIX = 'https://api.dev.runwayml.com/v1/';
var _MARBLE_PREFIX = 'https://api.worldlabs.ai/marble/v1/';
var _DECART_PREFIX = 'https://api.decart.ai/v1/';
var _KIRI_PREFIX = 'https://api.kiriengine.app/api/';
var _RUNPOD_PREFIX = 'https://rest.runpod.io/v1/';
var _RUNPOD_SLS_PREFIX = 'https://api.runpod.ai/v2/';
var _RUNPOD_GQL_URL = 'https://api.runpod.io/graphql';
async function proxiedFetch(url, opts) {
  opts = opts || {};
  if (_proxyUrl) {
    var workerPath = null;
    if (url.indexOf(_RUNWAY_PREFIX) === 0) workerPath = '/runway/' + url.slice(_RUNWAY_PREFIX.length);
    else if (url.indexOf(_MARBLE_PREFIX) === 0) workerPath = '/marble/' + url.slice(_MARBLE_PREFIX.length);
    else if (url.indexOf(_DECART_PREFIX) === 0) workerPath = '/decart/' + url.slice(_DECART_PREFIX.length);
    else if (url.indexOf(_KIRI_PREFIX) === 0) workerPath = '/kiri/' + url.slice(_KIRI_PREFIX.length);
    else if (url.indexOf(_RUNPOD_SLS_PREFIX) === 0) workerPath = '/runpod-sls/' + url.slice(_RUNPOD_SLS_PREFIX.length);
    else if (url === _RUNPOD_GQL_URL) workerPath = '/runpod-gql';
    else if (url.indexOf(_RUNPOD_PREFIX) === 0) workerPath = '/runpod/' + url.slice(_RUNPOD_PREFIX.length);
    if (workerPath) {
      // Strip auth headers — Worker adds them server-side
      var h = {};
      if (opts.headers) { for (var k in opts.headers) { var kl = k.toLowerCase(); if (kl !== 'authorization' && kl !== 'wlt-api-key' && kl !== 'x-api-key' && kl !== 'x-runway-version') h[k] = opts.headers[k]; } }
      return fetch(_proxyUrl + workerPath, Object.assign({}, opts, { headers: h }));
    }
    // Non-API URL: try direct, fallback to Worker generic proxy
    try { return await fetch(url, opts); }
    catch (e) { return fetch(_proxyUrl + '/fetch?url=' + encodeURIComponent(url), opts); }
  }
  try { return await fetch(url, opts); }
  catch (e) { return fetch('https://corsproxy.io/?' + encodeURIComponent(url), opts); }
}

// ---- Visibility-aware polling sleep ----
// When the tab is backgrounded, browsers throttle setTimeout to >=1s (or pause entirely).
// This mechanism lets polling loops be woken up early when the tab regains focus.
var _pollWakeResolvers = [];
function pollSleep(ms) {
  return new Promise(function(resolve) {
    var done = false;
    var timer = setTimeout(function() { if (!done) { done = true; resolve('timer'); } }, ms);
    _pollWakeResolvers.push(function() { if (!done) { done = true; clearTimeout(timer); resolve('wake'); } });
  });
}
function wakePollLoops() {
  var fns = _pollWakeResolvers.splice(0);
  fns.forEach(function(fn) { fn(); });
}
document.addEventListener('visibilitychange', function() {
  if (!document.hidden) {
    wakePollLoops();
    showRunwayPending();
    showDecartPending();
    showMarblePending();
  }
});

// ---- Runway pending state persistence ----
function saveRunwayPending(taskId, apiKey) {
  localStorage.setItem('runway_pending', JSON.stringify({ taskId: taskId, apiKey: apiKey, time: Date.now() }));
}
function clearRunwayPending() {
  localStorage.removeItem('runway_pending');
  var el = document.getElementById('runway-pending'); if (el) el.style.display = 'none';
}
function showRunwayPending() {
  var raw = localStorage.getItem('runway_pending'); if (!raw) return;
  try { var p = JSON.parse(raw); } catch(e) { return; }
  var age = Math.round((Date.now() - p.time) / 60000);
  if (age > 15) { clearRunwayPending(); return; }
  var el = document.getElementById('runway-pending'); if (!el) return;
  document.getElementById('runway-pending-info').textContent = 'Task: ' + p.taskId.substring(0, 12) + '... (' + age + ' min ago)';
  el.style.display = 'block';
}
async function checkRunwayOperation() {
  var raw = localStorage.getItem('runway_pending'); if (!raw) { toast('No pending Runway task'); return; }
  try { var p = JSON.parse(raw); } catch(e) { toast('Invalid pending data'); clearRunwayPending(); return; }
  var progEl = document.getElementById('runway-progress');
  var pendEl = document.getElementById('runway-pending');
  progEl.style.display = 'block';
  progEl.textContent = 'Checking Runway task status...';
  pendEl.style.display = 'none';
  var apiKey = p.apiKey || document.getElementById('runway-apikey').value.trim();
  if (!apiKey) { toast('Enter your Runway API key first'); pendEl.style.display = 'block'; return; }
  var headers = { 'Authorization': 'Bearer ' + apiKey, 'X-Runway-Version': '2024-11-06' };
  try {
    var res = await proxiedFetch('https://api.dev.runwayml.com/v1/tasks/' + p.taskId, { headers: headers });
    if (!res.ok) throw new Error('Poll failed: ' + res.status);
    var data = await res.json();
    if (data.status === 'SUCCEEDED') {
      clearRunwayPending();
      _runwayVideoUrl = data.output[0];
      var videoEl = document.getElementById('runway-video');
      videoEl.src = _runwayVideoUrl; videoEl.style.display = 'block';
      progEl.textContent = 'Runway stylization complete!';
      toast('Runway video ready');
    } else if (data.status === 'FAILED') {
      clearRunwayPending();
      throw new Error('Runway failed: ' + (data.failureCode || 'unknown'));
    } else if (data.status === 'CANCELED') {
      clearRunwayPending();
      throw new Error('Runway task canceled');
    } else {
      progEl.textContent = 'Still generating — resuming poll...';
      _runwayVideoUrl = await pollRunwayTask(p.taskId, apiKey, progEl);
      var videoEl = document.getElementById('runway-video');
      videoEl.src = _runwayVideoUrl; videoEl.style.display = 'block';
      progEl.textContent = 'Runway stylization complete!';
      toast('Runway video ready');
    }
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('Runway error: ' + err.message);
    console.error('Runway check error:', err);
  }
}

var _splatMesh = null;
var _sparkLoaded = false;

async function ensureSparkLoaded() {
if (_sparkLoaded) return;
if (window.Spark) { _sparkLoaded = true; return; }
var mod = await import('https://cdn.jsdelivr.net/npm/@sparkjsdev/spark@0.1.10/dist/spark.module.js');
window.Spark = mod;
_sparkLoaded = true;
}

function captureScreenshot() {
if (!trackData.length) { rndr.render(scene, cam); return rndr.domElement.toDataURL('image/png'); }
// Save current camera state
var savePhi = orb.phi, saveTheta = orb.theta, saveDist = orb.dist;
var saveTgt = orb.tgt.clone();
// Compute track bounding box
var minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
trackData.forEach(function(p){
minX=Math.min(minX,p[0][0]);maxX=Math.max(maxX,p[0][0]);
minY=Math.min(minY,p[0][1]);maxY=Math.max(maxY,p[0][1]);
minZ=Math.min(minZ,p[0][2]);maxZ=Math.max(maxZ,p[0][2]);
});
// Top-down: phi=0.001 (nearly straight down), theta=0
orb.tgt.set((minX+maxX)/2,(minY+maxY)/2,(minZ+maxZ)/2);
orb.phi = 0.001;
orb.theta = 0;
orb.dist = Math.max(maxX-minX, maxZ-minZ) * 1.1;
updCam();
rndr.render(scene, cam);
var dataUrl = rndr.domElement.toDataURL('image/png');
// Restore camera
orb.phi = savePhi; orb.theta = saveTheta; orb.dist = saveDist;
orb.tgt.copy(saveTgt);
updCam();
return dataUrl;
}

function analyzeTrack() {
if (trackData.length < 20) return { flat: true, tight: false, compact: true, elRange: 0, avgCurv: 0, hasLoop: false };
var pts = trackData.map(function(p) { return p[0]; });
var minY = Infinity, maxY = -Infinity, minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
var totalCurv = 0, segCount = 0;
for (var i = 0; i < pts.length; i++) {
var y = pts[i][1]; if (y < minY) minY = y; if (y > maxY) maxY = y;
var x = pts[i][0]; if (x < minX) minX = x; if (x > maxX) maxX = x;
var z = pts[i][2]; if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
if (i > 0 && i < pts.length - 1) {
var ax = pts[i-1][0], az = pts[i-1][2], bx = pts[i][0], bz = pts[i][2], cx = pts[i+1][0], cz = pts[i+1][2];
var d1x = bx-ax, d1z = bz-az, d2x = cx-bx, d2z = cz-bz;
var l1 = Math.sqrt(d1x*d1x+d1z*d1z)||1, l2 = Math.sqrt(d2x*d2x+d2z*d2z)||1;
var dot = (d1x*d2x+d1z*d2z)/(l1*l2);
totalCurv += Math.acos(Math.max(-1,Math.min(1,dot)));
segCount++;
}
}
var elRange = maxY - minY;
var avgCurv = segCount > 0 ? totalCurv / segCount : 0;
var spanX = maxX - minX, spanZ = maxZ - minZ;
var footprint = Math.max(spanX, spanZ);
var hasLoop = elRange > 40;
return { flat: elRange < 8, hilly: elRange >= 8 && elRange < 30, mountainous: elRange >= 30,
tight: avgCurv > 0.06, flowing: avgCurv <= 0.03, compact: footprint < 150, sprawling: footprint > 400,
elRange: elRange, avgCurv: avgCurv, footprint: footprint, hasLoop: hasLoop };
}

var _capturedScreenshot = null;

function trackAwarePrompt() {
if (trackData.length < 20) { toast('Load a track first'); return; }
// 1. Capture screenshot
_capturedScreenshot = captureScreenshot();
var preview = document.getElementById('marble-screenshot-preview');
document.getElementById('marble-screenshot-img').src = _capturedScreenshot;
preview.style.display = 'block';
// 2. Set input mode to screenshot
document.getElementById('marble-mode').value = 'screenshot';
// 3. Generate geometry-aware prompt
var t = analyzeTrack();
var p = 'racing track environment';
if (t.mountainous || t.hasLoop) p = 'dramatic mountain racing road with steep elevation changes and vertical sections';
else if (t.hilly) p = 'hillside racing road winding through varied terrain';
else p = 'wide racing highway on mostly flat ground';
if (t.tight) p += ', tight technical corners and sharp switchbacks';
else if (t.flowing) p += ', long sweeping high-speed curves';
else p += ', a mix of fast straights and medium-speed bends';
if (t.sprawling) p += ', vast open landscape stretching to the horizon';
else if (t.compact) p += ', enclosed arena-style layout surrounded by structures';
p += ', futuristic roadside barriers and signage, dramatic sky, volumetric lighting, photorealistic detail';
document.getElementById('marble-prompt').value = p;
toast('Screenshot captured + prompt generated — hit Generate World');
}

function saveMarblePending(opId, apiKey, quality) {
localStorage.setItem('marble_pending', JSON.stringify({ opId: opId, apiKey: apiKey, quality: quality, time: Date.now() }));
}
function clearMarblePending() {
localStorage.removeItem('marble_pending');
var el = document.getElementById('marble-pending'); if (el) el.style.display = 'none';
}
function showMarblePending() {
var raw = localStorage.getItem('marble_pending'); if (!raw) return;
try { var p = JSON.parse(raw); } catch(e) { return; }
var age = Math.round((Date.now() - p.time) / 60000);
if (age > 30) { clearMarblePending(); return; }
var el = document.getElementById('marble-pending'); if (!el) return;
document.getElementById('marble-pending-info').textContent = 'Operation: ' + p.opId.substring(0, 20) + '... (' + age + ' min ago)';
el.style.display = 'block';
}
function handleMarbleResult(worldData, quality) {
var progEl = document.getElementById('marble-progress');
var assets = worldData.assets;
var splatUrl = null;
var spzUrls = (assets && assets.splats && assets.splats.spz_urls) ? assets.splats.spz_urls : {};
splatUrl = spzUrls[quality] || spzUrls['100k'] || spzUrls['full_res'];
var colliderUrl = null;
if (assets && assets.mesh) { colliderUrl = assets.mesh.collider_mesh_url; }
if (splatUrl) {
document.getElementById('splat-url').value = splatUrl;
progEl.textContent = 'World generated! Loading splat...';
loadSplatFromURL();
if (colliderUrl) { window._marbleColliderUrl = colliderUrl; }
} else {
progEl.textContent = 'World generated! View at: ' + (worldData.world_marble_url || '');
if (worldData.world_marble_url) { window.open(worldData.world_marble_url, '_blank'); }
}

// Populate Stage 3 results panel (download buttons + public URL)
var resultsEl = document.getElementById('marble-vid-results');
var urlInput = document.getElementById('marble-vid-splat-url');
var publicEl = document.getElementById('marble-vid-public-url');
var dlBar = document.getElementById('marble-vid-dl-bar');
if (resultsEl) {
  resultsEl.style.display = splatUrl ? 'block' : 'none';
  if (splatUrl) {
    urlInput.value = splatUrl;
    dlBar.innerHTML = '';
    // Download button for selected quality
    dlBar.appendChild(makeDownloadBtn(splatUrl, 'Download .spz (' + quality + ')', 'marble-world-' + quality + '.spz'));
    // Additional quality options
    var qualities = Object.keys(spzUrls);
    for (var qi = 0; qi < qualities.length; qi++) {
      var q = qualities[qi];
      if (q !== quality && spzUrls[q]) {
        dlBar.appendChild(makeDownloadBtn(spzUrls[q], q, 'marble-world-' + q + '.spz'));
      }
    }
    // Collider mesh download
    if (colliderUrl) {
      dlBar.appendChild(makeDownloadBtn(colliderUrl, 'Collider mesh', 'marble-collider.glb'));
    }
  }
  // Public Marble viewer URL
  if (worldData.world_marble_url) {
    publicEl.style.display = 'block';
    publicEl.innerHTML = 'Public URL: <a href="' + worldData.world_marble_url + '" target="_blank" style="color:var(--accent)">' + worldData.world_marble_url + '</a>';
  } else {
    publicEl.style.display = 'none';
  }
}

toast('World generated!');
}
async function pollMarbleOp(opId, apiKey, quality, progEl) {
// Strip leading "operations/" if present to avoid double-path
var cleanId = opId;
if (cleanId && cleanId.indexOf('operations/') === 0) cleanId = cleanId.slice('operations/'.length);
var startTime = Date.now();
var maxMs = 9 * 60 * 1000; // 9 min wall-clock timeout
while (Date.now() - startTime < maxMs) {
await pollSleep(3000);
var elapsed = Math.round((Date.now() - startTime) / 1000);
progEl.textContent = 'Generating 3D world... (' + elapsed + 's)';
try {
var pollRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/operations/' + cleanId, { headers: { 'WLT-Api-Key': apiKey } });
if (!pollRes.ok) {
console.warn('Poll failed (status ' + pollRes.status + ') for op:', cleanId);
if (pollRes.status === 429) {
progEl.textContent = 'Rate limited — waiting... (' + elapsed + 's)';
await pollSleep(10000);
}
continue;
}
var pollData = await pollRes.json();
if (pollData.done) {
clearMarblePending();
if (pollData.error) throw new Error('Generation error: ' + (pollData.error.message || JSON.stringify(pollData.error)));
return pollData.response;
}
if (pollData.metadata && pollData.metadata.progress) {
progEl.textContent = 'Generating: ' + (pollData.metadata.progress.description || pollData.metadata.progress.status) + ' (' + elapsed + 's)';
}
} catch (e) {
if (e.message.includes('Generation error')) throw e;
console.warn('Poll exception:', e.message);
}
}
throw new Error('Timeout waiting for world generation');
}
async function checkMarbleOperation() {
var raw = localStorage.getItem('marble_pending'); if (!raw) { toast('No pending operation'); return; }
try { var p = JSON.parse(raw); } catch(e) { toast('Invalid pending data'); clearMarblePending(); return; }
var progEl = document.getElementById('marble-progress');
var pendEl = document.getElementById('marble-pending');
progEl.style.display = 'block';
progEl.textContent = 'Checking operation status...';
pendEl.style.display = 'none';
var apiKey = p.apiKey || document.getElementById('marble-apikey').value.trim();
if (!apiKey) { toast('Enter your API key first'); pendEl.style.display = 'block'; return; }
try {
var pollRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/operations/' + p.opId, { headers: { 'WLT-Api-Key': apiKey } });
if (!pollRes.ok) throw new Error('Poll failed: ' + pollRes.status);
var pollData = await pollRes.json();
if (pollData.done) {
clearMarblePending();
if (pollData.error) throw new Error('Generation error: ' + (pollData.error.message || JSON.stringify(pollData.error)));
handleMarbleResult(pollData.response, p.quality || '100k');
} else {
progEl.textContent = 'Still generating — resuming poll...';
var worldData = await pollMarbleOp(p.opId, apiKey, p.quality || '100k', progEl);
handleMarbleResult(worldData, p.quality || '100k');
}
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Error: ' + err.message);
console.error('Marble check error:', err);
}
}
async function generateMarbleWorld() {
var apiKey = document.getElementById('marble-apikey').value.trim();
if (!apiKey) { toast('Enter a Marble API key'); return; }
var prompt = document.getElementById('marble-prompt').value.trim();
var mode = document.getElementById('marble-mode').value;
var quality = document.getElementById('marble-quality').value;
var progEl = document.getElementById('marble-progress');
var btn = document.getElementById('marble-gen-btn');
if (!prompt) { toast('Enter an environment prompt'); return; }
progEl.style.display = 'block';
progEl.textContent = 'Preparing request...';
btn.disabled = true;
btn.textContent = 'Generating...';
var headers = { 'Content-Type': 'application/json', 'WLT-Api-Key': apiKey };
try {
var worldPrompt;
if (mode === 'screenshot' && trackData.length > 10) {
progEl.textContent = 'Capturing viewport screenshot...';
var screenshotDataUrl = _capturedScreenshot || captureScreenshot();
_capturedScreenshot = null;
var blob = await (await fetch(screenshotDataUrl)).blob();
progEl.textContent = 'Uploading screenshot to Marble...';
var uploadRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/media-assets:prepare_upload', {
method: 'POST', headers: headers,
body: JSON.stringify({ file_name: 'track-screenshot.png', kind: 'image', extension: 'png' })
});
if (!uploadRes.ok) throw new Error(uploadRes.status === 401 ? 'Invalid API key — check your Marble key' : 'Media asset creation failed: ' + uploadRes.status);
var uploadData = await uploadRes.json();
var mediaAssetId = uploadData.media_asset.media_asset_id;
var uploadUrl = uploadData.upload_info.upload_url;
var uploadMethod = uploadData.upload_info.upload_method || 'PUT';
var uploadHeaders = uploadData.upload_info.required_headers || {};
await proxiedFetch(uploadUrl, { method: uploadMethod, headers: uploadHeaders, body: blob });
worldPrompt = { type: 'image', image_prompt: { source: 'media_asset', media_asset_id: mediaAssetId }, text_prompt: prompt };
} else {
worldPrompt = { type: 'text', text_prompt: prompt };
}
progEl.textContent = 'Generating 3D world (this takes 1-3 minutes)...';
var genRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/worlds:generate', {
method: 'POST', headers: headers,
body: JSON.stringify({ display_name: 'Track Environment', model: 'Marble 0.1-plus', world_prompt: worldPrompt })
});
if (!genRes.ok) { if (genRes.status === 401) throw new Error('Invalid API key — check your Marble key'); var errText = await genRes.text(); throw new Error('Generation failed (' + genRes.status + '): ' + errText); }
var genData = await genRes.json();
var opId = genData.operation_id || genData.name;
var worldData = null;
if (genData.done && genData.response) {
worldData = genData.response;
} else if (opId) {
saveMarblePending(opId, apiKey, quality);
progEl.textContent = 'Generating 3D world... (you can close this tab and check back later)';
worldData = await pollMarbleOp(opId, apiKey, quality, progEl);
} else {
worldData = genData.world || genData;
}
handleMarbleResult(worldData, quality);
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Error: ' + err.message);
console.error('Marble generation error:', err);
} finally {
btn.disabled = false;
btn.textContent = 'Generate World';
}
}

// ============================================================
// PANORAMA CAPTURE PIPELINE (CubeCamera → equirect → Marble)
// ============================================================
var _panoCaptures = null;
var _panoMarkerGroup = null;

function clearPanoMarkers() {
if (_panoMarkerGroup) { scene.remove(_panoMarkerGroup); _panoMarkerGroup = null; }
}

function showPanoMarkers(captures, camHeight) {
clearPanoMarkers();
if (!captures || !captures.length) return;
_panoMarkerGroup = new THREE.Group();
_panoMarkerGroup.name = 'panoMarkers';

var sphereGeo = new THREE.SphereGeometry(4, 12, 8);
var coneGeo = new THREE.ConeGeometry(3, 10, 8);

for (var i = 0; i < captures.length; i++) {
var c = captures[i];
var px = c.position.x, py = c.position.y, pz = c.position.z;
var camY = py + camHeight;

// Camera position sphere (cyan)
var sphere = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ color: 0x00ffcc }));
sphere.position.set(px, camY, pz);
_panoMarkerGroup.add(sphere);

// Vertical pole from track to camera
var poleGeo = new THREE.BufferGeometry().setFromPoints([
new THREE.Vector3(px, py, pz), new THREE.Vector3(px, camY, pz)
]);
var pole = new THREE.Line(poleGeo, new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.5 }));
_panoMarkerGroup.add(pole);

// Direction arrow (cone pointing along tangent)
var cone = new THREE.Mesh(coneGeo, new THREE.MeshBasicMaterial({ color: 0xff44cc }));
cone.position.set(px + c.tangent.x * 12, camY, pz + c.tangent.z * 12);
cone.lookAt(px, camY, pz);
cone.rotateX(Math.PI / 2);
_panoMarkerGroup.add(cone);

// Index label sprite
var cv = document.createElement('canvas');
cv.width = 64; cv.height = 32;
var ctx = cv.getContext('2d');
ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 64, 32);
ctx.fillStyle = '#00ffcc'; ctx.font = 'bold 20px monospace'; ctx.textAlign = 'center';
ctx.fillText('#' + i, 32, 22);
var tex = new THREE.CanvasTexture(cv);
var spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
var sprite = new THREE.Sprite(spriteMat);
sprite.position.set(px, camY + 8, pz);
sprite.scale.set(20, 10, 1);
_panoMarkerGroup.add(sprite);
}

scene.add(_panoMarkerGroup);
}

function buildTrackSpline() {
if (trackData.length < 20) return null;
var pts = [];
var step = Math.max(1, Math.floor(trackData.length / 500));
for (var i = 0; i < trackData.length; i += step) {
pts.push(new THREE.Vector3(trackData[i][0][0], trackData[i][0][1], trackData[i][0][2]));
}
var last = trackData[trackData.length - 1][0];
if (pts.length < 2 || pts[pts.length - 1].distanceTo(new THREE.Vector3(last[0], last[1], last[2])) > 1) {
pts.push(new THREE.Vector3(last[0], last[1], last[2]));
}
var first = trackData[0][0];
var gap = Math.hypot(first[0] - last[0], first[1] - last[1], first[2] - last[2]);
return new THREE.CatmullRomCurve3(pts, gap < 50, 'catmullrom', 0.5);
}

function capturePanoramasAlongTrack(numSections, camHeight, cubeRes, rangeStart, rangeEnd) {
var spline = buildTrackSpline();
if (!spline) { toast('Load a track first'); return null; }
var isClosed = spline.closed;
var tStart = (rangeStart || 0) / 100;
var tEnd = (rangeEnd != null ? rangeEnd : 100) / 100;
if (tEnd <= tStart) { toast('Range end must be greater than start'); return null; }

// CubeCamera setup
var cubeRT = new THREE.WebGLCubeRenderTarget(cubeRes, {
format: THREE.RGBAFormat, generateMipmaps: false
});
var cubeCamera = new THREE.CubeCamera(1, 20000, cubeRT);

// Equirect render target (same GL context as main renderer)
var eqW = cubeRes * 2, eqH = cubeRes;
var equirectRT = new THREE.WebGLRenderTarget(eqW, eqH);

// Equirect conversion shader: cubemap UV → spherical direction lookup
var equirectMat = new THREE.ShaderMaterial({
uniforms: { cubeMap: { value: null } },
vertexShader: 'varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}',
fragmentShader: [
'uniform samplerCube cubeMap;',
'varying vec2 vUv;',
'#define PI 3.14159265359',
'void main(){',
'  float lon=vUv.x*2.0*PI-PI;',
'  float lat=vUv.y*PI-PI*0.5;',
'  vec3 dir=vec3(cos(lat)*sin(lon),sin(lat),cos(lat)*cos(lon));',
'  gl_FragColor=textureCube(cubeMap,dir);',
'}'
].join('\n'),
depthTest: false, depthWrite: false
});
var eqScene = new THREE.Scene();
var eqCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
eqScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), equirectMat));

// Hide editor overlays and section splats during capture
var hidden = [];
[ptCloud, selHL, cpGrp, splineLine, _panoMarkerGroup].forEach(function(obj) {
if (obj && obj.visible) { obj.visible = false; hidden.push(obj); }
});
for (var si = 0; si < _sectionSplats.length; si++) {
var sm = _sectionSplats[si].mesh;
if (sm && sm.visible) { sm.visible = false; hidden.push(sm); }
}
scene.traverse(function(obj) {
if (obj.type === 'GridHelper' && obj.visible) { obj.visible = false; hidden.push(obj); }
});

// Enable autoClear for clean cube face renders
var savedAutoClear = rndr.autoClear;
rndr.autoClear = true;

var results = [];
var pixels = new Uint8Array(eqW * eqH * 4);
var canvas = document.createElement('canvas');
canvas.width = eqW; canvas.height = eqH;
var ctx = canvas.getContext('2d');

for (var i = 0; i < numSections; i++) {
var frac = numSections > 1 ? i / (numSections - 1) : 0;
var t = tStart + (tEnd - tStart) * frac;
t = Math.min(t, 0.9999);

var pos = spline.getPointAt(t);
var tangent = spline.getTangentAt(t).normalize();

// Capture cube map at this track position
cubeCamera.position.set(pos.x, pos.y + camHeight, pos.z);
cubeCamera.update(rndr, scene);

// Convert cubemap → equirectangular via fullscreen quad shader
equirectMat.uniforms.cubeMap.value = cubeRT.texture;
rndr.setRenderTarget(equirectRT);
rndr.clear();
rndr.render(eqScene, eqCam);
rndr.setRenderTarget(null);

// Read pixels from render target (WebGL is bottom-up, flip to top-down)
rndr.readRenderTargetPixels(equirectRT, 0, 0, eqW, eqH, pixels);
var imageData = ctx.createImageData(eqW, eqH);
for (var row = 0; row < eqH; row++) {
var src = (eqH - 1 - row) * eqW * 4;
var dst2 = row * eqW * 4;
imageData.data.set(pixels.subarray(src, src + eqW * 4), dst2);
}
ctx.putImageData(imageData, 0, 0);

results.push({
index: i, t: t,
position: { x: pos.x, y: pos.y, z: pos.z },
tangent: { x: tangent.x, y: tangent.y, z: tangent.z },
dataUrl: canvas.toDataURL('image/jpeg', 0.92)
});
}

// Restore state
rndr.autoClear = savedAutoClear;
hidden.forEach(function(obj) { obj.visible = true; });
cubeRT.dispose();
equirectRT.dispose();
equirectMat.dispose();

return results;
}

function previewPanoCaptures() {
var numSections = parseInt(document.getElementById('s-pano-sections').value);
var camHeight = parseFloat(document.getElementById('s-pano-height').value);
var cubeRes = parseInt(document.getElementById('s-pano-cuberes').value);
var rangeStart = parseInt(document.getElementById('s-pano-start').value);
var rangeEnd = parseInt(document.getElementById('s-pano-end').value);
var progEl = document.getElementById('pano-progress');
var previewEl = document.getElementById('pano-preview');

progEl.style.display = 'block';
progEl.textContent = 'Capturing ' + numSections + ' panoramas (' + rangeStart + '%-' + rangeEnd + '%)...';

setTimeout(function() {
var captures = capturePanoramasAlongTrack(numSections, camHeight, cubeRes, rangeStart, rangeEnd);
if (!captures) { progEl.style.display = 'none'; return; }

_panoCaptures = captures;

// Show 3D markers in editor viewport
showPanoMarkers(captures, camHeight);

// Build preview grid
var html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:6px;margin-top:8px">';
for (var i = 0; i < captures.length; i++) {
var c = captures[i];
html += '<div style="position:relative;border:1px solid var(--border);border-radius:4px;overflow:hidden">';
html += '<img src="' + c.dataUrl + '" style="width:100%;display:block">';
html += '<div style="position:absolute;bottom:2px;left:4px;font-size:9px;color:var(--accent);font-family:monospace;background:rgba(0,0,0,.7);padding:1px 4px;border-radius:2px">';
html += '#' + i + ' t=' + c.t.toFixed(3);
html += '</div></div>';
}
html += '</div>';
previewEl.innerHTML = html;
previewEl.style.display = 'block';

progEl.textContent = 'Captured ' + captures.length + ' panoramas (' + cubeRes + 'px faces → ' + (cubeRes * 2) + 'x' + cubeRes + ' equirect)';
toast('Panoramas captured');
}, 50);
}

async function uploadImageToMarble(dataUrl, apiKey, fileName) {
var headers = { 'Content-Type': 'application/json', 'WLT-Api-Key': apiKey };
var blob = await (await fetch(dataUrl)).blob();

var uploadRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/media-assets:prepare_upload', {
method: 'POST', headers: headers,
body: JSON.stringify({ file_name: fileName, kind: 'image', extension: 'png' })
});
if (!uploadRes.ok) throw new Error(uploadRes.status === 401 ? 'Invalid API key' : 'Media upload failed: ' + uploadRes.status);
var uploadData = await uploadRes.json();
var mediaAssetId = uploadData.media_asset.media_asset_id;
var uploadUrl = uploadData.upload_info.upload_url;
var uploadMethod = uploadData.upload_info.upload_method || 'PUT';
var uploadHeaders = uploadData.upload_info.required_headers || {};

await proxiedFetch(uploadUrl, { method: uploadMethod, headers: uploadHeaders, body: blob });
return mediaAssetId;
}

async function batchPanoMarble() {
var apiKey = document.getElementById('marble-apikey').value.trim();
if (!apiKey) { toast('Enter a Marble API key in the Generate World panel'); return; }
var prompt = document.getElementById('marble-prompt').value.trim();
if (!prompt) { toast('Enter an environment prompt in the Generate World panel'); return; }
var quality = document.getElementById('marble-quality').value;
var genMode = document.getElementById('s-pano-genmode').value; // 'text' or 'image'

var numSections = parseInt(document.getElementById('s-pano-sections').value);
var camHeight = parseFloat(document.getElementById('s-pano-height').value);
var cubeRes = parseInt(document.getElementById('s-pano-cuberes').value);
var rangeStart = parseInt(document.getElementById('s-pano-start').value);
var rangeEnd = parseInt(document.getElementById('s-pano-end').value);
var progEl = document.getElementById('pano-progress');
var btn = document.getElementById('pano-gen-btn');

btn.disabled = true; btn.textContent = 'Generating...';
progEl.style.display = 'block';

try {
// Step 1: Capture panoramas (reuse cached if settings match)
var captures = _panoCaptures;
if (!captures || captures.length !== numSections) {
progEl.textContent = 'Capturing ' + numSections + ' panoramas (' + rangeStart + '%-' + rangeEnd + '%)...';
await new Promise(function(r) { setTimeout(r, 50); });
captures = capturePanoramasAlongTrack(numSections, camHeight, cubeRes, rangeStart, rangeEnd);
if (!captures) throw new Error('Failed to capture panoramas');
_panoCaptures = captures;
}

var headers = { 'Content-Type': 'application/json', 'WLT-Api-Key': apiKey };
var operations = [];

// Step 2: Upload each panorama and start Marble generation (with 429 retry)
for (var i = 0; i < captures.length; i++) {
var cap = captures[i];
var worldPrompt;

if (genMode === 'image') {
progEl.textContent = 'Uploading panorama ' + (i + 1) + '/' + captures.length + '...';
var mediaAssetId = await uploadImageToMarble(cap.dataUrl, apiKey, 'pano-section-' + i + '.jpg');
worldPrompt = {
type: 'image',
image_prompt: { source: 'media_asset', media_asset_id: mediaAssetId },
text_prompt: prompt
};
} else {
// Text-only: describe the viewpoint with spatial context so each section is unique
var pct = Math.round(cap.t * 100);
var sectionPrompt = prompt + '. This is section ' + (i + 1) + ' of ' + captures.length + ' along a racing track, at ' + pct + '% progress.';
worldPrompt = {
type: 'text',
text_prompt: sectionPrompt
};
}

progEl.textContent = 'Starting generation ' + (i + 1) + '/' + captures.length + ' (' + genMode + ')...';

// Retry with exponential backoff on 429 rate limit
var genRes = null;
var backoff = [5000, 15000, 30000, 60000]; // 5s, 15s, 30s, 60s
for (var attempt = 0; attempt <= backoff.length; attempt++) {
genRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/worlds:generate', {
method: 'POST', headers: headers,
body: JSON.stringify({ display_name: 'Track Section ' + i, model: 'Marble 0.1-plus', world_prompt: worldPrompt })
});
if (genRes.status !== 429) break;
if (attempt < backoff.length) {
var wait = backoff[attempt] / 1000;
progEl.textContent = 'Rate limited — waiting ' + wait + 's before retrying section ' + (i + 1) + '...';
await new Promise(function(r) { setTimeout(r, backoff[attempt]); });
}
}

if (!genRes.ok) {
if (genRes.status === 401) throw new Error('Invalid API key');
if (genRes.status === 429) throw new Error('Rate limit exceeded after retries — try fewer sections or wait a few minutes');
var errText = await genRes.text();
throw new Error('Generation ' + i + ' failed (' + genRes.status + '): ' + errText);
}

var genData = await genRes.json();
var opId = genData.operation_id || genData.name;
console.log('Section ' + i + ' generation response:', { opId: opId, done: genData.done, keys: Object.keys(genData) });

if (genData.done && genData.response) {
operations.push({ capture: cap, worldData: genData.response, done: true });
} else if (opId) {
operations.push({ capture: cap, opId: opId, done: false });
} else {
console.warn('Section ' + i + ': no operation_id or name in response', genData);
}

// Brief delay between requests to avoid hitting rate limits
if (i < captures.length - 1) {
await new Promise(function(r) { setTimeout(r, 2000); });
}
}

// Step 3: Poll all pending operations until complete
var allDone = operations.every(function(op) { return op.done; });
var startTime = Date.now();
var maxMs = 15 * 60 * 1000;
var pollErrors = 0;

while (!allDone && Date.now() - startTime < maxMs) {
await new Promise(function(r) { setTimeout(r, 5000); });
var pending = operations.filter(function(op) { return !op.done; });
var elapsed = Math.round((Date.now() - startTime) / 1000);
progEl.textContent = 'Generating... ' + (operations.length - pending.length) + '/' + operations.length + ' done (' + elapsed + 's)';

for (var j = 0; j < pending.length; j++) {
try {
// Strip leading "operations/" if present to avoid double-path
var pollId = pending[j].opId;
if (pollId && pollId.indexOf('operations/') === 0) pollId = pollId.slice('operations/'.length);
var pollRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/operations/' + pollId, {
headers: { 'WLT-Api-Key': apiKey }
});
if (!pollRes.ok) {
pollErrors++;
var errStatus = pollRes.status;
console.warn('Poll failed for section (status ' + errStatus + '):', pollId);
if (errStatus === 429) {
progEl.textContent = 'Rate limited during polling — backing off... (' + elapsed + 's)';
await new Promise(function(r) { setTimeout(r, 10000); }); // extra 10s backoff
}
continue;
}
pollErrors = 0;
var pollData = await pollRes.json();
if (pollData.done) {
if (pollData.error) {
pending[j].error = pollData.error.message || 'Generation failed';
} else {
pending[j].worldData = pollData.response;
}
pending[j].done = true;
} else if (pollData.metadata && pollData.metadata.progress) {
var desc = pollData.metadata.progress.description || pollData.metadata.progress.status || '';
if (desc) progEl.textContent = (operations.length - pending.length) + '/' + operations.length + ' done — ' + desc + ' (' + elapsed + 's)';
}
} catch (e) {
console.warn('Poll exception:', e.message);
}
// Stagger polls: brief pause between each operation to avoid rate limits
if (j < pending.length - 1) {
await new Promise(function(r) { setTimeout(r, 1000); });
}
}

allDone = operations.every(function(op) { return op.done; });
}

// Step 4: Collect results and build section data
var successful = operations.filter(function(op) { return op.worldData && !op.error; });
var failed = operations.filter(function(op) { return op.error; });

if (successful.length === 0) throw new Error('All generations failed');

var sectionData = successful.map(function(op) {
var assets = op.worldData.assets;
var spzUrls = (assets && assets.splats && assets.splats.spz_urls) ? assets.splats.spz_urls : {};
var splatUrl = spzUrls[quality] || spzUrls['100k'] || spzUrls['full_res'];
return {
t: op.capture.t,
position: op.capture.position,
tangent: op.capture.tangent,
splatUrl: splatUrl,
colliderUrl: assets && assets.mesh ? assets.mesh.collider_mesh_url : null,
publicUrl: op.worldData.world_marble_url
};
});

window._panoSections = sectionData;

// Step 5: Place all splats in the scene at their capture positions
progEl.textContent = 'Loading splats into scene...';
await placeSectionSplats(sectionData, progEl);

// Step 6: Auto-save bundle
saveSectionBundle();

// Show results UI
var previewEl = document.getElementById('pano-preview');
var html = '<div style="margin-top:8px;border:1px solid var(--accent2);border-radius:6px;padding:8px">';
html += '<div style="color:var(--accent2);font-size:11px;font-weight:600;margin-bottom:6px">' + successful.length + '/' + operations.length + ' sections generated</div>';
for (var k = 0; k < sectionData.length; k++) {
var sec = sectionData[k];
html += '<div style="font-size:10px;color:var(--text-dim);margin-bottom:4px;display:flex;gap:6px;align-items:center">';
html += '<span style="color:var(--accent)">Section ' + k + '</span>';
html += '<span>t=' + sec.t.toFixed(3) + '</span>';
if (sec.splatUrl) {
html += '<button class="btn" style="padding:2px 6px;font-size:9px;flex:0" onclick="loadPanoSection(' + k + ')">Load</button>';
}
if (sec.publicUrl) {
html += '<a href="' + sec.publicUrl + '" target="_blank" style="color:var(--accent2);font-size:9px">View</a>';
}
html += '</div>';
}
if (failed.length > 0) {
html += '<div style="color:var(--danger);font-size:10px;margin-top:4px">' + failed.length + ' section(s) failed</div>';
}
html += '<div class="btn-group" style="margin-top:6px">';
html += '<button class="btn btn-accent" onclick="placeSectionSplats(window._panoSections, document.getElementById(\'pano-progress\'))">Place All Splats</button>';
html += '<button class="btn" onclick="clearSectionSplats();toast(\'Section splats removed\')">Remove Splats</button>';
html += '<button class="btn btn-accent2" onclick="saveSectionBundle()">Save Bundle</button>';
html += '</div></div>';
previewEl.innerHTML = html;
previewEl.style.display = 'block';

progEl.textContent = 'Done! ' + successful.length + ' splats generated and placed.';
toast(successful.length + ' track sections generated');

} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Error: ' + err.message);
console.error('Panorama batch error:', err);
} finally {
btn.disabled = false;
btn.textContent = 'Generate All Sections';
}
}

function loadPanoSection(index) {
if (!window._panoSections || !window._panoSections[index]) return;
var sec = window._panoSections[index];
if (!sec.splatUrl) { toast('No splat URL for section ' + index); return; }
document.getElementById('splat-url').value = sec.splatUrl;
loadSplatFromURL();
// Position splat at the capture point on the track
['px','py','pz'].forEach(function(axis, ai) {
var val = Math.round(axis === 'px' ? sec.position.x : axis === 'py' ? sec.position.y : sec.position.z);
var sl = document.getElementById('s-splat' + axis);
var vl = document.getElementById('v-splat' + axis);
if (sl) { sl.value = val; }
if (vl) { vl.textContent = val; }
});
applySplatSettings();
toast('Loading section ' + index + ' splat');
}

function exportPanoSections() {
if (!window._panoSections) { toast('No section data'); return; }
var data = JSON.stringify(window._panoSections, null, 2);
var blob = new Blob([data], { type: 'application/json' });
var url = URL.createObjectURL(blob);
var a = document.createElement('a'); a.href = url; a.download = 'pano-sections.json'; a.click();
URL.revokeObjectURL(url);
toast('Section data exported');
}

// ============================================================
// MULTI-SPLAT SCENE PLACEMENT & BUNDLE SAVE/LOAD
// ============================================================
var _sectionSplats = []; // [{mesh, t, position, tangent, splatUrl}]
var _sectionBundleData = null; // last saved/loaded bundle

function clearSectionSplats() {
for (var i = 0; i < _sectionSplats.length; i++) {
var entry = _sectionSplats[i];
if (entry.mesh) {
scene.remove(entry.mesh);
if (entry.mesh.dispose) entry.mesh.dispose();
}
}
_sectionSplats = [];
}

async function placeSectionSplats(sectionData, progEl) {
await ensureSparkLoaded();
clearSectionSplats();
var Spark = window.Spark;
var loaded = 0;

for (var i = 0; i < sectionData.length; i++) {
var sec = sectionData[i];
if (!sec.splatUrl) continue;
if (progEl) progEl.textContent = 'Loading splat ' + (i + 1) + '/' + sectionData.length + '...';
try {
var mesh = await new Promise(function(resolve, reject) {
var m = new Spark.SplatMesh({
url: sec.splatUrl,
onLoad: function() { resolve(m); }
});
// Timeout after 60s
setTimeout(function() { reject(new Error('Timeout loading splat ' + i)); }, 60000);
});
mesh.position.set(sec.position.x, sec.position.y, sec.position.z);
scene.add(mesh);
_sectionSplats.push({
mesh: mesh, t: sec.t, position: sec.position,
tangent: sec.tangent, splatUrl: sec.splatUrl
});
loaded++;
} catch (err) {
console.warn('Failed to load section splat ' + i + ':', err.message);
}
}
if (progEl) progEl.textContent = loaded + '/' + sectionData.length + ' splats placed in scene.';
toast(loaded + ' splats placed along track');
return loaded;
}

function saveSectionBundle() {
if (!window._panoSections || !window._panoSections.length) { toast('No section data to save'); return; }
var captures = _panoCaptures || [];
var sections = window._panoSections.map(function(sec, i) {
var pano = captures[i];
return {
t: sec.t,
position: sec.position,
tangent: sec.tangent,
splatUrl: sec.splatUrl,
colliderUrl: sec.colliderUrl || null,
publicUrl: sec.publicUrl || null,
panoramaDataUrl: pano ? pano.dataUrl : null
};
});
var bundle = {
version: 1,
timestamp: Date.now(),
created: new Date().toISOString(),
trackPointCount: trackData.length,
sectionCount: sections.length,
sections: sections
};
var json = JSON.stringify(bundle);
var blob = new Blob([json], { type: 'application/json' });
var ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
var filename = 'track-bundle-' + ts + '.json';
var url = URL.createObjectURL(blob);
var a = document.createElement('a'); a.href = url; a.download = filename; a.click();
URL.revokeObjectURL(url);
_sectionBundleData = bundle;
toast('Bundle saved: ' + filename);
}

function loadSectionBundle() {
var input = document.createElement('input');
input.type = 'file'; input.accept = '.json';
input.onchange = async function() {
if (!this.files[0]) return;
var file = this.files[0];
var progEl = document.getElementById('pano-progress');
progEl.style.display = 'block';
progEl.textContent = 'Reading bundle...';
try {
var text = await file.text();
var bundle = JSON.parse(text);
if (!bundle.sections || !bundle.sections.length) throw new Error('No sections in bundle');
_sectionBundleData = bundle;

// Restore _panoSections for the existing per-section Load buttons
window._panoSections = bundle.sections;

// Restore panorama captures if present
if (bundle.sections[0] && bundle.sections[0].panoramaDataUrl) {
_panoCaptures = bundle.sections.map(function(sec, i) {
return {
index: i, t: sec.t,
position: sec.position, tangent: sec.tangent,
dataUrl: sec.panoramaDataUrl
};
});
}

// Show preview UI
var previewEl = document.getElementById('pano-preview');
var created = bundle.created ? ' (' + bundle.created.slice(0, 16).replace('T', ' ') + ')' : '';
var html = '<div style="margin-top:8px;border:1px solid var(--accent);border-radius:6px;padding:8px">';
html += '<div style="color:var(--accent);font-size:11px;font-weight:600;margin-bottom:6px">Loaded bundle: ' + bundle.sectionCount + ' sections' + created + '</div>';

// Panorama thumbnail grid
if (_panoCaptures && _panoCaptures.length) {
html += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:4px;margin-bottom:8px">';
for (var i = 0; i < _panoCaptures.length; i++) {
var c = _panoCaptures[i];
html += '<div style="position:relative;border:1px solid var(--border);border-radius:4px;overflow:hidden">';
html += '<img src="' + c.dataUrl + '" style="width:100%;display:block">';
html += '<div style="position:absolute;bottom:2px;left:4px;font-size:9px;color:var(--accent);font-family:monospace;background:rgba(0,0,0,.7);padding:1px 4px;border-radius:2px">';
html += '#' + i + ' t=' + c.t.toFixed(3) + '</div></div>';
}
html += '</div>';
}

// Section list with Load buttons
for (var k = 0; k < bundle.sections.length; k++) {
var sec = bundle.sections[k];
html += '<div style="font-size:10px;color:var(--text-dim);margin-bottom:4px;display:flex;gap:6px;align-items:center">';
html += '<span style="color:var(--accent)">Section ' + k + '</span>';
html += '<span>t=' + sec.t.toFixed(3) + '</span>';
if (sec.splatUrl) {
html += '<button class="btn" style="padding:2px 6px;font-size:9px;flex:0" onclick="loadPanoSection(' + k + ')">Load</button>';
}
if (sec.publicUrl) {
html += '<a href="' + sec.publicUrl + '" target="_blank" style="color:var(--accent2);font-size:9px">View</a>';
}
html += '</div>';
}
html += '<div class="btn-group" style="margin-top:6px">';
html += '<button class="btn btn-accent" onclick="placeSectionSplats(window._panoSections, document.getElementById(\'pano-progress\'))">Place All Splats</button>';
html += '<button class="btn" onclick="clearSectionSplats();toast(\'Section splats removed\')">Remove Splats</button>';
html += '<button class="btn btn-accent2" onclick="saveSectionBundle()">Re-save Bundle</button>';
html += '</div></div>';
previewEl.innerHTML = html;
previewEl.style.display = 'block';

progEl.textContent = 'Bundle loaded: ' + bundle.sectionCount + ' sections' + created;
toast('Bundle loaded: ' + file.name);

// Show 3D markers if we have captures
if (_panoCaptures && _panoCaptures.length) {
showPanoMarkers(_panoCaptures, 15);
}

} catch (err) {
progEl.textContent = 'Error loading bundle: ' + err.message;
toast('Failed to load bundle');
console.error(err);
}
};
input.click();
}

// ============================================================
// FLYTHROUGH → RUNWAY → MARBLE PIPELINE
// ============================================================
var _flyBlob = null;
var _flyFrames = [];
var _flyPoses = [];
var _flyCamParams = null;
var _runwayVideoUrl = null;

async function recordFlythrough() {
if (trackData.length < 20) { toast('Load a track first'); return; }
var duration = parseInt(document.getElementById('s-flydur').value);
var resVal = document.getElementById('fly-res').value;
var camH = parseFloat(document.getElementById('s-flyht').value);
var w = resVal === '1080' ? 1920 : 1280;
var h = resVal === '1080' ? 1080 : 720;
var fps = 30;
var totalFrames = duration * fps;
var btn = document.getElementById('fly-rec-btn');
var progEl = document.getElementById('fly-progress');
btn.disabled = true; btn.textContent = 'Recording...';
progEl.style.display = 'block'; progEl.textContent = 'Building spline...';

// Build CatmullRomCurve3 from track data
var pts = [];
var step = Math.max(1, Math.floor(trackData.length / 500));
for (var i = 0; i < trackData.length; i += step) {
pts.push(new THREE.Vector3(trackData[i][0][0], trackData[i][0][1], trackData[i][0][2]));
}
var last = trackData[trackData.length - 1][0];
if (pts.length < 2 || pts[pts.length - 1].distanceTo(new THREE.Vector3(last[0], last[1], last[2])) > 1) {
pts.push(new THREE.Vector3(last[0], last[1], last[2]));
}
// Detect closed loop: if start and end are within 50 units, close the spline
var first = trackData[0][0];
var trackGap = Math.hypot(first[0] - last[0], first[1] - last[1], first[2] - last[2]);
var isClosed = trackGap < 50;
var flyCurve = new THREE.CatmullRomCurve3(pts, isClosed, 'catmullrom', 0.5);

// Hide editor-only overlays and section splats during recording
var hidden = [];
[ptCloud, selHL, cpGrp, splineLine, _panoMarkerGroup].forEach(function(obj) {
if (obj && obj.visible) { obj.visible = false; hidden.push(obj); }
});
for (var si = 0; si < _sectionSplats.length; si++) {
var sm = _sectionSplats[si].mesh;
if (sm && sm.visible) { sm.visible = false; hidden.push(sm); }
}
scene.traverse(function(obj) {
if (obj.type === 'GridHelper' && obj.visible) { obj.visible = false; hidden.push(obj); }
});

// Temporary environment for Runway context (sky dome + ground plane)
var _origBg = scene.background;
var _origFog = scene.fog;
scene.background = new THREE.Color(0x050510);
scene.fog = new THREE.FogExp2(0x050510, 0.00015);

// Sky dome: large inverted sphere with vertex-color gradient (horizon glow → dark zenith)
var skyGeo = new THREE.SphereGeometry(8000, 32, 24);
var skyColors = [];
var skyPos = skyGeo.getAttribute('position');
for (var si = 0; si < skyPos.count; si++) {
  var ny = (skyPos.getY(si) / 8000 + 1) * 0.5; // 0 at bottom, 1 at top
  // Horizon: warm dark purple/blue, zenith: near-black with slight blue
  var hr = 0.06, hg = 0.04, hb = 0.12; // horizon
  var zr = 0.01, zg = 0.01, zb = 0.03; // zenith
  var blend = Math.pow(ny, 0.6);
  skyColors.push(hr + (zr - hr) * blend, hg + (zg - hg) * blend, hb + (zb - hb) * blend);
}
skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(skyColors, 3));
var skyMat = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide });
var skyDome = new THREE.Mesh(skyGeo, skyMat);
scene.add(skyDome);

// Stars: scattered points in the sky
var starCount = 800;
var starPositions = new Float32Array(starCount * 3);
for (var si = 0; si < starCount; si++) {
  var phi = Math.acos(2 * Math.random() - 1);
  var theta = Math.random() * Math.PI * 2;
  var sr = 7500 + Math.random() * 400;
  starPositions[si * 3] = sr * Math.sin(phi) * Math.cos(theta);
  starPositions[si * 3 + 1] = Math.abs(sr * Math.cos(phi)); // upper hemisphere only
  starPositions[si * 3 + 2] = sr * Math.sin(phi) * Math.sin(theta);
}
var starGeo = new THREE.BufferGeometry();
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
var starMat = new THREE.PointsMaterial({ color: 0xccccff, size: 6, sizeAttenuation: true });
var starField = new THREE.Points(starGeo, starMat);
scene.add(starField);

// Ground plane: dark textured surface extending to horizon
var groundGeo = new THREE.PlaneGeometry(16000, 16000, 64, 64);
var groundPos = groundGeo.getAttribute('position');
var groundColors = [];
for (var gi = 0; gi < groundPos.count; gi++) {
  var gx = groundPos.getX(gi), gz = groundPos.getY(gi); // plane is XY, we rotate it
  var dist = Math.sqrt(gx * gx + gz * gz) / 8000;
  // Slight variation for texture, darken at edges
  var fade = Math.max(0, 1 - dist * 0.7);
  var base = 0.025 + 0.015 * fade;
  groundColors.push(base * 0.8, base * 0.9, base * 1.2);
}
groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(groundColors, 3));
var groundMat = new THREE.MeshBasicMaterial({ vertexColors: true });
var groundMesh = new THREE.Mesh(groundGeo, groundMat);
groundMesh.rotation.x = -Math.PI / 2;
groundMesh.position.y = -2; // slightly below track
scene.add(groundMesh);

// Offscreen renderer
var offR = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
offR.setSize(w, h); offR.setPixelRatio(1);
offR.outputColorSpace = THREE.LinearSRGBColorSpace;
var offCam = new THREE.PerspectiveCamera(60, w / h, 1, 20000);

// Copy editor scene lighting
// (scene is shared, so lighting already exists)

_flyFrames = [];
_flyBlob = null;
_flyPoses = [];
_flyCamParams = { fov: 60, w: w, h: h };

// --- Pre-pass: capture keyframe images for Runway segment chaining ---
progEl.textContent = 'Capturing keyframes...';
for (var kf = 0; kf <= duration; kf++) {
  var kfFrame = kf === duration ? totalFrames - 1 : kf * fps;
  var kt = isClosed ? kfFrame / totalFrames : Math.min(kfFrame / Math.max(totalFrames - 1, 1), 0.9999);
  var kLookT = kt + 0.02;
  if (isClosed) { kLookT = kLookT % 1; } else { kLookT = Math.min(kLookT, 0.9999); }
  var kPt = flyCurve.getPointAt(kt);
  var kLook = flyCurve.getPointAt(kLookT);
  var kTan = flyCurve.getTangentAt(kt).normalize();
  offCam.position.set(kPt.x - kTan.x * 10, kPt.y + camH, kPt.z - kTan.z * 10);
  offCam.lookAt(kLook.x, kLook.y + camH * 0.3, kLook.z);
  offCam.updateMatrixWorld(true);
  offR.clear(); offR.render(scene, offCam);
  var label = kf === 0 ? 'first' : kf === duration ? 'last' : 't' + kf;
  _flyFrames.push({
    label: label, time: kfFrame / fps, frameIndex: kfFrame,
    dataUrl: offR.domElement.toDataURL('image/jpeg', 0.92)
  });
}

// --- Detect WebCodecs + H.264 encoding support ---
// WebCodecs gives us explicit per-frame timestamps, so the output is always
// exactly `duration` seconds at `fps` fps regardless of how fast/slow the GPU
// renders. MediaRecorder uses wall-clock timestamps which causes fast GPUs to
// produce short videos and slow GPUs to produce long videos.
var canUseWebCodecs = false;
if (typeof VideoEncoder !== 'undefined' && typeof VideoFrame !== 'undefined') {
  try {
    var codecStr = (w > 1280) ? 'avc1.4d0028' : 'avc1.4d001f'; // Main Profile L4.0 / L3.1
    var support = await VideoEncoder.isConfigSupported({
      codec: codecStr, width: w, height: h, bitrate: 8000000, framerate: fps
    });
    canUseWebCodecs = support.supported === true;
  } catch(e) { canUseWebCodecs = false; }
}

var f = 0;

if (canUseWebCodecs) {
  // --- WebCodecs + mp4-muxer path: precise frame timestamps ---
  progEl.textContent = 'Loading MP4 encoder...';
  var Mp4Muxer = await import('https://cdn.jsdelivr.net/npm/mp4-muxer@5.2.2/build/mp4-muxer.mjs');
  var target = new Mp4Muxer.ArrayBufferTarget();
  var muxer = new Mp4Muxer.Muxer({
    target: target,
    video: { codec: 'avc', width: w, height: h },
    fastStart: 'in-memory',
    firstTimestampBehavior: 'offset'
  });

  var encError = null;
  var encoder = new VideoEncoder({
    output: function(chunk, meta) { muxer.addVideoChunk(chunk, meta); },
    error: function(e) { encError = e; }
  });
  encoder.configure({
    codec: codecStr, width: w, height: h,
    bitrate: 8000000, framerate: fps
  });

  var frameDurUs = Math.round(1000000 / fps); // microseconds per frame

  for (f = 0; f < totalFrames; f++) {
    if (encError) throw encError;

    var t = isClosed ? f / totalFrames : Math.min(f / Math.max(totalFrames - 1, 1), 0.9999);
    var lookT = t + 0.02;
    if (isClosed) { lookT = lookT % 1; } else { lookT = Math.min(lookT, 0.9999); }

    var point = flyCurve.getPointAt(t);
    var lookPt = flyCurve.getPointAt(lookT);
    var tangent = flyCurve.getTangentAt(t).normalize();
    offCam.position.set(point.x - tangent.x * 10, point.y + camH, point.z - tangent.z * 10);
    offCam.lookAt(lookPt.x, lookPt.y + camH * 0.3, lookPt.z);
    offCam.updateMatrixWorld(true);
    _flyPoses.push({ t: t, time: f / fps, elements: Array.from(offCam.matrixWorld.elements) });
    offR.clear(); offR.render(scene, offCam);

    var frame = new VideoFrame(offR.domElement, {
      timestamp: f * frameDurUs,
      duration: frameDurUs
    });
    encoder.encode(frame, { keyFrame: f % (fps * 2) === 0 }); // keyframe every 2s
    frame.close();

    // Backpressure: wait if encoder queue is deep (prevents OOM on mobile)
    while (encoder.encodeQueueSize > 8) {
      await new Promise(function(r) { setTimeout(r, 5); });
    }

    var pct = Math.round((f + 1) / totalFrames * 100);
    progEl.textContent = 'Recording ' + pct + '% (' + (f + 1) + '/' + totalFrames + ' frames)';
    // Yield every 4 frames to keep UI responsive without excessive overhead
    if (f % 4 === 3) await new Promise(function(r) { setTimeout(r, 0); });
  }

  await encoder.flush();
  encoder.close();
  muxer.finalize();
  _flyBlob = new Blob([target.buffer], { type: 'video/mp4' });

} else {
  // --- MediaRecorder fallback (browsers without WebCodecs) ---
  var stream = offR.domElement.captureStream(0);
  var vTrack = stream.getVideoTracks()[0];
  var hasRF = typeof vTrack.requestFrame === 'function';
  if (!hasRF) { stream = offR.domElement.captureStream(fps); }
  var mimeType = bestRecorderMime();
  var blobType = mimeType.split(';')[0];
  var recorder = new MediaRecorder(stream, { mimeType: mimeType, videoBitsPerSecond: 8000000 });
  var chunks = [];
  recorder.ondataavailable = function(e) { if (e.data.size) chunks.push(e.data); };

  recorder.start();
  for (f = 0; f < totalFrames; f++) {
    var t = isClosed ? f / totalFrames : Math.min(f / Math.max(totalFrames - 1, 1), 0.9999);
    var lookT = t + 0.02;
    if (isClosed) { lookT = lookT % 1; } else { lookT = Math.min(lookT, 0.9999); }
    var point = flyCurve.getPointAt(t);
    var lookPt = flyCurve.getPointAt(lookT);
    var tangent = flyCurve.getTangentAt(t).normalize();
    offCam.position.set(point.x - tangent.x * 10, point.y + camH, point.z - tangent.z * 10);
    offCam.lookAt(lookPt.x, lookPt.y + camH * 0.3, lookPt.z);
    offCam.updateMatrixWorld(true);
    _flyPoses.push({ t: t, time: f / fps, elements: Array.from(offCam.matrixWorld.elements) });
    offR.clear(); offR.render(scene, offCam);
    if (hasRF) vTrack.requestFrame();
    var pct = Math.round((f + 1) / totalFrames * 100);
    progEl.textContent = 'Recording ' + pct + '% (' + (f + 1) + '/' + totalFrames + ' frames, fallback)';
    await new Promise(function(r) { setTimeout(r, 0); });
  }

  await new Promise(function(resolve) {
    recorder.onstop = function() { _flyBlob = new Blob(chunks, { type: blobType }); resolve(); };
    recorder.stop();
  });
  if (blobType.startsWith('video/webm')) {
    _flyBlob = await fixWebmDuration(_flyBlob, duration * 1000);
  }
}

// Remove temporary environment objects and restore scene
scene.remove(skyDome); skyGeo.dispose(); skyMat.dispose();
scene.remove(starField); starGeo.dispose(); starMat.dispose();
scene.remove(groundMesh); groundGeo.dispose(); groundMat.dispose();
scene.background = _origBg;
scene.fog = _origFog;

// Restore hidden objects
hidden.forEach(function(obj) { obj.visible = true; });

var videoEl = document.getElementById('fly-video');
var blobUrl = URL.createObjectURL(_flyBlob);
videoEl.src = blobUrl;
videoEl.style.display = 'block';
progEl.textContent = 'Recorded ' + duration + 's flythrough (' + f + ' frames, ' + (canUseWebCodecs ? 'MP4' : 'fallback') + ')';

// Populate debug panel after video metadata loads
var debugEl = document.getElementById('fly-debug');
debugEl.style.display = 'block';
var blobSizeKB = (_flyBlob.size / 1024).toFixed(1);
var blobSizeMB = (_flyBlob.size / (1024 * 1024)).toFixed(2);
var debugLines = [
  'Encoder:    ' + (canUseWebCodecs ? 'WebCodecs + mp4-muxer' : 'MediaRecorder (fallback)'),
  'Codec:      ' + (canUseWebCodecs ? codecStr : (typeof blobType !== 'undefined' ? blobType : 'unknown')),
  'Resolution: ' + w + 'x' + h,
  'Frames:     ' + f + ' (' + fps + ' fps x ' + duration + 's)',
  'Blob type:  ' + (_flyBlob.type || 'unknown'),
  'Blob size:  ' + blobSizeKB + ' KB (' + blobSizeMB + ' MB)',
  'Keyframes:  ' + _flyFrames.length,
  'Cam poses:  ' + _flyPoses.length
];
var poseInfoEl = document.getElementById('v2s-pose-info');
if (poseInfoEl) poseInfoEl.textContent = _flyPoses.length + ' camera poses captured (' + w + 'x' + h + ', FOV 60)';
debugEl.textContent = debugLines.join('\n');
videoEl.onloadedmetadata = function() {
  var actualDur = videoEl.duration;
  var durStr = isFinite(actualDur) ? actualDur.toFixed(2) + 's' : 'unknown';
  var actualW = videoEl.videoWidth || '?';
  var actualH = videoEl.videoHeight || '?';
  debugEl.textContent = debugLines.join('\n')
    + '\nVideo dur:  ' + durStr + (isFinite(actualDur) && Math.abs(actualDur - duration) > 0.5 ? '  ⚠ expected ' + duration + 's' : '')
    + '\nVideo res:  ' + actualW + 'x' + actualH;
};
offR.dispose();
btn.disabled = false; btn.textContent = 'Record Flythrough';
toast('Flythrough recorded');
}

function downloadFlythrough() {
if (!_flyBlob) { toast('Record a flythrough first'); return; }
var a = document.createElement('a'); a.href = URL.createObjectURL(_flyBlob);
var ext = (_flyBlob.type && _flyBlob.type.indexOf('mp4') !== -1) ? 'mp4' : 'webm';
a.download = 'flythrough.' + ext; a.click();
}

// ---- Download helpers ----
function downloadVideoUrl(url, filename) {
  var a = document.createElement('a');
  // If it's a blob URL we can download directly; for remote URLs fetch first
  if (url.startsWith('blob:')) {
    a.href = url; a.download = filename; a.click();
  } else {
    proxiedFetch(url).then(function(r) { return r.blob(); }).then(function(b) {
      var blobUrl = URL.createObjectURL(b);
      a.href = blobUrl; a.download = filename; a.click();
      setTimeout(function() { URL.revokeObjectURL(blobUrl); }, 1000);
    });
  }
}

function makeDownloadBtn(url, label, filename) {
  var btn = document.createElement('button');
  btn.className = 'btn';
  btn.textContent = label;
  btn.style.cssText = 'font-size:10px;padding:3px 8px;margin-top:2px';
  btn.onclick = function() { downloadVideoUrl(url, filename); };
  return btn;
}

// ---- Aleph model helpers ----
function onRunwayModelChange() {
  var model = document.getElementById('runway-model').value;
  var durSel = document.getElementById('runway-duration');
  var opt5 = document.getElementById('dur-opt-5');
  var opt10 = document.getElementById('dur-opt-10');
  if (model === 'gen4_aleph') {
    durSel.value = '5';
    durSel.disabled = true;
    opt5.textContent = '5 seconds (required for Aleph)';
    opt10.textContent = '10 seconds';
  } else {
    durSel.disabled = false;
    opt5.textContent = '5 seconds';
    opt10.textContent = '10 seconds (recommended)';
  }
}

function onProviderChange() {
  var provider = document.getElementById('stylize-provider').value;
  var modelSel = document.getElementById('runway-model');
  var btn = document.getElementById('runway-btn');
  var durRow = document.getElementById('stylize-duration-row');
  var decResRow = document.getElementById('decart-resolution-row');
  var descEl = document.getElementById('stylize-desc');
  var rwKeyRow = document.getElementById('apikey-runway-row');
  var dcKeyRow = document.getElementById('apikey-decart-row');

  if (provider === 'decart') {
    modelSel.innerHTML = '<option value="lucy-restyle-v2v" selected>Lucy Restyle V2V (style, up to 30m)</option>'
      + '<option value="lucy-pro-v2v">Lucy Pro V2V (edit, 5s chunks)</option>';
    btn.textContent = 'Stylize with Decart';
    durRow.style.display = 'none';
    decResRow.style.display = 'none';
    rwKeyRow.style.display = 'none';
    dcKeyRow.style.display = '';
    descEl.innerHTML = 'Stylizes the flythrough using <span style="color:var(--accent2)">Decart</span>. <strong>Lucy Pro V2V</strong> &mdash; targeted edit (max 5s/chunk, auto-chunked and concatenated for longer tracks). <strong>Lucy Restyle V2V</strong> &mdash; full style transfer, handles up to 30 min natively.';
  } else {
    modelSel.innerHTML = '<option value="gen4_turbo" selected>Gen-4 Turbo</option>'
      + '<option value="gen4_aleph">Gen-4 Aleph (video-to-video)</option>'
      + '<option value="gen3a_turbo">Gen-3 Alpha Turbo</option>';
    btn.textContent = 'Stylize with Runway';
    durRow.style.display = '';
    decResRow.style.display = 'none';
    rwKeyRow.style.display = '';
    dcKeyRow.style.display = 'none';
    descEl.innerHTML = 'Stylizes the flythrough using <span style="color:var(--accent2)">Runway</span>. Gen-4 Turbo/Gen-3 use image-to-video with keyframes per segment. <strong>Aleph</strong> uses video-to-video &mdash; sends actual flythrough chunks preserving camera motion (max 5s/segment). Longer tracks are auto-chunked and concatenated.';
    onRunwayModelChange();
  }
}

function onModelChange() {
  var provider = document.getElementById('stylize-provider').value;
  if (provider === 'runway') onRunwayModelChange();
}

function runStylize() {
  var provider = document.getElementById('stylize-provider').value;
  if (provider === 'decart') return runDecartStylize();
  return runRunwayStylize();
}

// ---- Decart pending state persistence ----
function saveDecartPending(jobId, apiKey) {
  localStorage.setItem('decart_pending', JSON.stringify({ jobId: jobId, apiKey: apiKey, time: Date.now() }));
}
function clearDecartPending() {
  localStorage.removeItem('decart_pending');
}
function showDecartPending() {
  var raw = localStorage.getItem('decart_pending'); if (!raw) return;
  try { var p = JSON.parse(raw); } catch(e) { return; }
  var age = Math.round((Date.now() - p.time) / 60000);
  if (age > 15) { clearDecartPending(); return; }
  var el = document.getElementById('runway-pending'); if (!el) return;
  document.getElementById('pending-title').textContent = 'Pending Decart generation found';
  document.getElementById('runway-pending-info').textContent = 'Job: ' + p.jobId.substring(0, 16) + '... (' + age + ' min ago)';
  el.style.display = 'block';
}

function checkPendingOperation() {
  var rwRaw = localStorage.getItem('runway_pending');
  var dcRaw = localStorage.getItem('decart_pending');
  if (dcRaw) return checkDecartOperation();
  if (rwRaw) return checkRunwayOperation();
  toast('No pending task');
}
function clearAllPending() {
  clearRunwayPending();
  clearDecartPending();
}

async function checkDecartOperation() {
  var raw = localStorage.getItem('decart_pending'); if (!raw) { toast('No pending Decart task'); return; }
  try { var p = JSON.parse(raw); } catch(e) { toast('Invalid pending data'); clearDecartPending(); return; }
  var progEl = document.getElementById('runway-progress');
  var pendEl = document.getElementById('runway-pending');
  progEl.style.display = 'block';
  progEl.textContent = 'Checking Decart job status...';
  pendEl.style.display = 'none';
  var apiKey = p.apiKey || document.getElementById('decart-apikey').value.trim();
  if (!apiKey) { toast('Enter your Decart API key first'); pendEl.style.display = 'block'; return; }
  try {
    var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + p.jobId, {
      headers: { 'X-API-KEY': apiKey }
    });
    if (!res.ok) throw new Error('Poll failed: ' + res.status);
    var data = await res.json();
    if (data.status === 'completed') {
      clearDecartPending();
      var vidUrl = await downloadDecartJob(p.jobId, apiKey);
      _runwayVideoUrl = vidUrl;
      var videoEl = document.getElementById('runway-video');
      videoEl.src = vidUrl; videoEl.style.display = 'block';
      var dlBar = document.getElementById('runway-download-bar');
      dlBar.style.display = 'flex'; dlBar.innerHTML = '';
      dlBar.appendChild(makeDownloadBtn(vidUrl, 'Download video', 'decart-stylized.mp4'));
      progEl.textContent = 'Decart stylization complete!';
      toast('Decart video ready');
    } else if (data.status === 'failed') {
      clearDecartPending();
      throw new Error('Decart job failed');
    } else {
      progEl.textContent = 'Still generating — resuming poll...';
      var vidUrl = await pollDecartJob(p.jobId, apiKey, progEl, '');
      _runwayVideoUrl = vidUrl;
      var videoEl = document.getElementById('runway-video');
      videoEl.src = vidUrl; videoEl.style.display = 'block';
      var dlBar = document.getElementById('runway-download-bar');
      dlBar.style.display = 'flex'; dlBar.innerHTML = '';
      dlBar.appendChild(makeDownloadBtn(vidUrl, 'Download video', 'decart-stylized.mp4'));
      progEl.textContent = 'Decart stylization complete!';
      toast('Decart video ready');
    }
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('Decart error: ' + err.message);
    console.error('Decart check error:', err);
  }
}

// Submit a video to a Decart V2V model with retry + direct fallback.
// Safari can throw "Load failed" if the proxy times out or blocks the route.
async function decartSubmitJob(model, apiKey, formData, progEl, label) {
  var url = 'https://api.decart.ai/v1/jobs/' + model;
  var attempts = [
    function() { return proxiedFetch(url, { method: 'POST', headers: { 'X-API-KEY': apiKey }, body: formData }); },
    function() { // Retry proxy after a short delay
      return new Promise(function(r) { setTimeout(r, 1500); }).then(function() {
        return proxiedFetch(url, { method: 'POST', headers: { 'X-API-KEY': apiKey }, body: formData });
      });
    },
    function() { // Direct fetch (bypasses proxy, works if Decart allows CORS)
      console.log('Decart: trying direct fetch (bypassing proxy)');
      return fetch(url, { method: 'POST', headers: { 'X-API-KEY': apiKey }, body: formData });
    }
  ];
  for (var i = 0; i < attempts.length; i++) {
    try {
      if (i > 0) progEl.textContent = label + 'Retrying Decart submit (attempt ' + (i + 1) + ')...';
      var res = await attempts[i]();
      if (!res.ok) { var errBody = await res.text(); throw new Error('Decart ' + model + ' (' + res.status + '): ' + errBody); }
      return await res.json();
    } catch (e) {
      console.warn('Decart submit attempt ' + (i + 1) + ' failed:', e.message);
      if (i === attempts.length - 1) throw e; // All attempts exhausted
      // Network errors ("Load failed", "Failed to fetch") → retry; HTTP errors → throw immediately
      if (e.message && !e.message.match(/load failed|failed to fetch|network/i)) throw e;
    }
  }
}

async function pollDecartJob(jobId, apiKey, progEl, prefix) {
  prefix = prefix || '';
  saveDecartPending(jobId, apiKey);
  var startTime = Date.now();
  var maxMs = 10 * 60 * 1000;
  while (Date.now() - startTime < maxMs) {
    await pollSleep(5000);
    var elapsed = Math.round((Date.now() - startTime) / 1000);
    progEl.textContent = prefix + 'Generating styled video... (' + elapsed + 's)';
    try {
      var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + jobId, {
        headers: { 'X-API-KEY': apiKey }
      });
      if (!res.ok) continue;
      var data = await res.json();
      if (data.status === 'completed') {
        clearDecartPending();
        return await downloadDecartJob(jobId, apiKey);
      }
      if (data.status === 'failed') { clearDecartPending(); throw new Error('Decart job failed' + (data.error ? ': ' + data.error : '')); }
      progEl.textContent = prefix + 'Decart: ' + data.status + ' (' + elapsed + 's)';
    } catch (e) {
      if (e.message.includes('Decart job failed')) throw e;
    }
  }
  throw new Error('Decart timed out (10 min)');
}

async function downloadDecartJob(jobId, apiKey) {
  var res = await proxiedFetch('https://api.decart.ai/v1/jobs/' + jobId + '/content', {
    headers: { 'X-API-KEY': apiKey }
  });
  if (!res.ok) throw new Error('Decart download failed: ' + res.status);
  var blob = await res.blob();
  return URL.createObjectURL(blob);
}

async function runDecartStylize() {
  var apiKey = document.getElementById('decart-apikey').value.trim();
  if (!apiKey) { toast('Enter a Decart API key'); return; }
  var prompt = document.getElementById('runway-prompt').value.trim();
  var model = document.getElementById('runway-model').value;

  if (!_flyBlob) { toast('Record a flythrough first'); return; }

  var btn = document.getElementById('runway-btn');
  var progEl = document.getElementById('runway-progress');
  var segEl = document.getElementById('runway-segments');
  var dlBar = document.getElementById('runway-download-bar');
  btn.disabled = true; btn.textContent = 'Stylizing...';
  progEl.style.display = 'block';
  segEl.style.display = 'none'; segEl.innerHTML = '';
  dlBar.style.display = 'none'; dlBar.innerHTML = '';

  var sDbg = document.getElementById('stylize-debug');
  sDbg.style.display = 'block';
  var blobMB = _flyBlob ? (_flyBlob.size / (1024 * 1024)).toFixed(2) : '?';
  sDbg.textContent = 'Model:      ' + model
    + '\nProvider:   Decart'
    + '\nInput blob: ' + blobMB + ' MB (' + (_flyBlob.type || 'unknown') + ')'
    + '\nPrompt:     ' + (prompt || '(empty)')
    + '\nProxy:      ' + (_proxyUrl || 'none');

  try {
    var segmentUrls = [];
    var isRestyle = (model === 'lucy-restyle-v2v');

    if (isRestyle) {
      // ---- Restyle V2V: handles up to 30 min natively, single call ----
      progEl.textContent = 'Submitting to Decart Restyle V2V...';
      var form = new FormData();
      form.append('prompt', prompt);
      form.append('data', _flyBlob, 'flythrough.mp4');
      var jobData = await decartSubmitJob(model, apiKey, form, progEl, '');
      sDbg.textContent += '\nJob ID:     ' + jobData.job_id;
      var vidUrl = await pollDecartJob(jobData.job_id, apiKey, progEl, '');
      segmentUrls = [vidUrl];
    } else {
      // ---- Lucy Pro V2V: 5-second output cap, chunk and concatenate ----
      var DECART_SEG_DUR = 5; // Lucy Pro V2V max output is 5 seconds
      var flyDur = _flyFrames.length ? _flyFrames[_flyFrames.length - 1].time : 0;
      if (!flyDur && _flyBlob) {
        // Estimate from blob: try loading into video element for duration
        var tmpVid = document.createElement('video');
        tmpVid.muted = true; tmpVid.preload = 'auto';
        tmpVid.src = URL.createObjectURL(_flyBlob);
        await new Promise(function(r) { tmpVid.onloadedmetadata = r; tmpVid.onerror = r; });
        if (isFinite(tmpVid.duration)) flyDur = tmpVid.duration;
        URL.revokeObjectURL(tmpVid.src);
      }

      var videoChunks;
      if (flyDur <= DECART_SEG_DUR + 0.5) {
        // Fits in one chunk — send as-is
        videoChunks = [{ blob: _flyBlob, duration: Math.round(flyDur) || DECART_SEG_DUR }];
      } else {
        progEl.textContent = 'Splitting flythrough into ' + DECART_SEG_DUR + 's chunks...';
        videoChunks = await splitVideoIntoChunks(_flyBlob, DECART_SEG_DUR);
      }

      var numChunks = videoChunks.length;
      progEl.textContent = numChunks === 1
        ? 'Submitting to Decart V2V...'
        : 'Stylizing ' + numChunks + ' chunks with Decart V2V...';

      for (var ci = 0; ci < videoChunks.length; ci++) {
        var chunk = videoChunks[ci];
        var segLabel = numChunks > 1 ? 'Chunk ' + (ci + 1) + '/' + numChunks + ': ' : '';

        progEl.textContent = segLabel + 'Submitting to Decart V2V...';
        var form = new FormData();
        form.append('prompt', prompt);
        form.append('data', chunk.blob, 'flythrough.mp4');
        var jobData = await decartSubmitJob(model, apiKey, form, progEl, segLabel);
        var segUrl = await pollDecartJob(jobData.job_id, apiKey, progEl, segLabel);
        segmentUrls.push(segUrl);

        if (numChunks > 1) {
          segEl.style.display = 'block';
          var segVid = document.createElement('video');
          segVid.src = segUrl; segVid.controls = true;
          segVid.style.cssText = 'width:100%;border-radius:4px;margin-bottom:4px;border:1px solid var(--border);background:#000';
          var segTitle = document.createElement('div');
          segTitle.textContent = 'Chunk ' + (ci + 1);
          segTitle.style.cssText = 'font-size:10px;color:var(--text-dim);margin-bottom:2px';
          segEl.appendChild(segTitle); segEl.appendChild(segVid);
          segEl.appendChild(makeDownloadBtn(segUrl, 'Download chunk ' + (ci + 1), 'decart-chunk-' + (ci + 1) + '.mp4'));
        }
      }
    }

    // Store segment URLs for Marble pipeline
    _runwaySegmentUrls = segmentUrls;
    var numSegments = segmentUrls.length;

    if (numSegments === 1) {
      _runwayVideoUrl = segmentUrls[0];
    } else {
      // Concatenate chunks client-side
      progEl.textContent = 'Downloading and concatenating ' + numSegments + ' chunks...';
      _runwayVideoUrl = await concatenateSegments(segmentUrls, progEl);
    }

    var videoEl = document.getElementById('runway-video');
    videoEl.src = _runwayVideoUrl;
    videoEl.style.display = 'block';

    // Show download bar
    dlBar.style.display = 'flex'; dlBar.innerHTML = '';
    dlBar.appendChild(makeDownloadBtn(_runwayVideoUrl, numSegments > 1 ? 'Download full video' : 'Download video', 'decart-stylized.mp4'));
    if (numSegments > 1) {
      for (var di = 0; di < segmentUrls.length; di++) {
        dlBar.appendChild(makeDownloadBtn(segmentUrls[di], 'Chunk ' + (di + 1), 'decart-chunk-' + (di + 1) + '.mp4'));
      }
    }

    progEl.textContent = 'Decart stylization complete!' + (numSegments > 1 ? ' (' + numSegments + ' chunks joined)' : '');
    toast('Decart video ready');
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('Decart error: ' + err.message);
    console.error('Decart error:', err);
    sDbg.textContent += '\n\n--- ERROR ---\n' + err.message + (err.stack ? '\n' + err.stack : '');
  } finally {
    btn.disabled = false; btn.textContent = 'Stylize with Decart';
  }
}

function blobToDataUrl(blob) {
  return new Promise(function(resolve, reject) {
    var reader = new FileReader();
    reader.onload = function() { resolve(reader.result); };
    reader.onerror = function() { reject(new Error('Failed to read blob')); };
    reader.readAsDataURL(blob);
  });
}

// Fix WebM duration metadata. MediaRecorder produces WebM blobs with
// missing or zero duration, which causes Runway's API to reject them.
// Patches the EBML Duration element (ID 0x4489) with the correct value.
async function fixWebmDuration(blob, durationMs) {
  var buffer = await blob.arrayBuffer();
  var bytes = new Uint8Array(buffer);

  // Search for the Duration EBML element: ID = 0x44 0x89
  for (var i = 0; i < bytes.length - 12; i++) {
    if (bytes[i] === 0x44 && bytes[i + 1] === 0x89) {
      var sizeTag = bytes[i + 2];
      if (sizeTag === 0x88) {
        // 8-byte float64 duration (most common)
        var dv = new DataView(buffer, i + 3, 8);
        dv.setFloat64(0, durationMs);
        return new Blob([buffer], { type: blob.type });
      } else if (sizeTag === 0x84) {
        // 4-byte float32 duration
        var dv = new DataView(buffer, i + 3, 4);
        dv.setFloat32(0, durationMs);
        return new Blob([buffer], { type: blob.type });
      }
    }
  }

  // Duration element not found — inject it into Segment Info.
  // Search for the Info element (ID 0x15 0x49 0xA9 0x66) and insert
  // a Duration element right after the Info header.
  for (var i = 0; i < bytes.length - 20; i++) {
    if (bytes[i] === 0x15 && bytes[i + 1] === 0x49 && bytes[i + 2] === 0xA9 && bytes[i + 3] === 0x66) {
      // Info element found. Read its VINT size to find where content starts.
      var sizeStart = i + 4;
      var infoByte = bytes[sizeStart];
      var vintLen = 0;
      for (var bit = 7; bit >= 0; bit--) {
        if (infoByte & (1 << bit)) { vintLen = 8 - bit; break; }
      }
      if (vintLen === 0) break;
      var insertPos = sizeStart + vintLen;

      // Build the Duration element: ID(2) + size(1) + float64(8) = 11 bytes
      var durEl = new Uint8Array(11);
      durEl[0] = 0x44; durEl[1] = 0x89; // Duration element ID
      durEl[2] = 0x88; // VINT size = 8 bytes
      var durView = new DataView(durEl.buffer, 3, 8);
      durView.setFloat64(0, durationMs);

      // We also need to increase the Info element's size by 11.
      // Read current size value
      var sizeMask = infoByte & ~(1 << (8 - vintLen));
      var sizeVal = sizeMask;
      for (var j = 1; j < vintLen; j++) {
        sizeVal = (sizeVal * 256) + bytes[sizeStart + j];
      }
      sizeVal += 11;

      // Write updated size back (same VINT length)
      var newSizeBytes = new Uint8Array(vintLen);
      var tmp = sizeVal;
      for (var j = vintLen - 1; j >= 0; j--) {
        newSizeBytes[j] = tmp & 0xFF;
        tmp = Math.floor(tmp / 256);
      }
      newSizeBytes[0] |= (1 << (8 - vintLen)); // set VINT marker bit

      // Assemble: before insert | duration element | after insert
      var before = bytes.slice(0, insertPos);
      var after = bytes.slice(insertPos);

      // Patch the size bytes in 'before'
      for (var j = 0; j < vintLen; j++) {
        before[sizeStart + j] = newSizeBytes[j];
      }

      var result = new Uint8Array(before.length + durEl.length + after.length);
      result.set(before, 0);
      result.set(durEl, before.length);
      result.set(after, before.length + durEl.length);
      return new Blob([result], { type: blob.type });
    }
  }

  console.warn('fixWebmDuration: could not patch duration metadata');
  return blob;
}

// Prefer MP4 for MediaRecorder (reliable duration metadata).
// Fall back to WebM (needs EBML duration patching for Runway).
function bestRecorderMime() {
  if (typeof MediaRecorder !== 'undefined') {
    if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')) return 'video/mp4;codecs=avc1';
    if (MediaRecorder.isTypeSupported('video/mp4')) return 'video/mp4';
  }
  if (typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) return 'video/webm;codecs=vp9';
  return 'video/webm';
}

// Upload a video blob to Runway via their ephemeral uploads endpoint.
// Returns a runway:// URI that can be used as videoUri.
// This avoids WebM duration metadata issues since Runway's server-side
// tools (ffprobe) can determine duration from the actual video frames.
async function uploadToRunway(blob, headers, progEl, prefix) {
  prefix = prefix || '';
  var ext = (blob.type && blob.type.indexOf('mp4') !== -1) ? 'mp4' : 'webm';

  progEl.textContent = prefix + 'Requesting Runway upload URL...';
  var initRes = await proxiedFetch('https://api.dev.runwayml.com/v1/uploads', {
    method: 'POST', headers: headers,
    body: JSON.stringify({ filename: 'flythrough.' + ext, type: 'ephemeral' })
  });
  if (!initRes.ok) {
    var errText = await initRes.text();
    throw new Error('Runway upload init failed (' + initRes.status + '): ' + errText);
  }
  var initData = await initRes.json();

  progEl.textContent = prefix + 'Uploading video to Runway...';
  var formData = new FormData();
  var fields = initData.fields || {};
  for (var key in fields) {
    if (fields.hasOwnProperty(key)) formData.append(key, fields[key]);
  }
  formData.append('file', blob, 'flythrough.' + ext);

  // Upload goes directly to the presigned URL (not proxied)
  var upRes = await fetch(initData.uploadUrl, { method: 'POST', body: formData });
  if (!upRes.ok && upRes.status !== 204) {
    throw new Error('Runway file upload failed (' + upRes.status + ')');
  }

  return initData.runwayUri;
}

// Split a video blob into chunks of segDur seconds each.
// Returns an array of { blob, duration } objects.
async function splitVideoIntoChunks(videoBlob, segDur) {
  var video = document.createElement('video');
  video.muted = true; video.playsInline = true;
  video.preload = 'auto';
  video.src = URL.createObjectURL(videoBlob);

  // Wait for metadata so we know the full duration
  await new Promise(function(res, rej) {
    video.onloadedmetadata = function() { res(); };
    video.onerror = function() { rej(new Error('Cannot load video for chunking')); };
  });

  var totalDur = video.duration;
  if (!isFinite(totalDur) || totalDur <= 0) {
    // WebM duration can be unknown; fall back to flythrough keyframe time
    totalDur = _flyFrames.length ? _flyFrames[_flyFrames.length - 1].time : segDur;
  }
  var numChunks = Math.max(1, Math.ceil(totalDur / segDur));
  var chunks = [];

  var canvas = document.createElement('canvas');
  canvas.width = 1280; canvas.height = 720;
  var ctx = canvas.getContext('2d');

  for (var i = 0; i < numChunks; i++) {
    var startT = i * segDur;
    var endT = Math.min((i + 1) * segDur, totalDur);
    var chunkDur = endT - startT;

    // Seek to start of this chunk
    await new Promise(function(res) {
      video.currentTime = startT;
      video.onseeked = function() { res(); };
    });

    // Record this chunk via canvas + MediaRecorder
    var cStream = canvas.captureStream(30);
    var mimeType = bestRecorderMime();
    var blobType = mimeType.split(';')[0]; // clean MIME for blob/data URI
    var rec = new MediaRecorder(cStream, { mimeType: mimeType, videoBitsPerSecond: 8000000 });
    var parts = [];
    rec.ondataavailable = function(e) { if (e.data.size) parts.push(e.data); };

    var chunkBlob = await new Promise(function(resolve, reject) {
      rec.start();
      video.play();

      function drawLoop() {
        if (video.paused || video.ended || video.currentTime >= endT) {
          video.pause();
          rec.onstop = function() {
            resolve(new Blob(parts, { type: blobType }));
          };
          rec.stop();
          return;
        }
        ctx.drawImage(video, 0, 0, 1280, 720);
        requestAnimationFrame(drawLoop);
      }

      // Also stop on timeupdate to catch endT precisely
      video.ontimeupdate = function() {
        if (video.currentTime >= endT) {
          video.pause();
        }
      };
      drawLoop();
    });

    // Fix WebM duration metadata (MP4 has reliable duration already)
    var fixedBlob = blobType.startsWith('video/webm')
      ? await fixWebmDuration(chunkBlob, chunkDur * 1000)
      : chunkBlob;
    chunks.push({ blob: fixedBlob, duration: Math.max(2, Math.round(chunkDur)) });
  }

  URL.revokeObjectURL(video.src);
  return chunks;
}

async function runRunwayStylize() {
var apiKey = document.getElementById('runway-apikey').value.trim();
if (!apiKey) { toast('Enter a Runway API key'); return; }
var prompt = document.getElementById('runway-prompt').value.trim();
var model = document.getElementById('runway-model').value;
var isAleph = (model === 'gen4_aleph');
var segDuration = parseInt(document.getElementById('runway-duration').value);
if (isAleph) segDuration = Math.min(segDuration, 5); // Aleph hard cap

// Validation: Aleph needs the video blob, image-to-video needs keyframes
if (isAleph) {
  if (!_flyBlob) { toast('Record a flythrough first'); return; }
} else {
  if (!_flyFrames.length || _flyFrames.length < 2) { toast('Record a flythrough first'); return; }
}

var btn = document.getElementById('runway-btn');
var progEl = document.getElementById('runway-progress');
var segEl = document.getElementById('runway-segments');
var dlBar = document.getElementById('runway-download-bar');
btn.disabled = true; btn.textContent = 'Stylizing...';
progEl.style.display = 'block';
segEl.style.display = 'none'; segEl.innerHTML = '';
dlBar.style.display = 'none'; dlBar.innerHTML = '';

var headers = {
'Content-Type': 'application/json',
'Authorization': 'Bearer ' + apiKey,
'X-Runway-Version': '2024-11-06'
};

try {
var sDbg = document.getElementById('stylize-debug');
sDbg.style.display = 'block';
var blobMB = _flyBlob ? (_flyBlob.size / (1024 * 1024)).toFixed(2) : 'N/A';
sDbg.textContent = 'Model:      ' + model
  + '\nProvider:   Runway'
  + '\nSeg dur:    ' + segDuration + 's'
  + '\nInput blob: ' + blobMB + ' MB (' + (_flyBlob ? _flyBlob.type : 'none') + ')'
  + '\nKeyframes:  ' + _flyFrames.length
  + '\nPrompt:     ' + (prompt || '(empty)')
  + '\nProxy:      ' + (_proxyUrl || 'none');
var segmentUrls = [];
var numSegments;

if (isAleph) {
  // ---- ALEPH: video-to-video path ----
  // Prepend motion-preservation instruction so Aleph follows the source
  // camera path exactly instead of hallucinating new curves/turns
  var alephPrompt = 'Preserve the exact camera motion, direction, and trajectory from the source video. Do not add turns, curves, or direction changes that are not in the original. ' + prompt;

  // Check if flythrough fits in a single chunk — skip re-encoding
  var flyDur = _flyFrames.length ? _flyFrames[_flyFrames.length - 1].time : segDuration;
  var videoChunks;
  if (flyDur <= segDuration + 0.5) {
    // Single chunk: use the already-duration-fixed _flyBlob directly
    videoChunks = [{ blob: _flyBlob, duration: Math.max(2, Math.round(flyDur)) }];
  } else {
    progEl.textContent = 'Splitting flythrough into ' + segDuration + 's chunks...';
    videoChunks = await splitVideoIntoChunks(_flyBlob, segDuration);
  }
  numSegments = videoChunks.length;
  progEl.textContent = numSegments === 1
    ? 'Submitting to Runway Aleph...'
    : 'Stylizing ' + numSegments + ' chunks with Aleph (video-to-video)...';

  for (var ci = 0; ci < videoChunks.length; ci++) {
    var chunk = videoChunks[ci];
    var segLabel = numSegments > 1 ? 'Chunk ' + (ci + 1) + '/' + numSegments + ': ' : '';

    // Upload video to Runway (avoids WebM duration metadata issues with data URIs)
    var runwayUri = await uploadToRunway(chunk.blob, headers, progEl, segLabel);

    progEl.textContent = segLabel + 'Submitting to Runway Aleph...';
    var res = await proxiedFetch('https://api.dev.runwayml.com/v1/video_to_video', {
      method: 'POST', headers: headers,
      body: JSON.stringify({
        model: 'gen4_aleph',
        videoUri: runwayUri,
        promptText: alephPrompt,
        ratio: '1280:720',
        duration: Math.max(2, chunk.duration || segDuration)
      })
    });
    if (!res.ok) { var errBody = await res.text(); throw new Error('Runway Aleph (' + res.status + '): ' + errBody); }
    var taskData = await res.json();
    var taskId = taskData.id;

    var segUrl = await pollRunwayTask(taskId, apiKey, progEl, segLabel);
    segmentUrls.push(segUrl);

    if (numSegments > 1) {
      segEl.style.display = 'block';
      var segVid = document.createElement('video');
      segVid.src = segUrl; segVid.controls = true;
      segVid.style.cssText = 'width:100%;border-radius:4px;margin-bottom:4px;border:1px solid var(--border);background:#000';
      var segTitle = document.createElement('div');
      segTitle.textContent = 'Chunk ' + (ci + 1);
      segTitle.style.cssText = 'font-size:10px;color:var(--text-dim);margin-bottom:2px';
      segEl.appendChild(segTitle); segEl.appendChild(segVid);
      segEl.appendChild(makeDownloadBtn(segUrl, 'Download chunk ' + (ci + 1), 'runway-chunk-' + (ci + 1) + '.mp4'));
    }
  }
} else {
  // ---- IMAGE-TO-VIDEO path (Gen-4 Turbo / Gen-3 Alpha Turbo) ----
  var totalDuration = _flyFrames[_flyFrames.length - 1].time;
  numSegments = Math.max(1, Math.ceil(totalDuration / segDuration));

  // Build segment boundaries using captured keyframes
  var segments = [];
  for (var s = 0; s < numSegments; s++) {
    var startTime = s * segDuration;
    var endTime = Math.min((s + 1) * segDuration, totalDuration);
    var firstKF = _flyFrames.reduce(function(best, f) {
      return Math.abs(f.time - startTime) < Math.abs(best.time - startTime) ? f : best;
    });
    var lastKF = _flyFrames.reduce(function(best, f) {
      return Math.abs(f.time - endTime) < Math.abs(best.time - endTime) ? f : best;
    });
    if (firstKF === lastKF && _flyFrames.length > 1) {
      var idx = _flyFrames.indexOf(firstKF);
      lastKF = _flyFrames[Math.min(idx + 1, _flyFrames.length - 1)];
    }
    segments.push({ index: s, firstKF: firstKF, lastKF: lastKF, duration: segDuration });
  }

  progEl.textContent = numSegments === 1
    ? 'Submitting to Runway (' + model + ')...'
    : 'Stylizing ' + numSegments + ' segments with ' + model + '...';

  for (var si = 0; si < segments.length; si++) {
    var seg = segments[si];
    var segLabel = numSegments > 1 ? 'Segment ' + (si + 1) + '/' + numSegments + ': ' : '';
    var promptImage = seg.firstKF.dataUrl;

    progEl.textContent = segLabel + 'Submitting to Runway...';
    var res = await proxiedFetch('https://api.dev.runwayml.com/v1/image_to_video', {
      method: 'POST', headers: headers,
      body: JSON.stringify({
        model: model,
        promptImage: promptImage,
        promptText: prompt,
        ratio: '1280:720',
        duration: seg.duration
      })
    });
    if (!res.ok) { var errBody = await res.text(); throw new Error('Runway (' + res.status + '): ' + errBody); }
    var taskData = await res.json();
    var taskId = taskData.id;

    var segUrl = await pollRunwayTask(taskId, apiKey, progEl, segLabel);
    segmentUrls.push(segUrl);

    if (numSegments > 1) {
      segEl.style.display = 'block';
      var segVid = document.createElement('video');
      segVid.src = segUrl; segVid.controls = true;
      segVid.style.cssText = 'width:100%;border-radius:4px;margin-bottom:4px;border:1px solid var(--border);background:#000';
      var segTitle = document.createElement('div');
      segTitle.textContent = 'Segment ' + (si + 1);
      segTitle.style.cssText = 'font-size:10px;color:var(--text-dim);margin-bottom:2px';
      segEl.appendChild(segTitle); segEl.appendChild(segVid);
      segEl.appendChild(makeDownloadBtn(segUrl, 'Download segment ' + (si + 1), 'runway-segment-' + (si + 1) + '.mp4'));
    }
  }
}

// Store all segment URLs for Marble pipeline
_runwaySegmentUrls = segmentUrls;

if (numSegments === 1) {
  _runwayVideoUrl = segmentUrls[0];
  var videoEl = document.getElementById('runway-video');
  videoEl.src = _runwayVideoUrl;
  videoEl.style.display = 'block';
} else {
  // Concatenate segments client-side
  progEl.textContent = 'Downloading and concatenating ' + numSegments + ' segments...';
  _runwayVideoUrl = await concatenateSegments(segmentUrls, progEl);
  var videoEl = document.getElementById('runway-video');
  videoEl.src = _runwayVideoUrl;
  videoEl.style.display = 'block';
}

// Show download bar
dlBar.style.display = 'flex';
dlBar.innerHTML = '';
dlBar.appendChild(makeDownloadBtn(_runwayVideoUrl, numSegments > 1 ? 'Download full video' : 'Download video', 'runway-stylized.mp4'));
if (numSegments > 1) {
  for (var di = 0; di < segmentUrls.length; di++) {
    dlBar.appendChild(makeDownloadBtn(segmentUrls[di], (isAleph ? 'Chunk ' : 'Seg ') + (di + 1), 'runway-part-' + (di + 1) + '.mp4'));
  }
}

progEl.textContent = 'Runway stylization complete!' + (numSegments > 1 ? ' (' + numSegments + ' segments joined)' : '');
toast('Runway video ready');
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Runway error: ' + err.message);
console.error('Runway error:', err);
if (sDbg) sDbg.textContent += '\n\n--- ERROR ---\n' + err.message + (err.stack ? '\n' + err.stack : '');
} finally {
btn.disabled = false; btn.textContent = 'Stylize with Runway';
}
}

var _runwaySegmentUrls = [];

async function concatenateSegments(urls, progEl) {
// Fetch all segment videos
var blobs = [];
for (var i = 0; i < urls.length; i++) {
  progEl.textContent = 'Downloading segment ' + (i + 1) + '/' + urls.length + '...';
  var res = await proxiedFetch(urls[i]);
  blobs.push(await res.blob());
}

// Concatenate via hidden video → canvas → MediaRecorder
progEl.textContent = 'Joining segments...';
var canvas = document.createElement('canvas');
canvas.width = 1280; canvas.height = 720;
var ctx = canvas.getContext('2d');
var stream = canvas.captureStream(30);
var mimeType = bestRecorderMime();
var blobType = mimeType.split(';')[0];
var recorder = new MediaRecorder(stream, { mimeType: mimeType, videoBitsPerSecond: 8000000 });
var recChunks = [];
recorder.ondataavailable = function(e) { if (e.data.size) recChunks.push(e.data); };
recorder.start();

var vid = document.createElement('video');
vid.muted = true; vid.playsInline = true;
var totalRecordedSec = 0;

for (var i = 0; i < blobs.length; i++) {
  progEl.textContent = 'Encoding segment ' + (i + 1) + '/' + blobs.length + '...';
  var blobUrl = URL.createObjectURL(blobs[i]);

  // Load video and wait for play() to actually start
  await new Promise(function(res, rej) {
    vid.src = blobUrl;
    vid.onloadeddata = function() {
      vid.play().then(res).catch(function(e) {
        // Autoplay may be blocked; try muted play
        vid.muted = true;
        vid.play().then(res).catch(rej);
      });
    };
    vid.onerror = function() { rej(new Error('Failed to load segment ' + (i + 1))); };
  });

  // Draw frames until this segment ends
  var segDur = vid.duration;
  await new Promise(function(res) {
    var done = false;
    function finish() {
      if (done) return;
      done = true;
      if (isFinite(segDur)) totalRecordedSec += segDur;
      res();
    }
    vid.onended = finish;
    // Safety timeout: if onended doesn't fire, stop after expected duration + buffer
    var safetyMs = (isFinite(segDur) ? segDur : 10) * 1000 + 2000;
    var safetyTimer = setTimeout(finish, safetyMs);
    function drawFrame() {
      if (done) { clearTimeout(safetyTimer); return; }
      if (vid.ended) { clearTimeout(safetyTimer); finish(); return; }
      ctx.drawImage(vid, 0, 0, 1280, 720);
      requestAnimationFrame(drawFrame);
    }
    drawFrame();
  });

  URL.revokeObjectURL(blobUrl);
}

// Stop recorder and build final blob with fixed duration
var finalBlobUrl = await new Promise(function(resolve) {
  recorder.onstop = async function() {
    var rawBlob = new Blob(recChunks, { type: blobType });
    var fixedBlob = blobType.startsWith('video/webm')
      ? await fixWebmDuration(rawBlob, totalRecordedSec * 1000)
      : rawBlob;
    resolve(URL.createObjectURL(fixedBlob));
  };
  recorder.stop();
});
return finalBlobUrl;
}

async function pollRunwayTask(taskId, apiKey, progEl, prefix) {
prefix = prefix || '';
var headers = { 'Authorization': 'Bearer ' + apiKey, 'X-Runway-Version': '2024-11-06' };
saveRunwayPending(taskId, apiKey);
var startTime = Date.now();
var maxMs = 10 * 60 * 1000; // 10 min wall-clock timeout
while (Date.now() - startTime < maxMs) {
await pollSleep(5000);
var elapsed = Math.round((Date.now() - startTime) / 1000);
progEl.textContent = prefix + 'Generating styled video... (' + elapsed + 's)';
try {
var res = await proxiedFetch('https://api.dev.runwayml.com/v1/tasks/' + taskId, { headers: headers });
if (!res.ok) continue;
var data = await res.json();
if (data.status === 'SUCCEEDED') { clearRunwayPending(); return data.output[0]; }
if (data.status === 'FAILED') { clearRunwayPending(); throw new Error('Runway failed: ' + (data.failureCode || 'unknown')); }
if (data.status === 'CANCELED') { clearRunwayPending(); throw new Error('Runway task canceled'); }
progEl.textContent = prefix + 'Runway: ' + data.status + ' (' + elapsed + 's)';
} catch (e) {
if (e.message.includes('Runway failed') || e.message.includes('canceled')) throw e;
}
}
throw new Error('Runway timed out (10 min)');
}

// Handle local video upload for Stage 3 Marble
var _marbleVidEl = document.getElementById('marble-vid-upload');
if (_marbleVidEl) _marbleVidEl.addEventListener('change', function(e) {
  var file = e.target.files && e.target.files[0];
  if (!file) return;
  if (_runwayVideoUrl && _runwayVideoUrl.startsWith('blob:')) {
    URL.revokeObjectURL(_runwayVideoUrl);
  }
  _runwayVideoUrl = URL.createObjectURL(file);
  _runwaySegmentUrls = [_runwayVideoUrl];
  var nameEl = document.getElementById('marble-vid-name');
  var sizeMB = (file.size / (1024 * 1024)).toFixed(1);
  nameEl.textContent = file.name + ' (' + sizeMB + ' MB)';
  nameEl.title = file.name;
  toast('Video loaded for Marble');
});

async function runMarbleFromVideo() {
var marbleKey = document.getElementById('marble-apikey').value.trim();
if (!marbleKey) { toast('Enter a Marble API key (panel 1)'); return; }
if (!_runwayVideoUrl) { toast('Upload a video or run Stage 2 stylization first'); return; }
var quality = document.getElementById('marble-quality').value;
var prompt = document.getElementById('marble-prompt').value.trim();
var btn = document.getElementById('marble-vid-btn');
var progEl = document.getElementById('marble-vid-progress');
btn.disabled = true; btn.textContent = 'Generating...';
progEl.style.display = 'block';

var headers = { 'Content-Type': 'application/json', 'WLT-Api-Key': marbleKey };

try {
// Fetch the video (blob URL for local/uploaded, remote URL for Stage 2 output)
var isLocal = _runwayVideoUrl.startsWith('blob:');
progEl.textContent = isLocal ? 'Reading uploaded video...' : 'Downloading styled video...';
var vidRes = isLocal ? await fetch(_runwayVideoUrl) : await proxiedFetch(_runwayVideoUrl);
if (!vidRes.ok) throw new Error('Video fetch failed: ' + vidRes.status);
var videoBlob = await vidRes.blob();

progEl.textContent = 'Uploading video to Marble...';
var upRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/media-assets:prepare_upload', {
method: 'POST', headers: headers,
body: JSON.stringify({ file_name: 'styled-flythrough.mp4', kind: 'video', extension: 'mp4' })
});
if (!upRes.ok) throw new Error('Marble upload setup failed: ' + upRes.status);
var upData = await upRes.json();
var mediaId = upData.media_asset.media_asset_id;
var upUrl = upData.upload_info.upload_url;
var upMethod = upData.upload_info.upload_method || 'PUT';
var upHeaders = upData.upload_info.required_headers || {};
await proxiedFetch(upUrl, { method: upMethod, headers: upHeaders, body: videoBlob });

progEl.textContent = 'Generating 3D world from video (1-5 min)...';
var genRes = await proxiedFetch('https://api.worldlabs.ai/marble/v1/worlds:generate', {
method: 'POST', headers: headers,
body: JSON.stringify({
display_name: 'Styled Track Environment',
model: 'Marble 0.1-plus',
world_prompt: {
type: 'video',
video_prompt: { source: 'media_asset', media_asset_id: mediaId },
text_prompt: prompt || ''
}
})
});
if (!genRes.ok) {
if (genRes.status === 401) throw new Error('Invalid Marble API key');
var errText = await genRes.text();
throw new Error('Marble generation failed (' + genRes.status + '): ' + errText);
}

var genData = await genRes.json();
var opId = genData.operation_id || genData.name;
var worldData = null;
if (genData.done && genData.response) { worldData = genData.response; }
else if (opId) {
saveMarblePending(opId, marbleKey, quality);
worldData = await pollMarbleOp(opId, marbleKey, quality, progEl);
} else { worldData = genData.world || genData; }

handleMarbleResult(worldData, quality);
progEl.textContent = 'Pipeline complete — 3D world loaded!';
toast('3D world reconstructed!');
} catch (err) {
progEl.textContent = 'Error: ' + err.message;
toast('Error: ' + err.message);
console.error('Marble video error:', err);
} finally {
btn.disabled = false; btn.textContent = 'Reconstruct 3D World';
}
}

async function runFullPipeline() {
var btn = document.getElementById('pipeline-full-btn');
var progEl = document.getElementById('pipeline-progress');
btn.disabled = true; progEl.style.display = 'block';
try {
progEl.textContent = 'Stage 1/3: Recording flythrough...';
await recordFlythrough();
var provider = document.getElementById('stylize-provider').value;
progEl.textContent = 'Stage 2/3: ' + (provider === 'decart' ? 'Decart' : 'Runway') + ' stylization...';
await runStylize();
progEl.textContent = 'Stage 3/3: Marble 3D reconstruction...';
await runMarbleFromVideo();
progEl.textContent = 'Full pipeline complete!';
toast('Pipeline complete!');
} catch (err) {
progEl.textContent = 'Pipeline error: ' + err.message;
toast('Pipeline error: ' + err.message);
} finally { btn.disabled = false; }
}

async function loadSplatFromURL() {
var url = document.getElementById('splat-url').value.trim();
if (!url) { toast('Enter a splat URL'); return; }
var infoEl = document.getElementById('splat-info');
infoEl.textContent = 'Loading Spark.js...';
try {
await ensureSparkLoaded();
if (_splatMesh) { scene.remove(_splatMesh); if (_splatMesh.dispose) _splatMesh.dispose(); _splatMesh = null; }
infoEl.textContent = 'Loading splat from URL...';
var Spark = window.Spark;
_splatMesh = new Spark.SplatMesh({
url: url,
onLoad: function(mesh) {
var numSplats = mesh.numSplats || 'unknown';
infoEl.textContent = 'Loaded: ' + numSplats + ' splats';
toast('Splat loaded (' + numSplats + ' splats)');
syncSplatSlidersToMesh();
}
});
scene.add(_splatMesh);
} catch (err) {
infoEl.textContent = 'Error: ' + err.message;
toast('Failed to load splat: ' + err.message);
console.error(err);
}
}

function loadSplatFromFile() {
var fileInput = document.getElementById('splat-file-input');
fileInput.onchange = async function() {
if (!this.files[0]) return;
var file = this.files[0];
var infoEl = document.getElementById('splat-info');
infoEl.textContent = 'Loading Spark.js...';
try {
await ensureSparkLoaded();
if (_splatMesh) { scene.remove(_splatMesh); if (_splatMesh.dispose) _splatMesh.dispose(); _splatMesh = null; }
infoEl.textContent = 'Loading ' + file.name + '...';
var bytes = new Uint8Array(await file.arrayBuffer());
var Spark = window.Spark;
_splatMesh = new Spark.SplatMesh({
fileBytes: bytes,
onLoad: function(mesh) {
var numSplats = mesh.numSplats || 'unknown';
infoEl.textContent = 'Loaded: ' + file.name + ' (' + numSplats + ' splats, ' + (file.size/1e6).toFixed(1) + ' MB)';
toast('Splat loaded: ' + file.name);
syncSplatSlidersToMesh();
}
});
scene.add(_splatMesh);
} catch (err) {
infoEl.textContent = 'Error: ' + err.message;
toast('Failed: ' + err.message);
}
};
fileInput.click();
}

function removeSplat() {
if (_splatMesh) {
scene.remove(_splatMesh);
if (_splatMesh.dispose) _splatMesh.dispose();
_splatMesh = null;
document.getElementById('splat-info').textContent = 'Splat removed';
document.getElementById('splat-url').value = '';
toast('Splat removed');
}
}

function syncSplatSlidersToMesh() {
if (!_splatMesh) return;
if (trackData.length > 10) {
var cx = 0, cy = 0, cz = 0;
trackData.forEach(function(pt) { cx += pt[0][0]; cy += pt[0][1]; cz += pt[0][2]; });
cx /= trackData.length; cy /= trackData.length; cz /= trackData.length;
_splatMesh.position.set(cx, cy, cz);
}
var p = _splatMesh.position;
document.getElementById('s-splatpx').value = Math.round(p.x);
document.getElementById('v-splatpx').textContent = Math.round(p.x);
document.getElementById('s-splatpy').value = Math.round(p.y);
document.getElementById('v-splatpy').textContent = Math.round(p.y);
document.getElementById('s-splatpz').value = Math.round(p.z);
document.getElementById('v-splatpz').textContent = Math.round(p.z);
document.getElementById('s-splatrx').value = 0;
document.getElementById('v-splatrx').textContent = '0';
document.getElementById('s-splatry').value = 0;
document.getElementById('v-splatry').textContent = '0';
document.getElementById('s-splatscale').value = 1;
document.getElementById('v-splatscale').textContent = '1.0';
document.getElementById('s-splatopacity').value = 1;
document.getElementById('v-splatopacity').textContent = '1.0';
}

function applySplatSettings() {
if (!_splatMesh) return;
var opacity = parseFloat(document.getElementById('s-splatopacity').value);
var scale = parseFloat(document.getElementById('s-splatscale').value);
var px = parseFloat(document.getElementById('s-splatpx').value);
var py = parseFloat(document.getElementById('s-splatpy').value);
var pz = parseFloat(document.getElementById('s-splatpz').value);
var rx = parseFloat(document.getElementById('s-splatrx').value) * Math.PI / 180;
var ry = parseFloat(document.getElementById('s-splatry').value) * Math.PI / 180;
_splatMesh.opacity = opacity;
_splatMesh.scale.setScalar(scale);
_splatMesh.position.set(px, py, pz);
_splatMesh.rotation.set(rx, ry, 0);
}

function splatBackdropPreset() {
if (!_splatMesh) { toast('Load a splat first'); return; }
var minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
if (trackData.length > 10) {
trackData.forEach(function(p) {
minX=Math.min(minX,p[0][0]);maxX=Math.max(maxX,p[0][0]);
minY=Math.min(minY,p[0][1]);maxY=Math.max(maxY,p[0][1]);
minZ=Math.min(minZ,p[0][2]);maxZ=Math.max(maxZ,p[0][2]);
});
}
var cx = (minX+maxX)/2, cy = (minY+maxY)/2, cz = (minZ+maxZ)/2;
var sc = 30;
document.getElementById('s-splatscale').value = sc;
document.getElementById('v-splatscale').textContent = sc.toFixed(1);
document.getElementById('s-splatpx').value = Math.round(cx);
document.getElementById('v-splatpx').textContent = Math.round(cx);
document.getElementById('s-splatpy').value = Math.round(cy);
document.getElementById('v-splatpy').textContent = Math.round(cy);
document.getElementById('s-splatpz').value = Math.round(cz);
document.getElementById('v-splatpz').textContent = Math.round(cz);
document.getElementById('s-splatrx').value = 0;
document.getElementById('v-splatrx').textContent = '0';
document.getElementById('s-splatry').value = 0;
document.getElementById('v-splatry').textContent = '0';
applySplatSettings();
toast('Backdrop preset applied (scale 30x, centered on track)');
}

function splatResetTransform() {
if (!_splatMesh) { toast('Load a splat first'); return; }
document.getElementById('s-splatscale').value = 1;
document.getElementById('v-splatscale').textContent = '1.0';
document.getElementById('s-splatpx').value = 0;
document.getElementById('v-splatpx').textContent = '0';
document.getElementById('s-splatpy').value = 0;
document.getElementById('v-splatpy').textContent = '0';
document.getElementById('s-splatpz').value = 0;
document.getElementById('v-splatpz').textContent = '0';
document.getElementById('s-splatrx').value = 0;
document.getElementById('v-splatrx').textContent = '0';
document.getElementById('s-splatry').value = 0;
document.getElementById('v-splatry').textContent = '0';
document.getElementById('s-splatopacity').value = 1;
document.getElementById('v-splatopacity').textContent = '1.0';
applySplatSettings();
toast('Transform reset');
}

// ============================================================
// UI BINDING
// ============================================================
function bindUI(){
var sliders={'smooth-iter':'smooth-iter-val','smooth-str':'smooth-str-val','cp-count':'cp-count-val','spline-resolution':'spline-res-val','loop-blend':'loop-blend-val','loop-pts':'loop-pts-val','elev-offset':'elev-val','s-imgscale':'v-imgscale','s-imgpts':'v-imgpts','s-imgsmooth':'v-imgsmooth','s-splatopacity':'v-splatopacity','s-splatscale':'v-splatscale'};
Object.keys(sliders).forEach(function(a){var b=sliders[a];var sl=document.getElementById(a),vl=document.getElementById(b);if(sl&&vl)sl.addEventListener('input',function(){vl.textContent=sl.value})});
document.querySelectorAll('input[type="range"]').forEach(function(sl){
var vid='v-'+sl.id.substring(2);var vlbl=document.getElementById(vid);
if(vlbl)sl.addEventListener('input',function(){vlbl.textContent=sl.value});
});
['s-splatopacity','s-splatscale','s-splatpx','s-splatpy','s-splatpz','s-splatrx','s-splatry'].forEach(function(id){
var el = document.getElementById(id);
if (el) el.addEventListener('input', applySplatSettings);
});
// Panorama capture sliders
['s-pano-sections','s-pano-height'].forEach(function(id){
var sl=document.getElementById(id);if(!sl)return;
var vlbl=document.getElementById('v-'+id.slice(2));
if(vlbl)sl.addEventListener('input',function(){vlbl.textContent=sl.value});
});
['s-pano-start','s-pano-end'].forEach(function(id){
var sl=document.getElementById(id);if(!sl)return;
var vlbl=document.getElementById('v-'+id.slice(2));
if(vlbl)sl.addEventListener('input',function(){vlbl.textContent=sl.value+'%'});
});
// Training view sliders
['s-trainviews','s-trainres'].forEach(function(id){
var sl=document.getElementById(id);if(!sl)return;
var vlbl=document.getElementById('v-'+id.slice(2));
if(vlbl)sl.addEventListener('input',function(){vlbl.textContent=sl.value});
});
// Proxy URL persistence: ?proxy=<url> to set, ?proxy=clear to remove
var _proxyParam = new URLSearchParams(window.location.search).get('proxy');
if (_proxyParam === '' || _proxyParam === 'clear') { localStorage.removeItem('proxy_url'); }
else if (_proxyParam) { var _pu = _proxyParam.replace(/\/+$/, ''); localStorage.setItem('proxy_url', _pu); _proxyUrl = _pu; }
else { var _stored = localStorage.getItem('proxy_url'); if (_stored) _proxyUrl = _stored; }
// API key persistence: load from localStorage, URL params override
var _apiKeyIds = ['runway-apikey', 'decart-apikey', 'marble-apikey', 'kiri-apikey', 'runpod-apikey'];
if (_proxyUrl) {
  _apiKeyIds.forEach(function(id) {
    var el = document.getElementById(id); if (!el) return;
    el.value = 'proxy-managed';
    el.disabled = true;
    el.style.opacity = '0.5';
    el.title = 'API key managed by proxy: ' + _proxyUrl;
  });
} else {
  _apiKeyIds.forEach(function(id) {
    var el = document.getElementById(id); if (!el) return;
    var saved = localStorage.getItem('apikey_' + id);
    if (saved && !el.value) el.value = saved;
    el.addEventListener('input', function() {
      var v = el.value.trim();
      if (v) localStorage.setItem('apikey_' + id, v);
      else localStorage.removeItem('apikey_' + id);
    });
  });
  // URL params override localStorage (Runway, Decart, Marble)
  var rkParam=new URLSearchParams(window.location.search).get('rk');
  if(rkParam){var rkEl=document.getElementById('runway-apikey');if(rkEl)rkEl.value=rkParam}
  var dkParam=new URLSearchParams(window.location.search).get('dk');
  if(dkParam){var dkEl=document.getElementById('decart-apikey');if(dkEl)dkEl.value=dkParam}
  var mkParam=new URLSearchParams(window.location.search).get('mk');
  if(mkParam){var mkEl=document.getElementById('marble-apikey');if(mkEl)mkEl.value=mkParam}
  var kkParam=new URLSearchParams(window.location.search).get('kk');
  if(kkParam){var kkEl=document.getElementById('kiri-apikey');if(kkEl)kkEl.value=kkParam}
}
}

// ============================================================
// KIRI ENGINE — 3DGS FROM VIDEO / PHOTOS
// ============================================================
var _kiriSerialize = null;

// Toggle video/images row based on mode selection
var _kiriModeEl = document.getElementById('kiri-mode');
if (_kiriModeEl) _kiriModeEl.addEventListener('change', function() {
  var mode = this.value;
  document.getElementById('kiri-video-row').style.display = mode === 'video' ? '' : 'none';
  document.getElementById('kiri-images-row').style.display = mode === 'images' ? '' : 'none';
});

// File input display names
var _kiriVideoEl = document.getElementById('kiri-video-input');
if (_kiriVideoEl) _kiriVideoEl.addEventListener('change', function() {
  var nameEl = document.getElementById('kiri-video-name');
  if (this.files[0]) nameEl.textContent = this.files[0].name;
  else nameEl.textContent = '';
});
var _kiriImagesEl = document.getElementById('kiri-images-input');
if (_kiriImagesEl) _kiriImagesEl.addEventListener('change', function() {
  var nameEl = document.getElementById('kiri-images-name');
  if (this.files.length) nameEl.textContent = this.files.length + ' photos selected';
  else nameEl.textContent = '';
});

// Video-to-Splat training: file input + slider handlers
document.getElementById('v2s-video-input').addEventListener('change', function() {
  var nameEl = document.getElementById('v2s-video-name');
  if (this.files[0]) nameEl.textContent = this.files[0].name;
  else nameEl.textContent = '';
});
var _flystepEl = document.getElementById('s-flystep');
if (_flystepEl) _flystepEl.addEventListener('input', function() {
  document.getElementById('v-flystep').textContent = this.value;
});
document.getElementById('s-runpod-iters').addEventListener('input', function() {
  document.getElementById('v-runpod-iters').textContent = this.value;
});

function saveKiriPending(serialize, apiKey) {
  localStorage.setItem('kiri_pending', JSON.stringify({ serialize: serialize, apiKey: apiKey, time: Date.now() }));
}
function clearKiriPending() {
  localStorage.removeItem('kiri_pending');
  _kiriSerialize = null;
  var el = document.getElementById('kiri-pending'); if (el) el.style.display = 'none';
}
function showKiriPending() {
  var raw = localStorage.getItem('kiri_pending'); if (!raw) return;
  try { var p = JSON.parse(raw); } catch(e) { return; }
  var age = Math.round((Date.now() - p.time) / 60000);
  if (age > 60) { clearKiriPending(); return; } // expire after 1 hour
  _kiriSerialize = p.serialize;
  var el = document.getElementById('kiri-pending'); if (!el) return;
  document.getElementById('kiri-pending-info').textContent = 'Serial: ' + p.serialize.substring(0, 20) + '... (' + age + ' min ago)';
  el.style.display = '';
}

async function generateKiri() {
  var apiKey = document.getElementById('kiri-apikey').value.trim();
  if (!apiKey && !_proxyUrl) { toast('Enter a KIRI API key'); return; }
  var mode = document.getElementById('kiri-mode').value;
  var isMesh = document.getElementById('kiri-mesh').checked ? '1' : '0';
  var isMask = document.getElementById('kiri-mask').checked ? '1' : '0';
  var progEl = document.getElementById('kiri-progress');
  var btn = document.getElementById('kiri-gen-btn');

  var formData = new FormData();
  formData.append('isMesh', isMesh);
  formData.append('isMask', isMask);

  var endpoint;
  if (mode === 'video') {
    var videoInput = document.getElementById('kiri-video-input');
    if (!videoInput.files[0]) { toast('Select a video file first'); return; }
    formData.append('videoFile', videoInput.files[0]);
    endpoint = 'https://api.kiriengine.app/api/v1/open/3dgs/video';
  } else {
    var imagesInput = document.getElementById('kiri-images-input');
    if (!imagesInput.files.length) { toast('Select photos first'); return; }
    if (imagesInput.files.length < 20) { toast('KIRI requires at least 20 photos'); return; }
    if (imagesInput.files.length > 300) { toast('KIRI supports max 300 photos'); return; }
    for (var i = 0; i < imagesInput.files.length; i++) {
      formData.append('imagesFiles', imagesInput.files[i]);
    }
    endpoint = 'https://api.kiriengine.app/api/v1/open/3dgs/image';
  }

  progEl.style.display = 'block';
  progEl.textContent = 'Uploading to KIRI Engine...';
  btn.disabled = true;
  btn.textContent = 'Uploading...';

  try {
    var uploadHeaders = {};
    if (apiKey) uploadHeaders['Authorization'] = 'Bearer ' + apiKey;
    var uploadRes = await proxiedFetch(endpoint, {
      method: 'POST',
      headers: uploadHeaders,
      body: formData
    });
    if (!uploadRes.ok) {
      if (uploadRes.status === 401) throw new Error('Invalid KIRI API key');
      if (uploadRes.status === 402) throw new Error('Insufficient KIRI credits');
      var errText = await uploadRes.text();
      throw new Error('Upload failed (' + uploadRes.status + '): ' + errText);
    }
    var uploadData = await uploadRes.json();
    var serialize = uploadData.data && uploadData.data.serialize || uploadData.serialize;
    if (!serialize) throw new Error('No serial number returned — check API response');

    _kiriSerialize = serialize;
    saveKiriPending(serialize, apiKey);
    progEl.textContent = 'Processing 3DGS... (serial: ' + serialize.substring(0, 16) + '...)';
    btn.textContent = 'Processing...';

    // Poll for completion
    var result = await pollKiriStatus(serialize, apiKey, progEl);
    handleKiriResult(result, apiKey);
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('KIRI error: ' + err.message);
    console.error('KIRI generation error:', err);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Generate 3DGS';
  }
}

async function pollKiriStatus(serialize, apiKey, progEl) {
  var maxAttempts = 120; // 20 min max (10s intervals)
  for (var i = 0; i < maxAttempts; i++) {
    await pollSleep(10000);
    try {
      var pollHeaders = {};
      if (apiKey) pollHeaders['Authorization'] = 'Bearer ' + apiKey;
      var statusRes = await proxiedFetch('https://api.kiriengine.app/api/v1/open/model/getStatus?serialize=' + encodeURIComponent(serialize), {
        headers: pollHeaders
      });
      if (!statusRes.ok) throw new Error('Status check failed: ' + statusRes.status);
      var statusData = await statusRes.json();
      var status = statusData.data && statusData.data.status !== undefined ? statusData.data.status : statusData.status;

      if (status === 2 || status === 4) {
        // Success or Exported
        clearKiriPending();
        return statusData;
      } else if (status === 1) {
        throw new Error('KIRI processing failed');
      } else {
        var statusLabels = { '-1': 'Uploading', '0': 'Processing', '3': 'Queuing' };
        var label = statusLabels[String(status)] || 'Status ' + status;
        progEl.textContent = label + '... (' + Math.round((i + 1) * 10 / 60) + ' min)';
      }
    } catch (err) {
      if (err.message === 'KIRI processing failed') throw err;
      console.warn('KIRI poll error (retrying):', err);
    }
  }
  throw new Error('KIRI processing timed out after 20 minutes');
}

async function handleKiriResult(statusData, apiKey) {
  var progEl = document.getElementById('kiri-progress');
  var resultsEl = document.getElementById('kiri-results');
  var urlInput = document.getElementById('kiri-result-url');
  var dlBar = document.getElementById('kiri-dl-bar');

  progEl.textContent = 'Downloading model ZIP...';

  try {
    var serialize = _kiriSerialize || (statusData.data && statusData.data.serialize);
    var dlHeaders = {};
    if (apiKey) dlHeaders['Authorization'] = 'Bearer ' + apiKey;
    var dlRes = await proxiedFetch('https://api.kiriengine.app/api/v1/open/model/getModelZip?serialize=' + encodeURIComponent(serialize), {
      headers: dlHeaders
    });
    if (!dlRes.ok) throw new Error('Download failed: ' + dlRes.status);
    var dlData = await dlRes.json();
    var zipUrl = dlData.data && dlData.data.url || dlData.url;
    if (!zipUrl) throw new Error('No download URL in response');

    urlInput.value = zipUrl;
    dlBar.innerHTML = '';
    resultsEl.style.display = '';

    // Download the ZIP and extract PLY
    progEl.textContent = 'Fetching ZIP and extracting PLY...';
    var zipResp = await proxiedFetch(zipUrl);
    if (!zipResp.ok) throw new Error('Failed to fetch ZIP: ' + zipResp.status);
    var zipBlob = await zipResp.blob();
    var zip = await JSZip.loadAsync(zipBlob);

    // Find PLY file in ZIP
    var plyFile = null;
    zip.forEach(function(path, entry) {
      if (!entry.dir && path.toLowerCase().endsWith('.ply') && !plyFile) {
        plyFile = entry;
      }
    });

    if (plyFile) {
      var plyBytes = await plyFile.async('uint8array');
      progEl.textContent = 'Loading PLY into splat viewer...';

      // Load into Spark.js viewer
      await ensureSparkLoaded();
      if (_splatMesh) { scene.remove(_splatMesh); if (_splatMesh.dispose) _splatMesh.dispose(); _splatMesh = null; }
      var Spark = window.Spark;
      _splatMesh = new Spark.SplatMesh({
        fileBytes: plyBytes,
        onLoad: function(mesh) {
          var numSplats = mesh.numSplats || 'unknown';
          progEl.textContent = 'KIRI 3DGS loaded! ' + numSplats + ' splats';
          toast('KIRI splat loaded (' + numSplats + ' splats)');
          document.getElementById('splat-info').textContent = 'KIRI: ' + numSplats + ' splats (' + (plyBytes.length / 1e6).toFixed(1) + ' MB)';
          syncSplatSlidersToMesh();
        }
      });
      scene.add(_splatMesh);

      // Add download button
      var dlBtn = document.createElement('button');
      dlBtn.className = 'btn';
      dlBtn.textContent = 'Download PLY';
      dlBtn.onclick = function() {
        var blob = new Blob([plyBytes], { type: 'application/octet-stream' });
        var a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'kiri-3dgs.ply';
        a.click();
        URL.revokeObjectURL(a.href);
      };
      dlBar.appendChild(dlBtn);

      // Add download ZIP button
      var zipBtn = document.createElement('button');
      zipBtn.className = 'btn';
      zipBtn.textContent = 'Download Full ZIP';
      zipBtn.onclick = function() {
        var a = document.createElement('a');
        a.href = URL.createObjectURL(zipBlob);
        a.download = 'kiri-3dgs.zip';
        a.click();
        URL.revokeObjectURL(a.href);
      };
      dlBar.appendChild(zipBtn);
    } else {
      progEl.textContent = 'ZIP downloaded but no PLY found — check ZIP contents';
      toast('No PLY in KIRI ZIP');
      // Still offer the ZIP download
      var zipBtn2 = document.createElement('button');
      zipBtn2.className = 'btn';
      zipBtn2.textContent = 'Download ZIP';
      zipBtn2.onclick = function() {
        var a = document.createElement('a');
        a.href = URL.createObjectURL(zipBlob);
        a.download = 'kiri-3dgs.zip';
        a.click();
        URL.revokeObjectURL(a.href);
      };
      dlBar.appendChild(zipBtn2);
    }
  } catch (err) {
    progEl.textContent = 'Download error: ' + err.message;
    toast('KIRI download error: ' + err.message);
    console.error('KIRI download error:', err);
  }
}

async function checkKiriStatus() {
  var raw = localStorage.getItem('kiri_pending');
  if (!raw && !_kiriSerialize) { toast('No pending KIRI job'); return; }
  var p = raw ? JSON.parse(raw) : { serialize: _kiriSerialize };
  var apiKey = p.apiKey || document.getElementById('kiri-apikey').value.trim();
  if (!apiKey && !_proxyUrl) { toast('Enter a KIRI API key'); return; }
  var serialize = p.serialize || _kiriSerialize;
  if (!serialize) { toast('No serial number found'); return; }

  var progEl = document.getElementById('kiri-progress');
  var pendEl = document.getElementById('kiri-pending');
  progEl.style.display = 'block';
  progEl.textContent = 'Checking KIRI status...';

  try {
    var chkHeaders = {};
    if (apiKey) chkHeaders['Authorization'] = 'Bearer ' + apiKey;
    var statusRes = await proxiedFetch('https://api.kiriengine.app/api/v1/open/model/getStatus?serialize=' + encodeURIComponent(serialize), {
      headers: chkHeaders
    });
    if (!statusRes.ok) throw new Error('Status check failed: ' + statusRes.status);
    var statusData = await statusRes.json();
    var status = statusData.data && statusData.data.status !== undefined ? statusData.data.status : statusData.status;

    var statusLabels = { '-1': 'Uploading', '0': 'Processing', '1': 'Failed', '2': 'Successful', '3': 'Queuing', '4': 'Exported' };
    var label = statusLabels[String(status)] || 'Unknown (' + status + ')';

    if (status === 2 || status === 4) {
      progEl.textContent = 'KIRI job complete! Downloading...';
      if (pendEl) pendEl.style.display = 'none';
      _kiriSerialize = serialize;
      handleKiriResult(statusData, apiKey);
    } else if (status === 1) {
      progEl.textContent = 'KIRI job failed';
      clearKiriPending();
      toast('KIRI processing failed');
    } else {
      progEl.textContent = 'KIRI status: ' + label;
      toast('KIRI: ' + label);
    }
  } catch (err) {
    progEl.textContent = 'Error: ' + err.message;
    toast('KIRI check error: ' + err.message);
    console.error('KIRI check error:', err);
  }
}

// ============================================================
// EXPORT TRAINING VIEWS for 3DGS
// ============================================================
async function exportTrainingViews(){
var numViews=parseInt(document.getElementById('s-trainviews').value);
var res=parseInt(document.getElementById('s-trainres').value);
var btn=document.getElementById('btn-export-views');
var prog=document.getElementById('export-views-progress');
btn.disabled=true;btn.textContent='Rendering...';prog.style.display='block';

// Compute scene bounding box from track + terrain
var bbox=new THREE.Box3();
if(trackRibbon)bbox.expandByObject(trackRibbon);
if(terrainMesh)bbox.expandByObject(terrainMesh);
if(tLine)bbox.expandByObject(tLine);
if(_splatMesh)bbox.expandByObject(_splatMesh);
if(bbox.isEmpty()){
trackData.forEach(function(p){bbox.expandByPoint(new THREE.Vector3(p[0][0],p[0][1],p[0][2]))});
}
var center=new THREE.Vector3();bbox.getCenter(center);
var size=new THREE.Vector3();bbox.getSize(size);
var radius=Math.max(size.x,size.y,size.z)*0.7;
if(radius<100)radius=500;

// Offscreen renderer
var offRndr=new THREE.WebGLRenderer({antialias:true,preserveDrawingBuffer:true});
offRndr.setSize(res,res);offRndr.setPixelRatio(1);
offRndr.outputColorSpace=THREE.LinearSRGBColorSpace;

var fov=50;
var offCam=new THREE.PerspectiveCamera(fov,1,1,radius*10);

// Generate camera poses — orbits at 3 elevations + top-down
var frames=[];
var elevations=[0.3,0.55,0.8]; // fraction of PI (low, mid, high)
var viewsPerRing=Math.floor(numViews/elevations.length);
var extraTop=numViews-viewsPerRing*elevations.length;

for(var e=0;e<elevations.length;e++){
var phi=Math.PI*elevations[e];
var n=viewsPerRing+(e<extraTop?1:0);
for(var i=0;i<n;i++){
var theta=(2*Math.PI*i)/n;
var x=center.x+radius*Math.sin(phi)*Math.cos(theta);
var y=center.y+radius*Math.cos(phi);
var z=center.z+radius*Math.sin(phi)*Math.sin(theta);
frames.push({pos:[x,y,z],target:[center.x,center.y,center.z]});
}
}

// Render each frame and collect PNGs
var zip=new JSZip();
var imgFolder=zip.folder('images');
var transforms={
camera_model:'OPENCV',
fl_x:res/(2*Math.tan(fov*Math.PI/360)),
fl_y:res/(2*Math.tan(fov*Math.PI/360)),
cx:res/2,cy:res/2,
w:res,h:res,
frames:[]
};

for(var i=0;i<frames.length;i++){
prog.textContent='Rendering view '+(i+1)+' / '+frames.length;
offCam.position.set(frames[i].pos[0],frames[i].pos[1],frames[i].pos[2]);
offCam.lookAt(frames[i].target[0],frames[i].target[1],frames[i].target[2]);
offCam.updateMatrixWorld(true);

offRndr.clear();offRndr.render(scene,offCam);

// Build nerfstudio-format transform matrix (c2w, OpenGL convention)
// Three.js matrixWorld is already camera-to-world
var m=offCam.matrixWorld.clone();
// Convert from Three.js (Y-up, -Z forward) to OpenGL (Y-up, -Z forward) — same convention, just emit the 4x4
var me=m.elements; // column-major
var c2w=[
[me[0],me[4],me[8],me[12]],
[me[1],me[5],me[9],me[13]],
[me[2],me[6],me[10],me[14]],
[me[3],me[7],me[11],me[15]]
];

var fname='images/frame_'+String(i).padStart(5,'0')+'.png';
transforms.frames.push({file_path:fname,transform_matrix:c2w});

// Canvas to PNG blob
var dataUrl=offRndr.domElement.toDataURL('image/png');
var b64=dataUrl.split(',')[1];
imgFolder.file('frame_'+String(i).padStart(5,'0')+'.png',b64,{base64:true});

// Yield to keep UI responsive
if(i%4===0)await new Promise(function(r){setTimeout(r,0)});
}

offRndr.dispose();

prog.textContent='Compressing ZIP...';
zip.file('transforms.json',JSON.stringify(transforms,null,2));

var blob=await zip.generateAsync({type:'blob'},function(meta){
prog.textContent='Compressing... '+Math.round(meta.percent)+'%';
});

var url=URL.createObjectURL(blob);
var a=document.createElement('a');a.href=url;a.download='training_views.zip';a.click();
URL.revokeObjectURL(url);

btn.disabled=false;btn.textContent='Export Views ZIP';
prog.textContent='Done — '+frames.length+' views at '+res+'px';
toast('Training views exported');
}

// ============================================================
// VIDEO → SPLAT TRAINING EXPORT
// ============================================================
function _buildTransformsJson(poses, w, h, fov) {
  var fl = w / (2 * Math.tan(fov * Math.PI / 360));
  var transforms = {
    camera_model: 'OPENCV',
    fl_x: fl,
    fl_y: fl,
    cx: w / 2,
    cy: h / 2,
    w: w,
    h: h,
    frames: []
  };
  for (var i = 0; i < poses.length; i++) {
    var me = poses[i].elements;
    var c2w = [
      [me[0], me[4], me[8], me[12]],
      [me[1], me[5], me[9], me[13]],
      [me[2], me[6], me[10], me[14]],
      [me[3], me[7], me[11], me[15]]
    ];
    transforms.frames.push({
      file_path: 'images/frame_' + String(i).padStart(5, '0') + '.png',
      transform_matrix: c2w
    });
  }
  return transforms;
}

async function exportFlythroughTraining() {
  if (!_flyPoses.length || !_flyCamParams) {
    try { _generatePosesFromTrack(); } catch(e) { toast(e.message); return; }
  }
  var stepEl = document.getElementById('s-flystep');
  var step = stepEl ? parseInt(stepEl.value) || 1 : 1;
  var btn = document.getElementById('btn-export-fly-train');
  var prog = document.getElementById('v2s-progress');
  btn.disabled = true; btn.textContent = 'Rendering...';
  prog.style.display = 'block';

  var cp = _flyCamParams;
  var selectedPoses = [];
  for (var i = 0; i < _flyPoses.length; i += step) {
    selectedPoses.push(_flyPoses[i]);
  }

  // Rebuild spline for re-rendering
  var pts = [];
  var spStep = Math.max(1, Math.floor(trackData.length / 500));
  for (var i = 0; i < trackData.length; i += spStep) {
    pts.push(new THREE.Vector3(trackData[i][0][0], trackData[i][0][1], trackData[i][0][2]));
  }
  var last = trackData[trackData.length - 1][0];
  if (pts.length < 2 || pts[pts.length - 1].distanceTo(new THREE.Vector3(last[0], last[1], last[2])) > 1) {
    pts.push(new THREE.Vector3(last[0], last[1], last[2]));
  }

  // Offscreen renderer
  var offRndr = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
  offRndr.setSize(cp.w, cp.h); offRndr.setPixelRatio(1);
  offRndr.outputColorSpace = THREE.LinearSRGBColorSpace;
  var offCam = new THREE.PerspectiveCamera(cp.fov, cp.w / cp.h, 1, 20000);

  var zip = new JSZip();
  var imgFolder = zip.folder('images');

  // Re-render at each stored pose
  var newPoses = [];
  for (var i = 0; i < selectedPoses.length; i++) {
    prog.textContent = 'Rendering frame ' + (i + 1) + ' / ' + selectedPoses.length;
    var me = selectedPoses[i].elements;
    offCam.matrixWorld.fromArray(me);
    offCam.matrixWorld.decompose(offCam.position, offCam.quaternion, offCam.scale);
    offCam.updateMatrixWorld(true);

    offRndr.clear(); offRndr.render(scene, offCam);

    newPoses.push({ elements: me });
    var dataUrl = offRndr.domElement.toDataURL('image/png');
    var b64 = dataUrl.split(',')[1];
    imgFolder.file('frame_' + String(i).padStart(5, '0') + '.png', b64, { base64: true });

    if (i % 4 === 0) await new Promise(function(r) { setTimeout(r, 0); });
  }

  offRndr.dispose();

  var transforms = _buildTransformsJson(newPoses, cp.w, cp.h, cp.fov);
  prog.textContent = 'Compressing ZIP...';
  zip.file('transforms.json', JSON.stringify(transforms, null, 2));

  var blob = await zip.generateAsync({ type: 'blob' }, function(meta) {
    prog.textContent = 'Compressing... ' + Math.round(meta.percent) + '%';
  });

  var url = URL.createObjectURL(blob);
  var a = document.createElement('a'); a.href = url; a.download = 'flythrough_training.zip'; a.click();
  URL.revokeObjectURL(url);

  btn.disabled = false; btn.textContent = 'Export Training ZIP';
  prog.textContent = 'Done — ' + newPoses.length + ' frames at ' + cp.w + 'x' + cp.h + ' with camera poses';
  toast('Flythrough training views exported');
}

async function extractStylizedTraining() {
  if (!_flyPoses.length || !_flyCamParams) {
    try { _generatePosesFromTrack(); } catch(e) { toast(e.message); return; }
  }
  var fileInput = document.getElementById('v2s-video-input');
  if (!fileInput.files[0]) { toast('Choose a stylized video first'); return; }
  var videoFile = fileInput.files[0];
  var sampling = document.getElementById('v2s-sampling').value;
  var btn = document.getElementById('btn-extract-stylized');
  var prog = document.getElementById('v2s-progress');
  btn.disabled = true; btn.textContent = 'Extracting...';
  prog.style.display = 'block';
  prog.textContent = 'Loading video...';

  var cp = _flyCamParams;

  // Create video element for frame extraction
  var video = document.createElement('video');
  video.muted = true;
  video.playsInline = true;
  var blobUrl = URL.createObjectURL(videoFile);
  video.src = blobUrl;

  await new Promise(function(resolve, reject) {
    video.onloadedmetadata = resolve;
    video.onerror = function() { reject(new Error('Failed to load video')); };
  });

  var vidDuration = video.duration;
  if (!isFinite(vidDuration) || vidDuration <= 0) {
    btn.disabled = false; btn.textContent = 'Extract & Export ZIP';
    prog.textContent = 'Error: could not read video duration';
    URL.revokeObjectURL(blobUrl);
    toast('Cannot read video duration'); return;
  }

  // Determine which poses/timestamps to extract
  var extractPoses = [];
  if (sampling === 'match') {
    // Match all flythrough poses — distribute them evenly across video duration
    for (var i = 0; i < _flyPoses.length; i++) {
      var frac = i / Math.max(_flyPoses.length - 1, 1);
      extractPoses.push({ poseIdx: i, time: frac * vidDuration, elements: _flyPoses[i].elements });
    }
  } else {
    // Fixed FPS sampling
    var targetFps = parseInt(sampling); // '2fps' -> 2, '5fps' -> 5, '10fps' -> 10
    var interval = 1 / targetFps;
    var totalPoses = _flyPoses.length;
    for (var t = 0; t < vidDuration; t += interval) {
      var frac = t / vidDuration;
      var poseIdx = Math.min(Math.round(frac * (totalPoses - 1)), totalPoses - 1);
      extractPoses.push({ poseIdx: poseIdx, time: t, elements: _flyPoses[poseIdx].elements });
    }
  }

  prog.textContent = 'Extracting ' + extractPoses.length + ' frames...';

  // Canvas for frame capture
  var canvas = document.createElement('canvas');
  canvas.width = cp.w;
  canvas.height = cp.h;
  var ctx = canvas.getContext('2d');

  var zip = new JSZip();
  var imgFolder = zip.folder('images');
  var finalPoses = [];

  for (var i = 0; i < extractPoses.length; i++) {
    var ep = extractPoses[i];
    prog.textContent = 'Extracting frame ' + (i + 1) + ' / ' + extractPoses.length;

    // Seek to timestamp
    video.currentTime = Math.min(ep.time, vidDuration - 0.01);
    await new Promise(function(resolve) {
      video.onseeked = resolve;
    });

    // Draw frame to canvas at the target resolution
    ctx.drawImage(video, 0, 0, cp.w, cp.h);
    var dataUrl = canvas.toDataURL('image/png');
    var b64 = dataUrl.split(',')[1];
    imgFolder.file('frame_' + String(i).padStart(5, '0') + '.png', b64, { base64: true });
    finalPoses.push({ elements: ep.elements });

    if (i % 4 === 0) await new Promise(function(r) { setTimeout(r, 0); });
  }

  URL.revokeObjectURL(blobUrl);

  var transforms = _buildTransformsJson(finalPoses, cp.w, cp.h, cp.fov);
  prog.textContent = 'Compressing ZIP...';
  zip.file('transforms.json', JSON.stringify(transforms, null, 2));

  var blob = await zip.generateAsync({ type: 'blob' }, function(meta) {
    prog.textContent = 'Compressing... ' + Math.round(meta.percent) + '%';
  });

  var url = URL.createObjectURL(blob);
  var a = document.createElement('a'); a.href = url; a.download = 'stylized_training.zip'; a.click();
  URL.revokeObjectURL(url);

  btn.disabled = false; btn.textContent = 'Extract & Export ZIP';
  prog.textContent = 'Done — ' + finalPoses.length + ' stylized frames at ' + cp.w + 'x' + cp.h + ' with camera poses';
  toast('Stylized training ZIP exported');
}

// ============================================================
// RUNPOD 3DGS TRAINING PIPELINE
// ============================================================
var _runpodState = { podId: null, token: null, phase: null };

function _runpodLog(msg) {
  var el = document.getElementById('runpod-status');
  if (el) { el.style.display = ''; el.textContent = msg; }
}

function _slsLogApi(label, data) {
  var el = document.getElementById('sls-api-log');
  if (!el) return;
  var ts = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  var body;
  if (typeof data === 'string') {
    body = data;
  } else {
    // Truncate large base64 fields for readability
    body = JSON.stringify(data, function(k, v) {
      if (typeof v === 'string' && v.length > 200 && /^[A-Za-z0-9+/=\s]+$/.test(v.slice(0, 100))) {
        return v.slice(0, 80) + '...[' + (v.length / 1024).toFixed(0) + ' KB]';
      }
      return v;
    }, 2);
  }
  el.textContent += '[' + ts + '] ' + label + '\n' + body + '\n\n';
  el.scrollTop = el.scrollHeight;
}

async function _runpodApi(method, path, body) {
  var opts = {
    method: method,
    headers: { 'Content-Type': 'application/json' }
  };
  if (body) opts.body = JSON.stringify(body);
  return proxiedFetch('https://rest.runpod.io/v1' + path, opts);
}

async function _jupyterApi(podId, token, method, path, body) {
  var sep = path.indexOf('?') >= 0 ? '&' : '?';
  var url = 'https://' + podId + '-8888.proxy.runpod.net' + path + sep + 'token=' + token;
  var opts = { method: method };
  if (body !== undefined) {
    opts.headers = { 'Content-Type': 'application/json' };
    opts.body = typeof body === 'string' ? body : JSON.stringify(body);
  }
  return proxiedFetch(url, opts);
}

async function _jupyterPut(podId, token, filePath, content) {
  var isText = typeof content === 'string';
  var body = { type: 'file', format: isText ? 'text' : 'base64', content: content };
  return _jupyterApi(podId, token, 'PUT', '/api/contents/' + filePath, body);
}

async function _jupyterMkdir(podId, token, dirPath) {
  return _jupyterApi(podId, token, 'PUT', '/api/contents/' + dirPath, { type: 'directory' });
}

async function _jupyterFileExists(podId, token, filePath) {
  try {
    var res = await _jupyterApi(podId, token, 'GET', '/api/contents/' + filePath + '?content=0');
    return res.ok;
  } catch(e) { return false; }
}

async function _jupyterGetText(podId, token, filePath) {
  var res = await _jupyterApi(podId, token, 'GET', '/api/contents/' + filePath);
  if (!res.ok) return null;
  var data = await res.json();
  return data.content || null;
}

async function _jupyterDownloadBinary(podId, token, filePath) {
  var sep = filePath.indexOf('?') >= 0 ? '&' : '?';
  var url = 'https://' + podId + '-8888.proxy.runpod.net/files/' + filePath + sep + 'token=' + token;
  var res = await proxiedFetch(url);
  if (!res.ok) throw new Error('Download failed: ' + res.status);
  return new Uint8Array(await res.arrayBuffer());
}

function _arrayBufferToBase64(buffer) {
  var bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
  var binary = '';
  for (var i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

// Auto-generate camera poses from the track spline (same math as recordFlythrough)
// This populates _flyPoses and _flyCamParams without rendering or recording a video.
function _generatePosesFromTrack() {
  if (trackData.length < 20) throw new Error('Load a track first');

  var duration = parseInt(document.getElementById('s-flydur').value) || 10;
  var resVal = document.getElementById('fly-res') ? document.getElementById('fly-res').value : '720';
  var camH = parseFloat(document.getElementById('s-flyht').value) || 20;
  var w = resVal === '1080' ? 1920 : 1280;
  var h = resVal === '1080' ? 1080 : 720;
  var fps = 30;
  var totalFrames = duration * fps;

  // Build CatmullRomCurve3 from track data (same as recordFlythrough)
  var pts = [];
  var step = Math.max(1, Math.floor(trackData.length / 500));
  for (var i = 0; i < trackData.length; i += step) {
    pts.push(new THREE.Vector3(trackData[i][0][0], trackData[i][0][1], trackData[i][0][2]));
  }
  var last = trackData[trackData.length - 1][0];
  if (pts.length < 2 || pts[pts.length - 1].distanceTo(new THREE.Vector3(last[0], last[1], last[2])) > 1) {
    pts.push(new THREE.Vector3(last[0], last[1], last[2]));
  }
  var first = trackData[0][0];
  var trackGap = Math.hypot(first[0] - last[0], first[1] - last[1], first[2] - last[2]);
  var isClosed = trackGap < 50;
  var flyCurve = new THREE.CatmullRomCurve3(pts, isClosed, 'catmullrom', 0.5);

  // Temporary camera just for matrix computation
  var tempCam = new THREE.PerspectiveCamera(60, w / h, 1, 20000);

  _flyPoses = [];
  _flyCamParams = { fov: 60, w: w, h: h };

  for (var f = 0; f < totalFrames; f++) {
    var t = isClosed ? f / totalFrames : Math.min(f / Math.max(totalFrames - 1, 1), 0.9999);
    var lookT = t + 0.02;
    if (isClosed) { lookT = lookT % 1; } else { lookT = Math.min(lookT, 0.9999); }

    var point = flyCurve.getPointAt(t);
    var lookPt = flyCurve.getPointAt(lookT);
    var tangent = flyCurve.getTangentAt(t).normalize();
    tempCam.position.set(point.x - tangent.x * 10, point.y + camH, point.z - tangent.z * 10);
    tempCam.lookAt(lookPt.x, lookPt.y + camH * 0.3, lookPt.z);
    tempCam.updateMatrixWorld(true);
    _flyPoses.push({ t: t, time: f / fps, elements: Array.from(tempCam.matrixWorld.elements) });
  }
}

// Build training data from video + poses (shared logic)
async function _buildTrainingFrames(prog) {
  if (!_flyPoses.length || !_flyCamParams) throw new Error('No camera poses available');

  var videoFile = null;
  var fileInput = document.getElementById('v2s-video-input');
  if (fileInput && fileInput.files[0]) {
    videoFile = fileInput.files[0];
  } else if (_runwayVideoUrl) {
    // Use stylized video from Stage 2
    prog('Fetching stylized video from Stage 2...');
    var resp = await fetch(_runwayVideoUrl);
    videoFile = await resp.blob();
  }
  if (!videoFile) throw new Error('Choose a stylized video or run Stage 2 first');

  var sampling = document.getElementById('v2s-sampling').value;
  var cp = _flyCamParams;

  // Create video element
  var video = document.createElement('video');
  video.muted = true; video.playsInline = true;
  var blobUrl = URL.createObjectURL(videoFile);
  video.src = blobUrl;
  await new Promise(function(resolve, reject) {
    video.onloadedmetadata = resolve;
    video.onerror = function() { reject(new Error('Failed to load video')); };
  });
  var vidDuration = video.duration;
  if (!isFinite(vidDuration) || vidDuration <= 0) {
    URL.revokeObjectURL(blobUrl);
    throw new Error('Cannot read video duration');
  }

  // Determine poses to extract
  var extractList = [];
  if (sampling === 'match') {
    for (var i = 0; i < _flyPoses.length; i++) {
      var frac = i / Math.max(_flyPoses.length - 1, 1);
      extractList.push({ poseIdx: i, time: frac * vidDuration, elements: _flyPoses[i].elements });
    }
  } else {
    var targetFps = parseInt(sampling);
    var interval = 1 / targetFps;
    for (var t = 0; t < vidDuration; t += interval) {
      var frac = t / vidDuration;
      var poseIdx = Math.min(Math.round(frac * (_flyPoses.length - 1)), _flyPoses.length - 1);
      extractList.push({ poseIdx: poseIdx, time: t, elements: _flyPoses[poseIdx].elements });
    }
  }

  // Extract frames
  var canvas = document.createElement('canvas');
  canvas.width = cp.w; canvas.height = cp.h;
  var ctx = canvas.getContext('2d');
  var frames = [];

  for (var i = 0; i < extractList.length; i++) {
    if (i % 10 === 0) prog('Extracting frame ' + (i + 1) + ' / ' + extractList.length);
    video.currentTime = Math.min(extractList[i].time, vidDuration - 0.01);
    await new Promise(function(r) { video.onseeked = r; });
    ctx.drawImage(video, 0, 0, cp.w, cp.h);
    // Use JPEG for smaller upload size
    var dataUrl = canvas.toDataURL('image/jpeg', 0.92);
    var b64 = dataUrl.split(',')[1];
    frames.push({ name: 'frame_' + String(i).padStart(5, '0') + '.jpg', b64: b64, elements: extractList[i].elements });
    if (i % 4 === 0) await new Promise(function(r) { setTimeout(r, 0); });
  }

  URL.revokeObjectURL(blobUrl);

  var transforms = _buildTransformsJson(frames.map(function(f) { return { elements: f.elements }; }), cp.w, cp.h, cp.fov);
  // Fix file paths to use .jpg
  for (var i = 0; i < transforms.frames.length; i++) {
    transforms.frames[i].file_path = 'images/' + frames[i].name;
  }

  return { frames: frames, transforms: transforms };
}

function useStylizedVideo() {
  var nameEl = document.getElementById('v2s-video-name');
  var fileInput = document.getElementById('v2s-video-input');
  if (_runwayVideoUrl) {
    // Stage 2 output exists — use it directly
    nameEl.textContent = 'Stage 2 output';
    if (fileInput) fileInput.value = '';
    toast('Will use Stage 2 stylized video');
    return;
  }
  // No Stage 2 output — prompt upload, fall back to Stage 1 only if user cancels
  var upload = document.createElement('input');
  upload.type = 'file';
  upload.accept = 'video/mp4,video/webm,.mp4,.webm';
  upload.onchange = function() {
    var file = upload.files && upload.files[0];
    if (!file) return;
    if (_runwayVideoUrl && _runwayVideoUrl.startsWith('blob:')) {
      URL.revokeObjectURL(_runwayVideoUrl);
    }
    _runwayVideoUrl = URL.createObjectURL(file);
    var sizeMB = (file.size / (1024 * 1024)).toFixed(1);
    nameEl.textContent = file.name + ' (' + sizeMB + ' MB)';
    if (fileInput) fileInput.value = '';
    toast('Stylized video loaded — ready for training');
  };
  // If user cancels the picker without choosing a file, fall back to Stage 1
  upload.addEventListener('cancel', function() {
    if (_flyBlob && _flyPoses.length && _flyCamParams) {
      _runwayVideoUrl = URL.createObjectURL(_flyBlob);
      var sizeMB = (_flyBlob.size / (1024 * 1024)).toFixed(1);
      nameEl.textContent = 'Stage 1 flythrough (' + sizeMB + ' MB, ' + _flyPoses.length + ' poses)';
      if (fileInput) fileInput.value = '';
      toast('Using Stage 1 flythrough video + camera poses');
    }
  });
  upload.click();
}

async function runpodTrain() {
  var hasVideo = (document.getElementById('v2s-video-input').files[0]) || _runwayVideoUrl;
  if (!hasVideo) { toast('Choose a stylized video or run Stage 2 first'); return; }

  var gpuType = document.getElementById('runpod-gpu').value;
  var iterations = parseInt(document.getElementById('s-runpod-iters').value);
  var btn = document.getElementById('btn-runpod-train');
  var prog = document.getElementById('v2s-progress');
  btn.disabled = true; btn.textContent = 'Starting...';
  prog.style.display = 'block';

  function updateProg(msg) { prog.textContent = msg; _runpodLog(msg); }

  try {
    // --- Phase 1: Ensure camera poses exist ---
    if (!_flyPoses.length || !_flyCamParams) {
      updateProg('Generating camera poses from track...');
      _generatePosesFromTrack();
      updateProg('Generated ' + _flyPoses.length + ' camera poses from track.');
    }

    // --- Phase 2: Extract frames from uploaded video ---
    updateProg('Extracting frames from video...');
    var data = await _buildTrainingFrames(function(m) { updateProg(m); });
    updateProg('Extracted ' + data.frames.length + ' frames. Creating RunPod pod...');

    // --- Phase 2: Create RunPod pod ---
    var token = 'ad' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    _runpodState = { podId: null, token: token, phase: 'creating' };

    var createRes = await _runpodApi('POST', '/pods', {
      name: 'accel-driv-3dgs-' + Date.now().toString(36).slice(-4),
      imageName: 'runpod/pytorch:2.4.1-py3.11-cuda12.4.1-devel-ubuntu22.04',
      gpuTypeIds: [gpuType],
      gpuCount: 1,
      cloudType: 'COMMUNITY',
      containerDiskInGb: 50,
      volumeInGb: 20,
      volumeMountPath: '/workspace',
      ports: ['8888/http'],
      env: {
        JUPYTER_PASSWORD: token,
        JUPYTER_TOKEN: token
      }
    });
    if (!createRes.ok) {
      var errText = await createRes.text();
      throw new Error('Failed to create pod (' + createRes.status + '): ' + errText);
    }
    var podData = await createRes.json();
    var podId = podData.id;
    if (!podId) throw new Error('No pod ID returned');
    _runpodState.podId = podId;
    _runpodState.phase = 'starting';
    updateProg('Pod created: ' + podId + '. Waiting for GPU...');

    // --- Phase 3: Wait for pod RUNNING ---
    for (var attempt = 0; attempt < 120; attempt++) {
      await pollSleep(5000);
      var statusRes = await _runpodApi('GET', '/pods/' + podId);
      if (statusRes.ok) {
        var statusData = await statusRes.json();
        var ds = statusData.desiredStatus || statusData.status || '';
        var runtime = statusData.runtime;
        if (runtime && runtime.uptimeInSeconds > 0) break;
        updateProg('Pod ' + podId + ': ' + ds + ' (waiting for GPU, ' + (attempt * 5) + 's)');
      }
      if (attempt >= 119) throw new Error('Pod failed to start after 10 minutes');
    }
    _runpodState.phase = 'jupyter-wait';
    updateProg('Pod running. Waiting for JupyterLab...');

    // --- Phase 4: Wait for JupyterLab ---
    var jupyterReady = false;
    for (var jAttempt = 0; jAttempt < 60; jAttempt++) {
      await pollSleep(5000);
      try {
        var jRes = await _jupyterApi(podId, token, 'GET', '/api');
        if (jRes.ok) { jupyterReady = true; break; }
      } catch(e) { /* retry */ }
      updateProg('Waiting for JupyterLab... (' + (jAttempt * 5) + 's)');
    }
    if (!jupyterReady) throw new Error('JupyterLab failed to start after 5 minutes');
    _runpodState.phase = 'uploading';
    updateProg('JupyterLab ready. Uploading training data...');

    // --- Phase 5: Upload training data ---
    await _jupyterMkdir(podId, token, 'data');
    await _jupyterMkdir(podId, token, 'data/images');

    // Upload transforms.json
    await _jupyterPut(podId, token, 'data/transforms.json', JSON.stringify(data.transforms, null, 2));

    // Upload frames in parallel batches of 8
    var batchSize = 8;
    for (var bi = 0; bi < data.frames.length; bi += batchSize) {
      var batch = data.frames.slice(bi, bi + batchSize);
      await Promise.all(batch.map(function(f) {
        return _jupyterPut(podId, token, 'data/images/' + f.name, f.b64);
      }));
      var pct = Math.round(Math.min(bi + batchSize, data.frames.length) / data.frames.length * 100);
      updateProg('Uploading frames... ' + pct + '% (' + Math.min(bi + batchSize, data.frames.length) + '/' + data.frames.length + ')');
    }

    // --- Phase 6: Upload and start training script ---
    var trainScript = [
      '#!/bin/bash',
      'set -e',
      'cd /workspace',
      'echo "install" > /workspace/STATUS',
      'pip install nerfstudio gsplat 2>&1 | tee install.log',
      'echo "train" > /workspace/STATUS',
      'ns-train splatfacto \\',
      '  --data /workspace/data \\',
      '  --max-num-iterations ' + iterations + ' \\',
      '  --output-dir /workspace/ns-output \\',
      '  --viewer.quit-on-train-completion True \\',
      '  --pipeline.datamanager.dataparser nerfstudio-data \\',
      '  2>&1 | tee train.log',
      'echo "export" > /workspace/STATUS',
      'CONFIG=$(find /workspace/ns-output -name "config.yml" -path "*/splatfacto/*" | head -1)',
      'if [ -z "$CONFIG" ]; then echo "error: no config" > /workspace/STATUS; exit 1; fi',
      'ns-export gaussian-splat \\',
      '  --load-config "$CONFIG" \\',
      '  --output-dir /workspace/export \\',
      '  2>&1 | tee export.log',
      'echo "done" > /workspace/STATUS',
      'touch /workspace/DONE'
    ].join('\n');
    await _jupyterPut(podId, token, 'train.sh', trainScript);
    updateProg('Starting nerfstudio training (' + iterations + ' iterations)...');

    // Start training via kernel
    _runpodState.phase = 'training';
    var kernelRes = await _jupyterApi(podId, token, 'POST', '/api/kernels', { name: 'python3' });
    if (!kernelRes.ok) throw new Error('Failed to create kernel: ' + kernelRes.status);
    var kernelData = await kernelRes.json();
    var kernelId = kernelData.id;

    // Execute training via kernel WebSocket
    var wsUrl = 'wss://' + podId + '-8888.proxy.runpod.net/api/kernels/' + kernelId + '/channels?token=' + token;
    await new Promise(function(resolve, reject) {
      var ws = new WebSocket(wsUrl);
      var sent = false;
      ws.onopen = function() {
        var msgId = 'exec-' + Date.now();
        ws.send(JSON.stringify({
          header: { msg_id: msgId, msg_type: 'execute_request', username: '', session: msgId, version: '5.3' },
          parent_header: {},
          metadata: {},
          content: { code: 'import subprocess; subprocess.Popen(["bash", "/workspace/train.sh"]); print("STARTED")', silent: false, store_history: false, user_expressions: {}, allow_stdin: false },
          channel: 'shell'
        }));
        sent = true;
      };
      ws.onmessage = function(e) {
        try {
          var msg = JSON.parse(e.data);
          if (msg.msg_type === 'stream' && msg.content && msg.content.text && msg.content.text.indexOf('STARTED') >= 0) {
            ws.close(); resolve();
          }
          if (msg.msg_type === 'execute_reply') {
            ws.close(); resolve();
          }
        } catch(ex) {}
      };
      ws.onerror = function(e) { if (!sent) reject(new Error('WebSocket failed — check RunPod pod status')); };
      // Timeout: if WS doesn't respond in 30s, assume training started anyway
      setTimeout(function() { try { ws.close(); } catch(ex) {} resolve(); }, 30000);
    });

    updateProg('Training started on GPU. This takes 15-45 min. Polling...');

    // --- Phase 7: Poll for completion ---
    var maxPolls = 360; // 60 min max (10s intervals)
    for (var pi = 0; pi < maxPolls; pi++) {
      await pollSleep(10000);
      var done = await _jupyterFileExists(podId, token, 'DONE');
      if (done) break;
      var statusText = await _jupyterGetText(podId, token, 'STATUS');
      var phase = statusText ? statusText.trim() : 'waiting';
      var elapsed = Math.round((pi + 1) * 10 / 60);
      updateProg('Training: ' + phase + ' (' + elapsed + ' min elapsed)');
      if (phase.indexOf('error') >= 0) throw new Error('Training failed: ' + phase);
      if (pi >= maxPolls - 1) throw new Error('Training timed out after 60 minutes');
    }

    _runpodState.phase = 'downloading';
    updateProg('Training complete! Downloading PLY splat...');

    // --- Phase 8: Download PLY ---
    var plyBytes = await _jupyterDownloadBinary(podId, token, 'export/splat.ply');
    updateProg('Downloaded PLY (' + (plyBytes.length / 1e6).toFixed(1) + ' MB). Loading into viewer...');

    // --- Phase 9: Load into Spark.js ---
    await ensureSparkLoaded();
    if (_splatMesh) { scene.remove(_splatMesh); if (_splatMesh.dispose) _splatMesh.dispose(); _splatMesh = null; }
    var Spark = window.Spark;
    _splatMesh = new Spark.SplatMesh({
      fileBytes: plyBytes,
      onLoad: function(mesh) {
        var numSplats = mesh.numSplats || 'unknown';
        document.getElementById('splat-info').textContent = 'RunPod 3DGS: ' + numSplats + ' splats (' + (plyBytes.length / 1e6).toFixed(1) + ' MB)';
        toast('Splat loaded (' + numSplats + ' splats)');
        syncSplatSlidersToMesh();
      }
    });
    scene.add(_splatMesh);

    // --- Phase 10: Terminate pod ---
    updateProg('Splat loaded! Terminating pod to save costs...');
    await _runpodApi('DELETE', '/pods/' + podId);
    _runpodState.phase = 'done';
    _runpodState.podId = null;
    updateProg('Done! Pod terminated. Splat loaded in viewer.');
    toast('RunPod training complete — splat loaded!');

  } catch (err) {
    updateProg('Error: ' + err.message);
    toast('RunPod error: ' + err.message);
    console.error('RunPod training error:', err);
  } finally {
    btn.disabled = false; btn.textContent = 'Train on RunPod';
  }
}

async function runpodCheckStatus() {
  if (!_runpodState.podId) { toast('No active RunPod pod'); return; }
  var prog = document.getElementById('v2s-progress');
  prog.style.display = 'block';
  try {
    var res = await _runpodApi('GET', '/pods/' + _runpodState.podId);
    if (!res.ok) { prog.textContent = 'Pod status check failed: ' + res.status; return; }
    var data = await res.json();
    var status = data.desiredStatus || 'unknown';
    var uptime = data.runtime && data.runtime.uptimeInSeconds ? Math.round(data.runtime.uptimeInSeconds / 60) + ' min' : 'N/A';
    var gpu = data.runtime && data.runtime.gpus && data.runtime.gpus[0] ? data.runtime.gpus[0].gpuUtilPercent + '% GPU' : '';
    _runpodLog('Pod: ' + _runpodState.podId + '\nStatus: ' + status + '\nUptime: ' + uptime + (gpu ? '\nGPU: ' + gpu : ''));
    // Also check training status
    if (_runpodState.token) {
      var statusText = await _jupyterGetText(_runpodState.podId, _runpodState.token, 'STATUS');
      if (statusText) _runpodLog('Pod: ' + _runpodState.podId + '\nStatus: ' + status + '\nUptime: ' + uptime + (gpu ? '\nGPU: ' + gpu : '') + '\nTraining: ' + statusText.trim());
    }
    prog.textContent = 'Pod ' + status + ', uptime ' + uptime;
  } catch (err) {
    prog.textContent = 'Status check error: ' + err.message;
  }
}

async function runpodTerminate() {
  if (!_runpodState.podId) { toast('No active RunPod pod'); return; }
  var prog = document.getElementById('v2s-progress');
  prog.style.display = 'block';
  prog.textContent = 'Terminating pod ' + _runpodState.podId + '...';
  try {
    await _runpodApi('DELETE', '/pods/' + _runpodState.podId);
    _runpodLog('Pod ' + _runpodState.podId + ' terminated.');
    prog.textContent = 'Pod terminated.';
    _runpodState.podId = null;
    _runpodState.phase = null;
    toast('Pod terminated');
  } catch (err) {
    prog.textContent = 'Terminate error: ' + err.message;
  }
}

// ============================================================
// RUNPOD SERVERLESS 3DGS TRAINING
// ============================================================
var _serverlessState = { endpointId: null, templateId: null, jobId: null, phase: null };
var _SLS_DOCKER_IMAGE = 'runpod/pytorch:2.4.1-py3.11-cuda12.4.1-devel-ubuntu22.04';
var _SLS_STORAGE_KEY = 'runpod_sls_endpoint';

function toggleRunpodMode() {
  var mode = document.getElementById('runpod-mode').value;
  document.getElementById('runpod-serverless-cfg').style.display = mode === 'serverless' ? '' : 'none';
  document.getElementById('runpod-pod-cfg').style.display = mode === 'pod' ? '' : 'none';
}

function _slsUpdateEndpointInfo() {
  var el = document.getElementById('sls-endpoint-info');
  if (!el) return;
  var cached = localStorage.getItem(_SLS_STORAGE_KEY);
  if (cached) {
    try {
      var d = JSON.parse(cached);
      _serverlessState.endpointId = d.endpointId;
      _serverlessState.templateId = d.templateId;
      el.textContent = 'Endpoint: ' + d.endpointId + ' (ready)';
      el.style.color = 'var(--accent)';
    } catch(e) { el.textContent = 'Endpoint: auto-created on first run'; }
  } else {
    el.textContent = 'Endpoint: auto-created on first run';
    el.style.color = 'var(--text-dim)';
  }
}

async function _serverlessApi(method, path, body) {
  var opts = { method: method, headers: { 'Content-Type': 'application/json' } };
  if (body) opts.body = JSON.stringify(body);
  return proxiedFetch('https://api.runpod.ai/v2' + path, opts);
}

async function _runpodGql(query, variables) {
  var reqBody = { query: query, variables: variables || {} };
  _slsLogApi('GQL REQUEST', { query: query.replace(/\s+/g, ' ').trim(), variables: variables });
  var res = await proxiedFetch('https://api.runpod.io/graphql', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(reqBody)
  });
  var text = await res.text();
  var data;
  try { data = JSON.parse(text); } catch(e) { _slsLogApi('GQL RESPONSE ' + res.status, text); throw new Error('RunPod GraphQL error: ' + res.status + ' — ' + text.slice(0, 200)); }
  _slsLogApi('GQL RESPONSE ' + res.status, data);
  if (!res.ok) throw new Error('RunPod GraphQL error: ' + res.status);
  if (data.errors && data.errors.length) throw new Error('GQL: ' + data.errors[0].message);
  return data.data;
}

// Handler script that runs inside the serverless worker container.
// Receives frames + transforms via input, trains splatfacto, returns PLY as base64.
function _slsHandlerScript() {
  return [
    'import runpod, os, json, base64, subprocess, glob, shutil',
    '',
    'def handler(event):',
    '    inp = event["input"]',
    '    iters = inp.get("iterations", 7000)',
    '    transforms = inp.get("transforms", {})',
    '    frames = inp.get("frames", [])',
    '',
    '    # Write training data to /workspace/data',
    '    os.makedirs("/workspace/data/images", exist_ok=True)',
    '    with open("/workspace/data/transforms.json", "w") as f:',
    '        json.dump(transforms, f)',
    '    for fr in frames:',
    '        path = "/workspace/data/images/" + fr["name"]',
    '        with open(path, "wb") as f:',
    '            f.write(base64.b64decode(fr["b64"]))',
    '',
    '    # Install nerfstudio + gsplat (cached after first cold start)',
    '    if not shutil.which("ns-train"):',
    '        subprocess.run(["pip", "install", "nerfstudio", "gsplat"], check=True)',
    '',
    '    # Train splatfacto',
    '    subprocess.run([',
    '        "ns-train", "splatfacto",',
    '        "--data", "/workspace/data",',
    '        "--max-num-iterations", str(iters),',
    '        "--output-dir", "/workspace/ns-output",',
    '        "--viewer.quit-on-train-completion", "True",',
    '        "--pipeline.datamanager.dataparser", "nerfstudio-data"',
    '    ], check=True)',
    '',
    '    # Export gaussian splat',
    '    configs = glob.glob("/workspace/ns-output/**/splatfacto/**/config.yml", recursive=True)',
    '    if not configs:',
    '        return {"error": "No config.yml found after training"}',
    '    subprocess.run([',
    '        "ns-export", "gaussian-splat",',
    '        "--load-config", configs[0],',
    '        "--output-dir", "/workspace/export"',
    '    ], check=True)',
    '',
    '    # Read and return PLY as base64',
    '    ply_path = "/workspace/export/splat.ply"',
    '    if not os.path.exists(ply_path):',
    '        plys = glob.glob("/workspace/export/**/*.ply", recursive=True)',
    '        if plys: ply_path = plys[0]',
    '        else: return {"error": "No PLY output found"}',
    '    with open(ply_path, "rb") as f:',
    '        ply_b64 = base64.b64encode(f.read()).decode()',
    '    size_mb = os.path.getsize(ply_path) / 1e6',
    '',
    '    # Cleanup for next job',
    '    shutil.rmtree("/workspace/data", ignore_errors=True)',
    '    shutil.rmtree("/workspace/ns-output", ignore_errors=True)',
    '    shutil.rmtree("/workspace/export", ignore_errors=True)',
    '',
    '    return {"ply_b64": ply_b64, "size_mb": round(size_mb, 1)}',
    '',
    'runpod.serverless.start({"handler": handler})'
  ].join('\n');
}

// Auto-provision: create template + endpoint via GraphQL, cache in localStorage
async function _slsEnsureEndpoint(prog) {
  var cached = localStorage.getItem(_SLS_STORAGE_KEY);
  if (cached) {
    try {
      var d = JSON.parse(cached);
      if (d.endpointId) {
        _serverlessState.endpointId = d.endpointId;
        _serverlessState.templateId = d.templateId;
        _slsLogApi('ENDPOINT (cached)', d);
        return d.endpointId;
      }
    } catch(e) {}
  }

  prog('Creating serverless template...');

  // Encode handler as base64 for docker start command
  var handlerPy = _slsHandlerScript();
  var startCmd = 'pip install runpod && python -u /handler.py';

  // Create template
  var tmplData = await _runpodGql(
    'mutation createTemplate($input: CreateTemplateInput!) { createTemplate(input: $input) { id name } }',
    { input: {
      name: 'accel-driv-3dgs-' + Date.now().toString(36).slice(-4),
      imageName: _SLS_DOCKER_IMAGE,
      isServerless: true,
      containerDiskInGb: 40,
      volumeInGb: 20,
      volumeMountPath: '/workspace',
      startJupyter: false,
      startSsh: false,
      dockerArgs: 'bash -c "echo \'' + handlerPy.replace(/'/g, "'\\''") + '\' > /handler.py && ' + startCmd + '"'
    }}
  );
  var templateId = tmplData.createTemplate.id;
  prog('Template created: ' + templateId + '. Creating endpoint...');

  // Create serverless endpoint
  var epData = await _runpodGql(
    'mutation createEndpoint($input: CreateEndpointInput!) { createEndpoint(input: $input) { id name } }',
    { input: {
      name: 'accel-driv-3dgs',
      templateId: templateId,
      gpuIds: 'AMPERE_48',
      workersMin: 0,
      workersMax: 1,
      idleTimeout: 5,
      flashboot: true,
      scalerType: 'QUEUE_DELAY',
      scalerValue: 1
    }}
  );
  var endpointId = epData.createEndpoint.id;

  // Cache
  var cacheObj = { endpointId: endpointId, templateId: templateId, created: Date.now() };
  localStorage.setItem(_SLS_STORAGE_KEY, JSON.stringify(cacheObj));
  _serverlessState.endpointId = endpointId;
  _serverlessState.templateId = templateId;
  _slsUpdateEndpointInfo();
  prog('Endpoint ready: ' + endpointId);
  return endpointId;
}

async function runpodServerlessTrain() {
  var hasVideo = (document.getElementById('v2s-video-input').files[0]) || _runwayVideoUrl;
  if (!hasVideo) { toast('Choose a stylized video or run Stage 2 first'); return; }

  var iterations = parseInt(document.getElementById('s-serverless-iters').value);
  var maxFrames = parseInt(document.getElementById('s-serverless-maxframes').value);
  var btn = document.getElementById('btn-serverless-train');
  var prog = document.getElementById('v2s-progress');
  btn.disabled = true; btn.textContent = 'Starting...';
  prog.style.display = 'block';

  function updateProg(msg) { prog.textContent = msg; _runpodLog(msg); }

  try {
    // --- Phase 0: Auto-provision endpoint ---
    var endpointId = await _slsEnsureEndpoint(updateProg);

    // --- Phase 1: Ensure camera poses exist ---
    if (!_flyPoses.length || !_flyCamParams) {
      updateProg('Generating camera poses from track...');
      _generatePosesFromTrack();
    }
    updateProg('Generated ' + _flyPoses.length + ' poses. Extracting frames...');

    // --- Phase 2: Extract frames from video ---
    var data = await _buildTrainingFrames(function(m) { updateProg(m); });

    // Subsample if over maxFrames
    if (data.frames.length > maxFrames) {
      updateProg('Subsampling ' + data.frames.length + ' frames to ' + maxFrames + '...');
      var step = data.frames.length / maxFrames;
      var sampled = [];
      for (var si = 0; si < maxFrames; si++) {
        sampled.push(data.frames[Math.round(si * step)]);
      }
      data.frames = sampled;
      // Rebuild transforms for subsampled frames
      data.transforms = _buildTransformsJson(
        data.frames.map(function(f) { return { elements: f.elements }; }),
        _flyCamParams.w, _flyCamParams.h, _flyCamParams.fov
      );
      for (var fi = 0; fi < data.transforms.frames.length; fi++) {
        data.transforms.frames[fi].file_path = 'images/' + data.frames[fi].name;
      }
    }

    updateProg('Extracted ' + data.frames.length + ' frames. Submitting serverless job...');

    // --- Phase 3: Build payload ---
    var payload = {
      input: {
        action: 'train_3dgs',
        iterations: iterations,
        transforms: data.transforms,
        frames: data.frames.map(function(f) { return { name: f.name, b64: f.b64 }; })
      }
    };

    // --- Phase 4: Submit to serverless endpoint ---
    _serverlessState.phase = 'submitting';
    _slsLogApi('SUBMIT POST /' + endpointId + '/run', { frames: data.frames.length + ' frames', iterations: iterations });
    var submitRes = await _serverlessApi('POST', '/' + endpointId + '/run', payload);
    var submitText = await submitRes.text();
    var submitData;
    try { submitData = JSON.parse(submitText); } catch(e) { submitData = submitText; }
    _slsLogApi('SUBMIT RESPONSE ' + submitRes.status, submitData);
    if (!submitRes.ok) {
      throw new Error('Submit failed (' + submitRes.status + '): ' + (typeof submitData === 'string' ? submitData : JSON.stringify(submitData)).slice(0, 300));
    }
    var jobId = submitData.id;
    if (!jobId) throw new Error('No job ID returned. Response: ' + JSON.stringify(submitData).slice(0, 300));
    _serverlessState.jobId = jobId;
    _serverlessState.phase = 'queued';
    updateProg('Job submitted: ' + jobId + '. Waiting for worker...');

    // --- Phase 5: Poll for completion ---
    var maxPolls = 720; // 60 min at 5s intervals
    for (var pi = 0; pi < maxPolls; pi++) {
      await pollSleep(5000);
      var statusRes = await _serverlessApi('GET', '/' + endpointId + '/status/' + jobId);
      var statusText = await statusRes.text();
      var statusData;
      try { statusData = JSON.parse(statusText); } catch(e) { statusData = null; }
      // Log every poll (but only full detail every 6th poll or on state change)
      if (statusData) {
        var prevPhase = _serverlessState.phase;
        var curStatus = statusData.status || '';
        if (pi % 6 === 0 || curStatus !== prevPhase.toUpperCase()) {
          _slsLogApi('STATUS ' + statusRes.status + ' (poll #' + (pi + 1) + ')', statusData);
        }
      } else {
        _slsLogApi('STATUS ' + statusRes.status + ' (poll #' + (pi + 1) + ')', statusText);
      }
      if (!statusRes.ok) {
        updateProg('Status poll failed (' + statusRes.status + '), retrying...');
        continue;
      }
      if (!statusData) { updateProg('Invalid JSON from status poll, retrying...'); continue; }
      var jobStatus = statusData.status;
      var elapsed = Math.round((pi + 1) * 5 / 60);

      if (jobStatus === 'COMPLETED') {
        _serverlessState.phase = 'completed';
        _slsLogApi('JOB COMPLETED', statusData);
        updateProg('Job completed! Processing result...');

        // --- Phase 6: Extract result ---
        var output = statusData.output;
        if (!output) throw new Error('Job completed but no output returned. Full response: ' + JSON.stringify(statusData).slice(0, 500));

        var plyBytes = null;
        if (output.ply_b64) {
          var raw = atob(output.ply_b64);
          plyBytes = new Uint8Array(raw.length);
          for (var bi = 0; bi < raw.length; bi++) plyBytes[bi] = raw.charCodeAt(bi);
        } else if (output.ply_url) {
          updateProg('Downloading PLY from ' + output.ply_url.substring(0, 60) + '...');
          var dlRes = await proxiedFetch(output.ply_url);
          if (!dlRes.ok) throw new Error('PLY download failed: ' + dlRes.status);
          plyBytes = new Uint8Array(await dlRes.arrayBuffer());
        } else if (output.splat_b64) {
          var raw = atob(output.splat_b64);
          plyBytes = new Uint8Array(raw.length);
          for (var bi = 0; bi < raw.length; bi++) plyBytes[bi] = raw.charCodeAt(bi);
        } else if (output.splat_url) {
          updateProg('Downloading splat from ' + output.splat_url.substring(0, 60) + '...');
          var dlRes = await proxiedFetch(output.splat_url);
          if (!dlRes.ok) throw new Error('Splat download failed: ' + dlRes.status);
          plyBytes = new Uint8Array(await dlRes.arrayBuffer());
        } else {
          throw new Error('No PLY or splat in job output. Keys: ' + Object.keys(output).join(', '));
        }

        updateProg('Downloaded splat (' + (plyBytes.length / 1e6).toFixed(1) + ' MB). Loading into viewer...');

        // --- Phase 7: Load into Spark.js ---
        await ensureSparkLoaded();
        if (_splatMesh) { scene.remove(_splatMesh); if (_splatMesh.dispose) _splatMesh.dispose(); _splatMesh = null; }
        var Spark = window.Spark;
        _splatMesh = new Spark.SplatMesh({
          fileBytes: plyBytes,
          onLoad: function(mesh) {
            var numSplats = mesh.numSplats || 'unknown';
            document.getElementById('splat-info').textContent = 'Serverless 3DGS: ' + numSplats + ' splats (' + (plyBytes.length / 1e6).toFixed(1) + ' MB)';
            toast('Splat loaded (' + numSplats + ' splats)');
            syncSplatSlidersToMesh();
          }
        });
        scene.add(_splatMesh);

        _serverlessState.phase = 'done';
        updateProg('Done! Splat loaded in viewer. Job: ' + jobId);
        toast('Serverless training complete — splat loaded!');
        break;

      } else if (jobStatus === 'FAILED') {
        _slsLogApi('JOB FAILED', statusData);
        var errMsg = statusData.error || (statusData.output && statusData.output.error) || JSON.stringify(statusData).slice(0, 500);
        throw new Error('Job failed: ' + errMsg);

      } else if (jobStatus === 'CANCELLED') {
        _slsLogApi('JOB CANCELLED', statusData);
        throw new Error('Job was cancelled');

      } else {
        _serverlessState.phase = jobStatus.toLowerCase();
        var detail = '';
        if (statusData.output && statusData.output.progress) detail = ' — ' + statusData.output.progress;
        if (statusData.executionTime) detail += ' (exec: ' + Math.round(statusData.executionTime / 1000) + 's)';
        if (statusData.delayTime) detail += ' (queue: ' + Math.round(statusData.delayTime / 1000) + 's)';
        updateProg('Job ' + jobStatus + detail + ' (' + elapsed + ' min)');
      }

      if (pi >= maxPolls - 1) throw new Error('Job timed out after 60 minutes');
    }

  } catch (err) {
    updateProg('Error: ' + err.message);
    toast('Serverless error: ' + err.message);
    console.error('Serverless training error:', err);
  } finally {
    btn.disabled = false; btn.textContent = 'Train (Serverless)';
  }
}

async function serverlessCheckStatus() {
  var endpointId = _serverlessState.endpointId;
  var jobId = _serverlessState.jobId;
  if (!endpointId || !jobId) { toast('No active serverless job'); return; }
  var prog = document.getElementById('v2s-progress');
  prog.style.display = 'block';
  try {
    var res = await _serverlessApi('GET', '/' + endpointId + '/status/' + jobId);
    var text = await res.text();
    var data;
    try { data = JSON.parse(text); } catch(e) { data = null; }
    _slsLogApi('CHECK STATUS ' + res.status, data || text);
    if (!res.ok) { prog.textContent = 'Status check failed: ' + res.status; return; }
    if (!data) { prog.textContent = 'Invalid response'; return; }
    var lines = ['Job: ' + jobId, 'Status: ' + data.status];
    if (data.delayTime != null) lines.push('Queue time: ' + (data.delayTime / 1000).toFixed(1) + 's');
    if (data.executionTime != null) lines.push('Exec time: ' + (data.executionTime / 1000).toFixed(1) + 's');
    if (data.workerId) lines.push('Worker: ' + data.workerId);
    if (data.output) {
      var outKeys = Object.keys(data.output);
      if (data.output.progress) lines.push('Progress: ' + data.output.progress);
      if (data.output.error) lines.push('Error: ' + data.output.error);
      if (data.output.size_mb) lines.push('Output: ' + data.output.size_mb + ' MB');
      lines.push('Output keys: ' + outKeys.join(', '));
    }
    if (data.error) lines.push('Error: ' + data.error);
    _runpodLog(lines.join('\n'));
    prog.textContent = 'Job ' + data.status + (data.output && data.output.progress ? ' — ' + data.output.progress : '');
  } catch (err) {
    prog.textContent = 'Status error: ' + err.message;
  }
}

async function serverlessCancel() {
  var endpointId = _serverlessState.endpointId;
  var jobId = _serverlessState.jobId;
  if (!endpointId || !jobId) { toast('No active serverless job'); return; }
  var prog = document.getElementById('v2s-progress');
  prog.style.display = 'block';
  prog.textContent = 'Cancelling job ' + jobId + '...';
  try {
    var res = await _serverlessApi('POST', '/' + endpointId + '/cancel/' + jobId);
    var text = await res.text();
    var data; try { data = JSON.parse(text); } catch(e) { data = text; }
    _slsLogApi('CANCEL ' + res.status, data);
    _runpodLog('Job ' + jobId + ' cancelled.');
    prog.textContent = 'Job cancelled.';
    _serverlessState.jobId = null;
    _serverlessState.phase = null;
    toast('Job cancelled');
  } catch (err) {
    prog.textContent = 'Cancel error: ' + err.message;
  }
}

async function serverlessDeleteEndpoint() {
  var cached = localStorage.getItem(_SLS_STORAGE_KEY);
  if (!cached) { toast('No cached endpoint'); return; }
  var d;
  try { d = JSON.parse(cached); } catch(e) { localStorage.removeItem(_SLS_STORAGE_KEY); _slsUpdateEndpointInfo(); toast('Cache cleared'); return; }
  var prog = document.getElementById('v2s-progress');
  prog.style.display = 'block';
  prog.textContent = 'Deleting endpoint ' + d.endpointId + '...';
  try {
    // Delete endpoint
    if (d.endpointId) {
      await _runpodGql('mutation { deleteEndpoint(id: "' + d.endpointId + '") }');
    }
    // Delete template
    if (d.templateId) {
      await _runpodGql('mutation { deleteTemplate(templateName: "' + d.templateId + '") }');
    }
    prog.textContent = 'Endpoint deleted.';
  } catch(err) {
    prog.textContent = 'Cleanup: ' + err.message + ' (cache cleared)';
  }
  localStorage.removeItem(_SLS_STORAGE_KEY);
  _serverlessState.endpointId = null;
  _serverlessState.templateId = null;
  _slsUpdateEndpointInfo();
  toast('Endpoint reset');
}

// ============================================================
// DRAWER (mobile)
// ============================================================
function setupDrawer(){}
function toggleDrawer(){var sb=document.getElementById('sidebar');drawerOpen=!drawerOpen;sb.classList.toggle('open',drawerOpen)}

// ============================================================
// ANIMATION
// ============================================================
function animate(time){
requestAnimationFrame(animate);
updCam();
rndr.clear();
rndr.render(scene, cam);
var s=isMobile?70:120;var d=new THREE.Vector3().subVectors(cam.position,orb.tgt).normalize();cCam.position.copy(d.multiplyScalar(3.5));cCam.lookAt(0,0,0);
var vp=rndr.getSize(new THREE.Vector2());rndr.setViewport(vp.x-s-10,vp.y-s-10,s,s);rndr.setScissor(vp.x-s-10,vp.y-s-10,s,s);rndr.setScissorTest(true);rndr.clearDepth();rndr.render(cScene,cCam);rndr.setScissorTest(false);rndr.setViewport(0,0,vp.x,vp.y);
}

// Expose for inline HTML handlers
Object.assign(window,{switchTab,toggleDrawer,fitView,loadFile,exportTrack,undoAll,handleFile,handleImageUpload,setEditMode,smoothSelection,smoothAll,applyElevation,extractControlPoints,rebuildFromSpline,updateCPFromInput,insertCPAfter,deleteSelectedCP,onDefaultWidthChange,setAllWidths,onCPWidthChange,widthPreset,rebuildWithWidth,previewLoop,makeLoop,removeLoop,generateTerrain,clearTerrain,toggleSpeedPads,placeSpeedPads,toggleAICars,placeAICars,generateScenery,clearScenery,toggleScenery,exportAll,startGame,stopGame,generateMarbleWorld,trackAwarePrompt,loadSplatFromURL,loadSplatFromFile,removeSplat,splatBackdropPreset,splatResetTransform,checkMarbleOperation,clearMarblePending,checkRunwayOperation,clearRunwayPending,exportTrainingViews,previewPanoCaptures,batchPanoMarble,loadPanoSection,exportPanoSections,recordFlythrough,downloadFlythrough,runRunwayStylize,runMarbleFromVideo,runFullPipeline,onProviderChange,onModelChange,runStylize,checkPendingOperation,clearAllPending,generateKiri,checkKiriStatus,clearKiriPending,exportFlythroughTraining,extractStylizedTraining,runpodTrain,runpodCheckStatus,runpodTerminate,useStylizedVideo});
init();fitView();showMarblePending();showRunwayPending();showDecartPending();showKiriPending();onRunwayModelChange();
</script>

</body>
</html>
