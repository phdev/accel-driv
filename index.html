<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,maximum-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Horizon Drive</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
canvas{display:block;width:100%;height:100%}

#ui-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:10;pointer-events:none}
#ui-overlay>*{pointer-events:auto}

/* HUD */
#hud{position:absolute;top:0;left:0;right:0;display:flex;justify-content:space-between;align-items:center;padding:8px 16px;font:700 14px/1 system-ui,sans-serif;color:#fff;background:linear-gradient(180deg,rgba(0,0,0,.5),transparent);display:none}
#hud .speed{font-size:22px;color:#0ff;text-shadow:0 0 10px #0ff}
#hud .time{font-size:18px;color:#ffd700;text-shadow:0 0 8px rgba(255,215,0,.5)}
#hud .progress{font-size:12px;opacity:.7}

/* Start screen */
#start-screen{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(ellipse at 50% 60%,#1a0040,#0a001a);z-index:20}
#start-screen h1{font:900 2.8rem/1 system-ui;background:linear-gradient(135deg,#ff6ec7,#ffd700);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:.3rem}
#start-screen .sub{font:400 .85rem/1 system-ui;color:#a080d0;margin-bottom:2.5rem}
#start-btn{
  background:linear-gradient(135deg,#ff6ec7,#ff3cac);color:#fff;border:none;
  padding:16px 48px;border-radius:14px;font:700 1.1rem system-ui;cursor:pointer;
  box-shadow:0 4px 24px rgba(255,60,172,.4);-webkit-tap-highlight-color:transparent;
}
#start-btn:active{transform:scale(.96)}
.controls-hint{font:400 .7rem/1.5 system-ui;color:#8060b0;margin-top:1.5rem;text-align:center}

/* Countdown */
#countdown{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font:900 6rem system-ui;color:#fff;text-shadow:0 0 40px #ff6ec7,0 0 80px #ff3cac;display:none;z-index:15}

/* Finish screen */
#finish-screen{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.75);backdrop-filter:blur(8px);display:none;z-index:20}
#finish-screen h2{font:900 2rem system-ui;color:#ffd700;text-shadow:0 0 20px rgba(255,215,0,.5);margin-bottom:.5rem}
#finish-screen .final-time{font:700 3.5rem system-ui;color:#fff;margin-bottom:.3rem}
#finish-screen .label{font:400 .8rem system-ui;color:#a080d0;margin-bottom:2rem}
#restart-btn{
  background:linear-gradient(135deg,#6e3cff,#3c8cff);color:#fff;border:none;
  padding:14px 40px;border-radius:14px;font:700 1rem system-ui;cursor:pointer;
  box-shadow:0 4px 20px rgba(60,140,255,.35);-webkit-tap-highlight-color:transparent;
}

/* Tilt indicator */
#tilt-indicator{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:120px;height:6px;background:rgba(255,255,255,.1);border-radius:3px;display:none}
#tilt-dot{position:absolute;top:50%;left:50%;width:14px;height:14px;background:#ff6ec7;border-radius:50%;transform:translate(-50%,-50%);box-shadow:0 0 10px #ff6ec7;transition:left .05s}

/* Loading */
#loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#a080d0;font:600 1rem system-ui;z-index:25}
</style>
</head>
<body>

<div id="ui-overlay">
  <div id="loading">Loading track...</div>

  <div id="start-screen" style="display:none">
    <h1>HORIZON DRIVE</h1>
    <p class="sub">Accelerometer Racing</p>
    <button id="start-btn">START</button>
    <p class="controls-hint">Tilt phone to steer &bull; Auto-gas<br>Or use arrow keys on desktop</p>
  </div>

  <div id="hud">
    <div><span class="speed" id="speed-val">0</span> <span style="font-size:11px;opacity:.5">km/h</span></div>
    <div class="time" id="time-val">0:00.0</div>
    <div class="progress" id="progress-val">0%</div>
    <div id="boost-hud" style="display:none;color:#0f0;font-size:16px;font-weight:900;text-shadow:0 0 12px #0f0,0 0 24px #0f0">BOOST!</div>
  </div>
  <div id="position-hud" style="position:absolute;top:50px;right:16px;font:900 28px system-ui;color:#ffd700;text-shadow:0 0 12px rgba(255,215,0,.6);display:none"><span id="pos-num">1</span><span id="pos-suffix" style="font-size:14px;opacity:.7">st</span><span style="font-size:12px;opacity:.5;margin-left:4px">/ 6</span></div>

  <div id="countdown"></div>

  <div id="finish-screen">
    <h2>FINISH!</h2>
    <div class="final-time" id="final-time">0:00.00</div>
    <div class="label">Your Time</div>
    <button id="restart-btn">RACE AGAIN</button>
  </div>

  <div id="tilt-indicator">
    <div id="tilt-dot"></div>
  </div>

  <label id="free-roam-label" style="position:absolute;bottom:50px;left:16px;display:flex;align-items:center;gap:6px;font:400 .75rem system-ui;color:rgba(192,160,224,.7);cursor:pointer;z-index:30">
    <input type="checkbox" id="free-roam-cb" style="width:16px;height:16px;accent-color:#ff6ec7;cursor:pointer">
    Disable rail
  </label>

  <button id="drift-btn" style="position:absolute;bottom:16px;right:16px;width:80px;height:80px;border-radius:50%;border:3px solid #ff6ec7;background:rgba(255,110,199,.15);color:#ff6ec7;font:900 14px system-ui;text-transform:uppercase;letter-spacing:1px;cursor:pointer;z-index:30;display:none;-webkit-tap-highlight-color:transparent;touch-action:none;text-shadow:0 0 8px #ff6ec7;box-shadow:0 0 16px rgba(255,110,199,.3)">DRIFT</button>
  <div id="drift-hud" style="position:absolute;top:50px;left:16px;font:900 18px system-ui;color:#ff6ec7;text-shadow:0 0 12px rgba(255,110,199,.8);display:none">DRIFT!</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
(function(){
'use strict';

// ── CONFIG ──
const CFG = {
  // max km/h
  maxSpeed: 270,
  // km/h per second acceleration
  accel: 67,
  // km/h per second braking
  brake: 120,
  // passive decel km/h/s
  friction: 12,
  // lateral offset speed
  steerSpeed: 14,
  // max lateral offset from center
  maxLateral: 19,
  // road visual width
  roadWidth: 40,
  cameraHeight: 4.5,
  cameraDist: 12,
  cameraLerp: 0.08,
  fov: 72,
  // Boost pads
  // lots of boost pads throughout the track
  boostCount: 40,
  // speed during boost (km/h)
  boostSpeed: 390,
  // seconds of boost (shorter since there are more)
  boostDuration: 1.5,
  // pad width on road
  boostPadWidth: 6,
  // pad length along track
  boostPadLength: 4,
  // AI opponents
  // number of AI cars
  aiCount: 5,
  // slowest AI base speed (km/h)
  aiMinSpeed: 165,
  // fastest AI base speed (km/h)
  aiMaxSpeed: 248,
  // lateral weave amplitude
  aiWeaveAmp: 2.5,
  // weave frequency (Hz)
  aiWeaveFreq: 0.3,
  // Drift
  driftMinSpeed: 60,
  driftLateralGrip: 0.55,
  driftLongGrip: 0.95,
  driftSpeedBleed: 0.15,
  driftAssistGain: 0.8,
  driftMaxAssist: 1.0,
  driftBaseSlip: 15,
  driftMaxSlip: 45,
  driftKSteer: 20,
  driftExitSnap: 0.05,
  driftEnterSteer: 0.3,
  driftExitSteer: 0.2,
};

// ── STATE ──
let trackData = null;
let curve = null;
let trackLength = 0;
let scene, camera, renderer, composer, bloomPass;
let roadMesh, groundMesh;
let carGroup, carBody;
let barrierLeft, barrierRight;
// [{t: 0..1, mesh, used: false}]
let boostPads = [];
// remaining boost seconds
let boostTimer = 0;
// for animation
let boostMeshes = [];
// [{group, progress, speed, baseSpeed, lateral, weavePhase}]
let aiCars = [];
// 1-based position among all racers
let playerPosition = 1;

// loading, ready, countdown, racing, finished
let gameState = 'loading';
let raceStartTime = 0;
let raceTime = 0;
// km/h
let speed = 0;
// 0..1
let trackProgress = 0;
// left/right offset from track center
let lateralOffset = 0;
// -1 to 1
let steerInput = 0;
// smoothed Y-axis rotation for car
let smoothYaw = 0;
// free-roam: car moves in its own direction, not on the rail
let freeRoam = false;
let freePos = new THREE.Vector3();
let freeHeading = 0;
// Drift state
let driftState = 'grip';
let driftSign = 0;
let driftAngle = 0;
let driftBtnHeld = false;

// Input
let keys = {};
let gyroGamma = 0;
let gyroCal = 0;
let gyroAvailable = false;
// degrees — minimal deadzone for high sensitivity
const DEADZONE = 3;

// DOM
const $loading = document.getElementById('loading');
const $startScreen = document.getElementById('start-screen');
const $startBtn = document.getElementById('start-btn');
const $hud = document.getElementById('hud');
const $speedVal = document.getElementById('speed-val');
const $timeVal = document.getElementById('time-val');
const $progressVal = document.getElementById('progress-val');
const $countdown = document.getElementById('countdown');
const $finishScreen = document.getElementById('finish-screen');
const $finalTime = document.getElementById('final-time');
const $restartBtn = document.getElementById('restart-btn');
const $tiltIndicator = document.getElementById('tilt-indicator');
const $tiltDot = document.getElementById('tilt-dot');
const $positionHud = document.getElementById('position-hud');
const $posNum = document.getElementById('pos-num');
const $posSuffix = document.getElementById('pos-suffix');

// ── LOAD TRACK ──
fetch('track.json')
  .then(r => r.json())
  .then(data => {
    trackData = data;
    init();
  })
  .catch(e => {
    $loading.textContent = 'Failed to load track: ' + e.message;
  });

function init() {
  // Build Three.js curve from track data
  // Use every 3rd point to keep it manageable (1000 control points)
  const points = [];
  for (let i = 0; i < trackData.length; i += 3) {
    const p = trackData[i][0];
    // Swap Y/Z for Three.js coordinate system (Y up)
    points.push(new THREE.Vector3(p[0], p[2], -p[1]));
  }
  curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
  trackLength = curve.getLength();

  setupScene();
  buildTrack();
  buildCar();
  buildAICars();
  buildEnvironment();
  setupInput();
  setupUI();

  $loading.style.display = 'none';
  $startScreen.style.display = 'flex';
  gameState = 'ready';

  // Position camera at start
  updateCarPosition(0, 0);
  updateCamera(true);

  animate();
}

// ── SCENE SETUP ──
function setupScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a001a);
  scene.fog = new THREE.FogExp2(0x0a001a, 0.004);

  camera = new THREE.PerspectiveCamera(CFG.fov, innerWidth/innerHeight, 0.5, 800);
  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambient = new THREE.AmbientLight(0x4040a0, 0.4);
  scene.add(ambient);

  const dirLight = new THREE.DirectionalLight(0xffeedd, 0.8);
  dirLight.position.set(50, 100, 50);
  scene.add(dirLight);

  // Neon glow from below
  const underLight = new THREE.PointLight(0xff6ec7, 0.6, 100);
  underLight.position.set(0, -5, 0);
  scene.add(underLight);

  // ── BLOOM POST-PROCESSING ──
  const renderPass = new THREE.RenderPass(scene, camera);
  bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    // bloom strength (Horizon Drive uses heavy bloom)
    1.4,
    // bloom radius (how far glow spreads)
    0.6,
    // bloom threshold (low = more things glow)
    0.15
  );
  composer = new THREE.EffectComposer(renderer);
  composer.addPass(renderPass);
  composer.addPass(bloomPass);

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
  });
}

// ── BUILD TRACK ──
function buildTrack() {
  const divisions = 2000;
  const halfWidth = CFG.roadWidth / 2;

  // Road surface
  const roadGeo = new THREE.BufferGeometry();
  const vertices = [];
  const colors = [];
  const indices = [];

  for (let i = 0; i <= divisions; i++) {
    const t = i / divisions;
    const point = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();

    // If cross product is degenerate, use fallback
    if (right.length() < 0.1) {
      right.set(1, 0, 0);
    }

    const lx = point.x - right.x * halfWidth;
    const ly = point.y - right.y * halfWidth;
    const lz = point.z - right.z * halfWidth;
    const rx = point.x + right.x * halfWidth;
    const ry = point.y + right.y * halfWidth;
    const rz = point.z + right.z * halfWidth;

    vertices.push(lx, ly, lz, rx, ry, rz);

    // Neon road coloring - subtle stripe pattern
    const stripe = (i % 40 < 2) ? 1.0 : 0.15;
    const edgeGlow = 0.5;
    // Left edge: pink, Right edge: cyan, Center: dark
    // left - pink
    colors.push(stripe * 0.8, stripe * 0.1, stripe * 0.5, 1);
    // right - cyan
    colors.push(stripe * 0.1, stripe * 0.5, stripe * 0.8, 1);

    if (i < divisions) {
      const base = i * 2;
      indices.push(base, base + 1, base + 2);
      indices.push(base + 1, base + 3, base + 2);
    }
  }

  roadGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  roadGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));
  roadGeo.setIndex(indices);
  roadGeo.computeVertexNormals();

  const roadMat = new THREE.MeshStandardMaterial({
    vertexColors: true,
    metalness: 0.8,
    roughness: 0.2,
    emissive: new THREE.Color(0x330066),
    emissiveIntensity: 0.6,
    side: THREE.DoubleSide,
  });

  roadMesh = new THREE.Mesh(roadGeo, roadMat);
  scene.add(roadMesh);

  // Edge barriers (neon rails)
  buildBarriers(divisions, halfWidth);

  // Start/finish line
  buildStartLine();

  // Boost pads
  buildBoostPads();
}

function buildBarriers(divisions, halfWidth) {
  const step = 4;
  const leftPts = [];
  const rightPts = [];

  for (let i = 0; i <= divisions; i += step) {
    const t = i / divisions;
    const point = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
    if (right.length() < 0.1) right.set(1, 0, 0);

    leftPts.push(new THREE.Vector3(
      point.x - right.x * (halfWidth + 0.3),
      point.y + 0.4,
      point.z - right.z * (halfWidth + 0.3)
    ));
    rightPts.push(new THREE.Vector3(
      point.x + right.x * (halfWidth + 0.3),
      point.y + 0.4,
      point.z + right.z * (halfWidth + 0.3)
    ));
  }

  // Glowing tube barriers using TubeGeometry on CatmullRomCurve3
  const leftCurve = new THREE.CatmullRomCurve3(leftPts, false, 'catmullrom', 0.5);
  const rightCurve = new THREE.CatmullRomCurve3(rightPts, false, 'catmullrom', 0.5);

  // Left barrier - hot pink neon glow
  const leftGeo = new THREE.TubeGeometry(leftCurve, divisions / step, 0.12, 6, false);
  const leftMat = new THREE.MeshBasicMaterial({ color: 0xff6ec7 });
  barrierLeft = new THREE.Mesh(leftGeo, leftMat);
  scene.add(barrierLeft);

  // Right barrier - cyan neon glow
  const rightGeo = new THREE.TubeGeometry(rightCurve, divisions / step, 0.12, 6, false);
  const rightMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  barrierRight = new THREE.Mesh(rightGeo, rightMat);
  scene.add(barrierRight);
}

function buildStartLine() {
  const geo = new THREE.PlaneGeometry(CFG.roadWidth, 1.5);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffd700,
    side: THREE.DoubleSide,
  });
  const startLine = new THREE.Mesh(geo, mat);

  const p = curve.getPointAt(0);
  const t = curve.getTangentAt(0).normalize();
  const up = new THREE.Vector3(0, 1, 0);
  startLine.position.copy(p);
  startLine.position.y += 0.05;
  startLine.lookAt(p.clone().add(t));
  startLine.rotateX(-Math.PI / 2);
  scene.add(startLine);
}

function buildBoostPads() {
  boostPads = [];
  boostMeshes = [];

  // Shared geometries — bigger and brighter
  const baseGeo = new THREE.PlaneGeometry(CFG.boostPadWidth, CFG.boostPadLength);
  const baseMat = new THREE.MeshBasicMaterial({
    color: 0x00ffaa, transparent: true, opacity: 0.55, side: THREE.DoubleSide,
    depthWrite: false,
  });
  const arrowMat = new THREE.MeshBasicMaterial({
    color: 0x44ffaa, side: THREE.DoubleSide, depthWrite: false,
  });

  // Build a bigger, chunkier chevron arrow (pointing backward in local Y so it faces forward after lookAt)
  const arrowShape = new THREE.Shape();
  arrowShape.moveTo(0, -1.1);
  arrowShape.lineTo(-0.7, 0.3);
  arrowShape.lineTo(-0.3, 0.3);
  arrowShape.lineTo(0, -0.2);
  arrowShape.lineTo(0.3, 0.3);
  arrowShape.lineTo(0.7, 0.3);
  arrowShape.closePath();
  const arrowGeo = new THREE.ShapeGeometry(arrowShape);

  for (let i = 0; i < CFG.boostCount; i++) {
    const t = 0.05 + (i / CFG.boostCount) * 0.9;

    const tA = Math.max(0, t - 0.001);
    const tB = Math.min(0.9999, t + 0.001);
    const point = curve.getPointAt(t);
    const pA = curve.getPointAt(tA);
    const pB = curve.getPointAt(tB);

    const tangent = new THREE.Vector3().subVectors(pB, pA).normalize();
    const worldUp = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, worldUp).normalize();
    if (right.lengthSq() < 0.01) right.set(1, 0, 0);
    const normal = new THREE.Vector3().crossVectors(right, tangent).normalize();

    const padGroup = new THREE.Group();
    padGroup.position.copy(point);
    // Lift above road surface to avoid z-fighting
    padGroup.position.addScaledVector(normal, 0.2);

    // Orient: look along the tangent (track forward), with surface normal as up
    const lookTarget = point.clone().add(tangent);
    lookTarget.addScaledVector(normal, 0.2);
    padGroup.up.copy(normal);
    padGroup.lookAt(lookTarget);

    // Base rectangle — XY plane facing up after lookAt
    const base = new THREE.Mesh(baseGeo, baseMat.clone());
    base.rotation.x = -Math.PI / 2;
    padGroup.add(base);

    // 3 chevron arrows spread along the forward (local Z) direction
    for (let a = -1; a <= 1; a++) {
      const arrow = new THREE.Mesh(arrowGeo, arrowMat);
      arrow.rotation.x = -Math.PI / 2;
      arrow.position.set(0, 0.02, a * 1.3);
      arrow.scale.set(1.5, 1.5, 1.5);
      padGroup.add(arrow);
    }

    // Edge glow strips on left/right sides
    const edgeGeo = new THREE.PlaneGeometry(0.3, CFG.boostPadLength);
    const edgeMat = new THREE.MeshBasicMaterial({
      color: 0x00ff44, side: THREE.DoubleSide, depthWrite: false,
    });
    const edgeL = new THREE.Mesh(edgeGeo, edgeMat);
    edgeL.rotation.x = -Math.PI / 2;
    edgeL.position.set(-CFG.boostPadWidth / 2, 0.01, 0);
    padGroup.add(edgeL);
    const edgeR = new THREE.Mesh(edgeGeo, edgeMat);
    edgeR.rotation.x = -Math.PI / 2;
    edgeR.position.set(CFG.boostPadWidth / 2, 0.01, 0);
    padGroup.add(edgeR);

    scene.add(padGroup);
    boostPads.push({ t: t, group: padGroup, active: false });
    boostMeshes.push(padGroup);
  }
}

// ── BUILD CAR ──
function buildCar() {
  carGroup = new THREE.Group();

  // Load GLB model
  const loader = new THREE.GLTFLoader();
  loader.load('base_basic_shaded.glb', (gltf) => {
    const model = gltf.scene;

    // Auto-center and scale the model
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    // Scale to fit roughly 8 units long (car length)
    const targetLength = 8;
    const maxDim = Math.max(size.x, size.y, size.z);
    const s = targetLength / maxDim;
    model.scale.setScalar(s);

    // Re-center after scaling
    box.setFromObject(model);
    box.getCenter(center);
    model.position.sub(center);
    // Sit on ground plane
    box.setFromObject(model);
    model.position.y -= box.min.y;

    carGroup.add(model);
  });

  // Headlight beams
  const beamLight = new THREE.SpotLight(0xffffff, 2.0, 80, Math.PI/6, 0.5);
  beamLight.position.set(0, 0.5, 2);
  beamLight.target.position.set(0, 0, 20);
  carGroup.add(beamLight);
  carGroup.add(beamLight.target);

  // Neon underglow
  const underGlow = new THREE.PointLight(0xff6ec7, 2.5, 12);
  underGlow.position.set(0, -0.1, 0);
  carGroup.add(underGlow);

  // Underglow visible mesh
  const ugGeo = new THREE.PlaneGeometry(1.4, 2.8);
  const ugMat = new THREE.MeshBasicMaterial({
    color: 0xff6ec7, transparent: true, opacity: 0.4, side: THREE.DoubleSide,
  });
  const ugMesh = new THREE.Mesh(ugGeo, ugMat);
  ugMesh.rotation.x = -Math.PI / 2;
  ugMesh.position.y = 0.02;
  carGroup.add(ugMesh);

  scene.add(carGroup);
}

// ── SKID MARKS ──
const skidMarks = [];
const SKID_MAX = 600;
const SKID_FADE_TIME = 3.0;
const skidMat = new THREE.MeshBasicMaterial({
  color: 0x222222, transparent: true, opacity: 0.7,
  side: THREE.DoubleSide, depthWrite: false,
});
// Car-local wheel offsets (x = lateral, z = front/back) — scaled to the 8-unit car
const WHEEL_OFFSETS = [
  { x: -0.9, z: -1.6 },
  { x:  0.9, z: -1.6 },
  { x: -0.9, z:  1.4 },
  { x:  0.9, z:  1.4 },
];
let lastSkidTime = 0;

function spawnSkidMarks(trackPoint, rightVec, lateral) {
  const now = performance.now() * 0.001;
  // Spawn every ~16ms (60fps)
  if (now - lastSkidTime < 0.016) return;
  lastSkidTime = now;

  const tangent = curve.getTangentAt(Math.max(0, Math.min(0.9999, trackProgress))).normalize();
  // Build car's world-space forward and right using smoothYaw
  const cosY = Math.cos(smoothYaw);
  const sinY = Math.sin(smoothYaw);
  // Car forward = tangent rotated by smoothYaw around up axis
  const fwdX = tangent.x * cosY + tangent.z * sinY;
  const fwdZ = -tangent.x * sinY + tangent.z * cosY;
  const rgtX = rightVec.x * cosY + rightVec.z * sinY;
  const rgtZ = -rightVec.x * sinY + rightVec.z * cosY;

  const baseX = trackPoint.x + rightVec.x * lateral;
  const baseY = trackPoint.y + 0.03;
  const baseZ = trackPoint.z + rightVec.z * lateral;

  for (const w of WHEEL_OFFSETS) {
    const wx = baseX + rgtX * w.x + fwdX * w.z;
    const wz = baseZ + rgtZ * w.x + fwdZ * w.z;

    const geo = new THREE.PlaneGeometry(0.3, 0.6);
    const mesh = new THREE.Mesh(geo, skidMat.clone());
    mesh.rotation.x = -Math.PI / 2;
    // Align the mark with car heading
    mesh.rotation.z = -Math.atan2(fwdX, fwdZ) + Math.PI / 2;
    mesh.position.set(wx, baseY, wz);
    scene.add(mesh);
    skidMarks.push({ mesh, born: now });
  }

  // Remove oldest marks if over limit
  while (skidMarks.length > SKID_MAX) {
    const old = skidMarks.shift();
    scene.remove(old.mesh);
    old.mesh.geometry.dispose();
    old.mesh.material.dispose();
  }
}

function updateSkidMarks() {
  const now = performance.now() * 0.001;
  for (let i = skidMarks.length - 1; i >= 0; i--) {
    const mark = skidMarks[i];
    const age = now - mark.born;
    if (age > SKID_FADE_TIME) {
      scene.remove(mark.mesh);
      mark.mesh.geometry.dispose();
      mark.mesh.material.dispose();
      skidMarks.splice(i, 1);
    } else {
      mark.mesh.material.opacity = 0.7 * (1 - age / SKID_FADE_TIME);
    }
  }
}

// ── AI CARS ──
function buildAICars() {
  aiCars = [];
  const aiColors = [0xff3333, 0x33aaff, 0xffaa00, 0xaa33ff, 0x33ff88];

  // Load the same GLB model used by the player
  const loader = new THREE.GLTFLoader();
  loader.load('base_basic_shaded.glb', (gltf) => {
    for (let i = 0; i < CFG.aiCount; i++) {
      const group = new THREE.Group();
      const model = gltf.scene.clone(true);

      // Tint the model with AI color
      const aiColor = new THREE.Color(aiColors[i % aiColors.length]);
      model.traverse((child) => {
        if (child.isMesh) {
          child.material = child.material.clone();
          child.material.color.copy(aiColor);
          child.material.emissive = aiColor.clone().multiplyScalar(0.3);
          child.material.emissiveIntensity = 0.6;
        }
      });

      // Auto-center and scale (same as player car)
      const box = new THREE.Box3().setFromObject(model);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const targetLength = 8;
      const maxDim = Math.max(size.x, size.y, size.z);
      const s = targetLength / maxDim;
      model.scale.setScalar(s);
      box.setFromObject(model);
      box.getCenter(center);
      model.position.sub(center);
      box.setFromObject(model);
      model.position.y -= box.min.y;

      group.add(model);

      // Neon underglow matching car color
      const ugLight = new THREE.PointLight(aiColors[i % aiColors.length], 1.5, 8);
      ugLight.position.set(0, -0.1, 0);
      group.add(ugLight);

      scene.add(group);

      // Stagger starting positions: AI cars start AHEAD of player (player is last)
      const startProgress = 0.005 * (i + 1);
      // Each AI has a different base speed
      const baseSpeed = CFG.aiMinSpeed + (CFG.aiMaxSpeed - CFG.aiMinSpeed) * (i / Math.max(1, CFG.aiCount - 1));

      aiCars.push({
        group: group,
        progress: startProgress,
        speed: 0,
        baseSpeed: baseSpeed,
        // spread across the road
        lateral: (i - 2) * 3,
        weavePhase: Math.random() * Math.PI * 2,
        boostTimer: 0,
        finished: false,
      });
    }
  });
}

function updateAICar(ai, dt) {
  if (ai.finished) return;

  // Accelerate toward base speed
  if (ai.speed < ai.baseSpeed) {
    ai.speed += CFG.accel * 0.8 * dt;
  } else {
    ai.speed -= CFG.friction * dt;
  }
  ai.speed = Math.max(0, ai.speed);

  // Boost pad detection for AI
  const padHitZone = (CFG.boostPadLength / trackLength) / 2;
  for (let bp of boostPads) {
    if (Math.abs(ai.progress - bp.t) < padHitZone && ai.boostTimer <= 0) {
      // slightly shorter AI boost
      ai.boostTimer = CFG.boostDuration * 0.8;
    }
  }
  if (ai.boostTimer > 0) {
    ai.boostTimer -= dt;
    ai.speed = Math.max(ai.speed, CFG.boostSpeed * 0.9);
  }

  // Add slight speed variation (personality)
  const speedVariation = Math.sin(performance.now() * 0.001 + ai.weavePhase * 10) * 8;
  const effectiveSpeed = ai.speed + speedVariation;

  // Progress along track
  const metersPerSec = Math.max(0, effectiveSpeed) / 3.6;
  ai.progress += (metersPerSec * dt) / trackLength;

  // Lateral weaving
  ai.lateral = Math.sin(performance.now() * 0.001 * CFG.aiWeaveFreq + ai.weavePhase) * CFG.aiWeaveAmp;

  // Finish check
  if (ai.progress >= 1) {
    ai.progress = 1;
    ai.finished = true;
  }

  // Position the car on track
  const t = Math.max(0, Math.min(0.9999, ai.progress));
  const point = curve.getPointAt(t);
  const tangent = curve.getTangentAt(t).normalize();
  const up = new THREE.Vector3(0, 1, 0);
  const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
  if (right.length() < 0.1) right.set(1, 0, 0);

  ai.group.position.set(
    point.x + right.x * ai.lateral,
    point.y + 0.15,
    point.z + right.z * ai.lateral
  );

  const lookTarget = new THREE.Vector3(
    point.x + tangent.x * 5 + right.x * ai.lateral,
    point.y + tangent.y * 5,
    point.z + tangent.z * 5 + right.z * ai.lateral
  );
  ai.group.lookAt(lookTarget);
}

function calcPosition() {
  let pos = 1;
  for (let ai of aiCars) {
    if (ai.progress > trackProgress) pos++;
  }
  return pos;
}

function positionSuffix(n) {
  if (n === 1) return 'st';
  if (n === 2) return 'nd';
  if (n === 3) return 'rd';
  return 'th';
}

function checkCollisions(dt) {
  // car length in world units
  const carLength = 8;
  // car width in world units
  const carWidth = 2.5;
  // Convert car length to track-progress units
  const halfLenT = (carLength / trackLength) / 2;

  for (let ai of aiCars) {
    // Check longitudinal overlap (track progress)
    const dProgress = Math.abs(trackProgress - ai.progress);
    // too far apart along track
    if (dProgress > halfLenT * 2) continue;

    // Check lateral overlap
    const dLateral = Math.abs(lateralOffset - ai.lateral);
    // too far apart sideways
    if (dLateral > carWidth * 2) continue;

    // Collision! Apply effects
    // Determine who is ahead
    if (trackProgress > ai.progress) {
      // Player is ahead — slow AI, slight push forward for player
      ai.speed *= 0.7;
      speed = Math.max(speed, speed * 0.95);
    } else {
      // AI is ahead — slow player down on impact
      speed *= 0.85;
    }

    // Lateral push — push cars apart
    const pushDir = (lateralOffset > ai.lateral) ? 1 : -1;
    const pushStrength = 15 * dt;
    lateralOffset += pushDir * pushStrength;
    ai.lateral -= pushDir * pushStrength * 0.5;

    // Clamp lateral
    lateralOffset = Math.max(-CFG.maxLateral, Math.min(CFG.maxLateral, lateralOffset));
    ai.lateral = Math.max(-CFG.maxLateral, Math.min(CFG.maxLateral, ai.lateral));

    // Small progress separation to prevent sticking
    if (Math.abs(trackProgress - ai.progress) < halfLenT * 0.5) {
      if (trackProgress > ai.progress) {
        trackProgress += halfLenT * 0.1;
      } else {
        ai.progress += halfLenT * 0.1;
      }
    }
  }
}

// ── ENVIRONMENT ──
function buildEnvironment() {
  // Ground plane
  const groundGeo = new THREE.PlaneGeometry(8000, 8000);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x050010,
    roughness: 1,
    metalness: 0,
  });
  groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI/2;
  groundMesh.position.y = -2;
  scene.add(groundMesh);

  // Grid lines on ground
  const gridHelper = new THREE.GridHelper(4000, 200, 0x1a0040, 0x0a0020);
  gridHelper.position.y = -1.9;
  scene.add(gridHelper);

  // Starfield
  const starCount = 2000;
  const starGeo = new THREE.BufferGeometry();
  const starPositions = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount; i++) {
    starPositions[i*3] = (Math.random() - 0.5) * 4000;
    starPositions[i*3+1] = Math.random() * 400 + 20;
    starPositions[i*3+2] = (Math.random() - 0.5) * 4000;
  }
  starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: true });
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // Decorative neon pillars along the track
  buildTrackDecorations();
}

function buildTrackDecorations() {
  const pillarGeo = new THREE.CylinderGeometry(0.12, 0.12, 8, 6);
  const glowOrbGeo = new THREE.SphereGeometry(0.35, 8, 8);
  const neonColors = [0xff6ec7, 0x00ffff, 0xffd700, 0x6e3cff];
  const halfWidth = CFG.roadWidth / 2;
  const count = 120;

  // Pre-create materials for reuse
  const pillarMats = neonColors.map(c => new THREE.MeshStandardMaterial({
    color: 0x111122,
    emissive: new THREE.Color(c),
    emissiveIntensity: 0.15,
    metalness: 0.9,
    roughness: 0.3,
  }));
  const orbMats = neonColors.map(c => new THREE.MeshBasicMaterial({ color: c }));

  for (let i = 0; i < count; i++) {
    const t = i / count;
    const point = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
    if (right.length() < 0.1) continue;

    const side = (i % 2 === 0) ? -1 : 1;
    const ci = i % neonColors.length;

    // Dark pillar with faint emissive
    const pillar = new THREE.Mesh(pillarGeo, pillarMats[ci]);
    pillar.position.set(
      point.x + right.x * (halfWidth + 3) * side,
      point.y + 4,
      point.z + right.z * (halfWidth + 3) * side
    );
    scene.add(pillar);

    // Bright glowing orb on top — this blooms hard
    const orb = new THREE.Mesh(glowOrbGeo, orbMats[ci]);
    orb.position.set(pillar.position.x, pillar.position.y + 4.3, pillar.position.z);
    scene.add(orb);
  }
}

// ── INPUT ──
function setupInput() {
  // Keyboard
  document.addEventListener('keydown', e => { keys[e.code] = true; });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  // Touch steering (left/right halves of screen)
  let touchSteer = 0;
  document.addEventListener('touchstart', handleTouch, { passive: false });
  document.addEventListener('touchmove', handleTouch, { passive: false });
  document.addEventListener('touchend', () => { touchSteer = 0; });

  function handleTouch(e) {
    if (gameState !== 'racing') return;
    e.preventDefault();
    const touch = e.touches[0];
    if (!touch) { touchSteer = 0; return; }
    const x = touch.clientX / innerWidth;
    // -1 to 1
    touchSteer = (x - 0.5) * 2;
  }

  // Update steer input each frame
  window._getTouchSteer = () => touchSteer;
}

function requestGyro() {
  if (typeof DeviceOrientationEvent !== 'undefined' &&
      typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission().then(state => {
      if (state === 'granted') enableGyro();
    }).catch(() => {});
  } else {
    enableGyro();
  }
}

function enableGyro() {
  let samples = 0;
  let sumAbs = 0;
  window.addEventListener('deviceorientation', e => {
    const g = e.gamma || 0;
    gyroGamma = g;
    // Only mark gyro as available after seeing strong, consistent real tilt data
    // Requires 20 samples averaging > 5 degrees to avoid false positives
    if (!gyroAvailable) {
      samples++;
      sumAbs += Math.abs(g);
      if (samples >= 20 && (sumAbs / samples) > 5) {
        gyroAvailable = true;
        $tiltIndicator.style.display = 'block';
      }
    }
  });
}

function getSteerInput() {
  // Keyboard always takes priority (explicit digital input)
  if (keys['ArrowLeft'] || keys['KeyA']) return -1;
  if (keys['ArrowRight'] || keys['KeyD']) return 1;

  // Touch takes next priority
  const ts = window._getTouchSteer ? window._getTouchSteer() : 0;
  if (Math.abs(ts) > 0.05) return Math.max(-1, Math.min(1, ts));

  // Gyro only used if no keyboard/touch active
  if (gyroAvailable) {
    const adjusted = gyroGamma - gyroCal;
    if (Math.abs(adjusted) < DEADZONE) return 0;
    const raw = (adjusted - Math.sign(adjusted) * DEADZONE) / (15 - DEADZONE);
    return Math.max(-1, Math.min(1, raw));
  }

  return 0;
}

function getBrakeInput() {
  return (keys['ArrowDown'] || keys['KeyS'] || keys['Space']) ? 1 : 0;
}

// ── UI ──
function setupUI() {
  $startBtn.addEventListener('click', startRace);
  $restartBtn.addEventListener('click', restartRace);

  // Drift button — hold to engage
  const $driftBtn = document.getElementById('drift-btn');
  $driftBtn.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    driftBtnHeld = true;
  });
  $driftBtn.addEventListener('pointerup', () => { driftBtnHeld = false; });
  $driftBtn.addEventListener('pointercancel', () => { driftBtnHeld = false; });
  $driftBtn.addEventListener('pointerleave', () => { driftBtnHeld = false; });
}

function startRace() {
  requestGyro();
  gyroCal = gyroGamma;
  $startScreen.style.display = 'none';
  gameState = 'countdown';
  doCountdown();
}

function doCountdown() {
  $countdown.style.display = 'block';
  let count = 3;
  $countdown.textContent = count;

  const interval = setInterval(() => {
    count--;
    if (count > 0) {
      $countdown.textContent = count;
    } else if (count === 0) {
      $countdown.textContent = 'GO!';
      $countdown.style.color = '#0f0';
    } else {
      clearInterval(interval);
      $countdown.style.display = 'none';
      $countdown.style.color = '#fff';
      gameState = 'racing';
      raceStartTime = performance.now();
      $hud.style.display = 'flex';
      $positionHud.style.display = '';
      document.getElementById('drift-btn').style.display = '';
      if (gyroAvailable) $tiltIndicator.style.display = 'block';
    }
  }, 800);
}

function finishRace() {
  gameState = 'finished';
  $hud.style.display = 'none';
  $positionHud.style.display = 'none';
  $tiltIndicator.style.display = 'none';
  document.getElementById('drift-btn').style.display = 'none';
  document.getElementById('drift-hud').style.display = 'none';
  driftState = 'grip';
  driftAngle = 0;
  const t = raceTime;
  const min = Math.floor(t / 60);
  const sec = (t % 60).toFixed(2);
  $finalTime.textContent = min + ':' + (sec < 10 ? '0' : '') + sec;
  // Show final position
  const pos = calcPosition();
  document.querySelector('#finish-screen .label').textContent =
    'You finished ' + pos + positionSuffix(pos) + ' out of ' + (CFG.aiCount + 1);
  $finishScreen.style.display = 'flex';
}

function restartRace() {
  $finishScreen.style.display = 'none';
  speed = 0;
  trackProgress = 0;
  lateralOffset = 0;
  steerInput = 0;
  raceTime = 0;
  boostTimer = 0;
  playerPosition = 1;
  driftState = 'grip';
  driftSign = 0;
  driftAngle = 0;
  driftBtnHeld = false;
  freeRoam = false;
  freeHeading = 0;
  freePos.set(0, 0, 0);
  // Clear skid marks
  for (const mark of skidMarks) {
    scene.remove(mark.mesh);
    mark.mesh.geometry.dispose();
    mark.mesh.material.dispose();
  }
  skidMarks.length = 0;
  for (let bp of boostPads) { bp.active = false; }
  // Reset AI cars
  for (let i = 0; i < aiCars.length; i++) {
    aiCars[i].progress = 0.005 * (i + 1);
    aiCars[i].speed = 0;
    aiCars[i].boostTimer = 0;
    aiCars[i].finished = false;
    aiCars[i].lateral = (i - 2) * 3;
  }
  updateCarPosition(0, 0);
  updateCamera(true);
  startRace();
}

function formatTime(t) {
  const min = Math.floor(t / 60);
  const sec = Math.floor(t % 60);
  const ms = Math.floor((t * 10) % 10);
  return min + ':' + (sec < 10 ? '0' : '') + sec + '.' + ms;
}

// ── CAR POSITION ──
function updateCarPosition(progress, lateral) {
  const t = Math.max(0, Math.min(0.9999, progress));
  const point = curve.getPointAt(t);
  const tangent = curve.getTangentAt(t).normalize();
  const up = new THREE.Vector3(0, 1, 0);
  const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
  if (right.length() < 0.1) right.set(1, 0, 0);

  if (freeRoam) {
    // ── FREE-ROAM MODE ──
    // Steer heading with gyro/input
    const turnRate = 2.5;
    freeHeading += -steerInput * turnRate * frameDt;

    // Move forward along current heading
    const effectiveSpeed = boostTimer > 0 ? Math.max(speed, CFG.boostSpeed) : speed;
    const mps = effectiveSpeed / 3.6;
    const dx = Math.sin(freeHeading) * mps * frameDt;
    const dz = Math.cos(freeHeading) * mps * frameDt;
    freePos.x += dx;
    freePos.z += dz;

    // Sample track height at nearest point for ground following
    // Use the rail point Y as approximate ground
    freePos.y = point.y + 0.15;

    carGroup.position.copy(freePos);

    // Orient car along heading
    const lookAhead = new THREE.Vector3(
      freePos.x + Math.sin(freeHeading) * 5,
      freePos.y,
      freePos.z + Math.cos(freeHeading) * 5
    );
    carGroup.lookAt(lookAhead);

    // Apply yaw (drift or steer visual rotation)
    let targetYaw;
    if (driftState === 'drift') {
      targetYaw = -driftAngle * (Math.PI / 180);
    } else {
      targetYaw = -steerInput * (15 * Math.PI / 180);
    }
    smoothYaw += (targetYaw - smoothYaw) * 0.08;
    carGroup.rotateY(smoothYaw);

    // Spawn skid marks during drift
    if (driftState === 'drift') {
      spawnSkidMarks(freePos, right, 0);
    }
  } else {
    // ── RAIL MODE ──
    carGroup.position.set(
      point.x + right.x * lateral,
      point.y + 0.15,
      point.z + right.z * lateral
    );

    // Orient car along track direction
    const lookTarget = new THREE.Vector3(
      point.x + tangent.x * 5 + right.x * lateral,
      point.y + tangent.y * 5,
      point.z + tangent.z * 5 + right.z * lateral
    );
    carGroup.lookAt(lookTarget);

    // Smoothly lerp car yaw — clamp to 15° normally, full driftAngle (up to 45°) when drifting
    let targetYaw;
    if (driftState === 'drift') {
      targetYaw = -driftAngle * (Math.PI / 180);
    } else {
      targetYaw = -steerInput * (15 * Math.PI / 180);
    }
    smoothYaw += (targetYaw - smoothYaw) * 0.08;
    carGroup.rotateY(smoothYaw);

    // Spawn skid marks during drift
    if (driftState === 'drift') {
      spawnSkidMarks(point, right, lateral);
    }
  }
}

// ── CAMERA ──
const camPos = new THREE.Vector3();
const camTarget = new THREE.Vector3();

function updateCamera(instant) {
  let idealPos, idealTarget;

  if (freeRoam) {
    // Free-roam camera: behind car along its heading
    const behindX = -Math.sin(freeHeading) * CFG.cameraDist;
    const behindZ = -Math.cos(freeHeading) * CFG.cameraDist;
    idealPos = new THREE.Vector3(
      freePos.x + behindX,
      Math.max(freePos.y + CFG.cameraHeight, 0),
      freePos.z + behindZ
    );
    idealTarget = new THREE.Vector3(
      freePos.x + Math.sin(freeHeading) * 10,
      freePos.y + 1,
      freePos.z + Math.cos(freeHeading) * 10
    );
  } else {
    const t = Math.max(0, Math.min(0.9999, trackProgress));
    const point = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
    if (right.length() < 0.1) right.set(1, 0, 0);

    // Camera behind and above car
    // Sample the track point where the camera would be (behind the car)
    // to get the correct elevation for downhill sections
    const camT = Math.max(0, Math.min(0.9999, t - (CFG.cameraDist / trackLength)));
    const camTrackPoint = curve.getPointAt(camT);
    // Use the higher of: car's point or the behind-point, so camera doesn't dip below track
    const camBaseY = Math.max(point.y, camTrackPoint.y);

    idealPos = new THREE.Vector3(
      point.x - tangent.x * CFG.cameraDist + right.x * lateralOffset * 0.5,
      // Ensure camera never goes below ground plane (-2) + minimum clearance
      Math.max(camBaseY + CFG.cameraHeight, -2 + 2),
      point.z - tangent.z * CFG.cameraDist + right.z * lateralOffset * 0.5
    );

    idealTarget = new THREE.Vector3(
      point.x + tangent.x * 10 + right.x * lateralOffset,
      point.y + 1,
      point.z + tangent.z * 10 + right.z * lateralOffset
    );
  }

  if (instant) {
    camPos.copy(idealPos);
    camTarget.copy(idealTarget);
  } else {
    camPos.lerp(idealPos, CFG.cameraLerp);
    camTarget.lerp(idealTarget, CFG.cameraLerp);
  }

  camera.position.copy(camPos);
  camera.lookAt(camTarget);
}

// ── GAME LOOP ──
let lastTime = 0;
let frameDt = 0;
function animate(now = 0) {
  requestAnimationFrame(animate);
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  frameDt = dt;
  lastTime = now;

  if (gameState === 'racing') {
    // Timing
    raceTime = (performance.now() - raceStartTime) / 1000;
    $timeVal.textContent = formatTime(raceTime);

    // Steering
    steerInput = getSteerInput();
    const braking = getBrakeInput();

    // ── DRIFT STATE MACHINE ──
    const $driftHud = document.getElementById('drift-hud');
    if (driftState === 'grip') {
      // Enter drift: drift button held + steering + enough speed
      if (driftBtnHeld && Math.abs(steerInput) > CFG.driftEnterSteer && speed > CFG.driftMinSpeed) {
        driftState = 'drift';
        driftSign = Math.sign(steerInput);
        $driftHud.style.display = '';
      }
    } else {
      // Exit drift: release drift button or straighten steering at low slip
      if (!driftBtnHeld || (Math.abs(driftAngle) < 4 && Math.abs(steerInput) < CFG.driftExitSteer)) {
        // Exit snap: small speed boost on clean exit
        if (speed > CFG.driftMinSpeed) {
          speed += CFG.driftExitSnap * speed;
        }
        driftState = 'grip';
        driftAngle = 0;
        driftSign = 0;
        $driftHud.style.display = 'none';
      }
    }

    // ── APPLY STEERING ──
    const wasFreeRoam = freeRoam;
    freeRoam = document.getElementById('free-roam-cb').checked;
    // On transition to free-roam, snapshot current world position & heading
    if (freeRoam && !wasFreeRoam) {
      freePos.copy(carGroup.position);
      const tang = curve.getTangentAt(Math.max(0, Math.min(0.9999, trackProgress))).normalize();
      freeHeading = Math.atan2(tang.x, tang.z);
    }
    if (driftState === 'drift') {
      // Update drift direction to follow gyro/steer input in real-time
      if (Math.abs(steerInput) > 0.1) {
        driftSign = Math.sign(steerInput);
      }
      // Desired slip angle: base + steer influence
      const desiredSlip = driftSign * (CFG.driftBaseSlip + CFG.driftKSteer * Math.abs(steerInput));
      const clampedDesired = Math.max(-CFG.driftMaxSlip, Math.min(CFG.driftMaxSlip, desiredSlip));

      // Assist: nudge drift angle toward desired (prevents spinout)
      const slipErr = clampedDesired - driftAngle;
      const yawAssist = Math.max(-CFG.driftMaxAssist, Math.min(CFG.driftMaxAssist, slipErr * CFG.driftAssistGain));
      driftAngle += yawAssist * dt * 60;

      if (!freeRoam) {
        // Reduced lateral grip during drift
        const driftLateralMove = steerInput * CFG.steerSpeed * CFG.driftLateralGrip * dt * (speed / CFG.maxSpeed + 0.3);
        lateralOffset += driftLateralMove;
        lateralOffset = Math.max(-CFG.maxLateral, Math.min(CFG.maxLateral, lateralOffset));
      }
    } else if (!freeRoam) {
      lateralOffset += steerInput * CFG.steerSpeed * dt * (speed / CFG.maxSpeed + 0.3);
      lateralOffset = Math.max(-CFG.maxLateral, Math.min(CFG.maxLateral, lateralOffset));
    }

    // Speed: always accelerating (auto-gas)
    if (braking) {
      speed -= CFG.brake * dt;
    } else {
      speed += CFG.accel * dt;
    }
    speed -= CFG.friction * dt;

    // Drift speed bleed: mild drag while sliding (arcade — keeps most speed)
    if (driftState === 'drift') {
      const slipFactor = Math.abs(driftAngle) / CFG.driftMaxSlip;
      speed -= CFG.driftSpeedBleed * slipFactor * speed * dt;
      // Protect forward speed (arcade): apply longitudinal grip preservation
      speed = Math.max(speed, speed * CFG.driftLongGrip);
    }

    speed = Math.max(0, Math.min(CFG.maxSpeed, speed));

    // Boost pad detection — hit zone matches the visual pad length
    const padHitZone = (CFG.boostPadLength / trackLength) / 2;
    for (let bp of boostPads) {
      if (Math.abs(trackProgress - bp.t) < padHitZone && !bp.active) {
        bp.active = true;
        boostTimer = CFG.boostDuration;
      }
    }
    // Reset active flag once car passes through
    for (let bp of boostPads) {
      if (bp.active && Math.abs(trackProgress - bp.t) >= padHitZone) {
        bp.active = false;
      }
    }

    // Apply boost
    if (boostTimer > 0) {
      boostTimer -= dt;
      speed = Math.max(speed, CFG.boostSpeed);
      document.getElementById('boost-hud').style.display = '';
    } else {
      document.getElementById('boost-hud').style.display = 'none';
    }

    // Animate boost pads (pulse glow)
    const pulse = 0.4 + Math.sin(performance.now() * 0.005) * 0.15;
    for (let bp of boostPads) {
      bp.group.children[0].material.opacity = pulse;
    }

    // Progress along track
    const effectiveSpeed = boostTimer > 0 ? Math.max(speed, CFG.boostSpeed) : speed;
    const metersPerSec = effectiveSpeed / 3.6;
    trackProgress += (metersPerSec * dt) / trackLength;

    // Update AI cars
    for (let ai of aiCars) {
      updateAICar(ai, dt);
    }

    // Check collisions between player and AI
    checkCollisions(dt);

    // Update position
    playerPosition = calcPosition();
    $posNum.textContent = playerPosition;
    $posSuffix.textContent = positionSuffix(playerPosition);

    // Update HUD
    $speedVal.textContent = Math.round(speed);
    $progressVal.textContent = Math.round(trackProgress * 100) + '%';

    // Update tilt indicator
    if (gyroAvailable) {
      const pct = 50 + (steerInput * 40);
      $tiltDot.style.left = pct + '%';
    }

    // Check finish
    if (trackProgress >= 1) {
      trackProgress = 1;
      finishRace();
    }

    updateCarPosition(trackProgress, lateralOffset);
  }

  updateSkidMarks();
  updateCamera(false);

  // Move ground to follow camera loosely
  if (groundMesh) {
    groundMesh.position.x = camera.position.x;
    groundMesh.position.z = camera.position.z;
  }

  composer.render();
}

})();
</script>
</body>
</html>
